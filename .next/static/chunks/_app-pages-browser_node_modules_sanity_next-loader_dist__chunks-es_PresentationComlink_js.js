"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_sanity_next-loader_dist__chunks-es_PresentationComlink_js"],{

/***/ "(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/observable/defer.js":
/*!******************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/observable/defer.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defer: function() { return /* binding */ defer; }\n/* harmony export */ });\n/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Observable */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/Observable.js\");\n/* harmony import */ var _innerFrom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./innerFrom */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js\");\n\n\nfunction defer(observableFactory) {\n    return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function(subscriber) {\n        (0,_innerFrom__WEBPACK_IMPORTED_MODULE_1__.innerFrom)(observableFactory()).subscribe(subscriber);\n    });\n} //# sourceMappingURL=defer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vYnNlcnZhYmxlL2RlZmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEyQztBQUVIO0FBa0RsQyxTQUFVRSxNQUFzQ0MsaUJBQTBCO0lBQzlFLE9BQU8sSUFBSUgsbURBQUFBLENBQStCLFNBQUNJLFVBQVU7UUFDbkRILHFEQUFBQSxDQUFVRSxxQkFBcUJFLFNBQVMsQ0FBQ0Q7SUFDM0M7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vc3JjL2ludGVybmFsL29ic2VydmFibGUvZGVmZXIudHM/OTIyYSJdLCJuYW1lcyI6WyJPYnNlcnZhYmxlIiwiaW5uZXJGcm9tIiwiZGVmZXIiLCJvYnNlcnZhYmxlRmFjdG9yeSIsInN1YnNjcmliZXIiLCJzdWJzY3JpYmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/observable/defer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/observable/empty.js":
/*!******************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/observable/empty.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EMPTY: function() { return /* binding */ EMPTY; },\n/* harmony export */   empty: function() { return /* binding */ empty; }\n/* harmony export */ });\n/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Observable */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/Observable.js\");\n\nvar EMPTY = new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function(subscriber) {\n    return subscriber.complete();\n});\nfunction empty(scheduler) {\n    return scheduler ? emptyScheduled(scheduler) : EMPTY;\n}\nfunction emptyScheduled(scheduler) {\n    return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function(subscriber) {\n        return scheduler.schedule(function() {\n            return subscriber.complete();\n        });\n    });\n} //# sourceMappingURL=empty.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vYnNlcnZhYmxlL2VtcHR5LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEyQztBQWlFcEMsSUFBTUMsUUFBUSxJQUFJRCxtREFBQUEsQ0FBa0IsU0FBQ0UsVUFBVTtJQUFLLE9BQUFBLFdBQVdDLFFBQVE7QUFBbkIsR0FBdUI7QUFPNUUsU0FBVUMsTUFBTUMsU0FBeUI7SUFDN0MsT0FBT0EsWUFBWUMsZUFBZUQsYUFBYUo7QUFDakQ7QUFFQSxTQUFTSyxlQUFlRCxTQUF3QjtJQUM5QyxPQUFPLElBQUlMLG1EQUFBQSxDQUFrQixTQUFDRSxVQUFVO1FBQUssT0FBQUcsVUFBVUUsUUFBUSxDQUFDO1lBQU0sT0FBQUwsV0FBV0MsUUFBUTtRQUFuQjtJQUF6QjtBQUMvQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vc3JjL2ludGVybmFsL29ic2VydmFibGUvZW1wdHkudHM/MDkyOSJdLCJuYW1lcyI6WyJPYnNlcnZhYmxlIiwiRU1QVFkiLCJzdWJzY3JpYmVyIiwiY29tcGxldGUiLCJlbXB0eSIsInNjaGVkdWxlciIsImVtcHR5U2NoZWR1bGVkIiwic2NoZWR1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/observable/empty.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/observable/fromEvent.js":
/*!**********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/observable/fromEvent.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromEvent: function() { return /* binding */ fromEvent; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _observable_innerFrom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../observable/innerFrom */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js\");\n/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Observable */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/Observable.js\");\n/* harmony import */ var _operators_mergeMap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../operators/mergeMap */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js\");\n/* harmony import */ var _util_isArrayLike__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/isArrayLike */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js\");\n/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/isFunction */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/util/isFunction.js\");\n/* harmony import */ var _util_mapOneOrManyArgs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/mapOneOrManyArgs */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js\");\n\n\n\n\n\n\n\nvar nodeEventEmitterMethods = [\n    \"addListener\",\n    \"removeListener\"\n];\nvar eventTargetMethods = [\n    \"addEventListener\",\n    \"removeEventListener\"\n];\nvar jqueryMethods = [\n    \"on\",\n    \"off\"\n];\nfunction fromEvent(target, eventName, options, resultSelector) {\n    if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(options)) {\n        resultSelector = options;\n        options = undefined;\n    }\n    if (resultSelector) {\n        return fromEvent(target, eventName, options).pipe((0,_util_mapOneOrManyArgs__WEBPACK_IMPORTED_MODULE_1__.mapOneOrManyArgs)(resultSelector));\n    }\n    var _a = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__read)(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {\n        return function(handler) {\n            return target[methodName](eventName, handler, options);\n        };\n    }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add = _a[0], remove = _a[1];\n    if (!add) {\n        if ((0,_util_isArrayLike__WEBPACK_IMPORTED_MODULE_3__.isArrayLike)(target)) {\n            return (0,_operators_mergeMap__WEBPACK_IMPORTED_MODULE_4__.mergeMap)(function(subTarget) {\n                return fromEvent(subTarget, eventName, options);\n            })((0,_observable_innerFrom__WEBPACK_IMPORTED_MODULE_5__.innerFrom)(target));\n        }\n    }\n    if (!add) {\n        throw new TypeError(\"Invalid event target\");\n    }\n    return new _Observable__WEBPACK_IMPORTED_MODULE_6__.Observable(function(subscriber) {\n        var handler = function() {\n            var args = [];\n            for(var _i = 0; _i < arguments.length; _i++){\n                args[_i] = arguments[_i];\n            }\n            return subscriber.next(1 < args.length ? args : args[0]);\n        };\n        add(handler);\n        return function() {\n            return remove(handler);\n        };\n    });\n}\nfunction toCommonHandlerRegistry(target, eventName) {\n    return function(methodName) {\n        return function(handler) {\n            return target[methodName](eventName, handler);\n        };\n    };\n}\nfunction isNodeStyleEventEmitter(target) {\n    return (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(target.addListener) && (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(target.removeListener);\n}\nfunction isJQueryStyleEventEmitter(target) {\n    return (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(target.on) && (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(target.off);\n}\nfunction isEventTarget(target) {\n    return (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(target.addEventListener) && (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(target.removeEventListener);\n} //# sourceMappingURL=fromEvent.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vYnNlcnZhYmxlL2Zyb21FdmVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBb0Q7QUFDVDtBQUNNO0FBQ0M7QUFDRjtBQUNZO0FBRzVELElBQU1NLDBCQUEwQjtJQUFDO0lBQWU7Q0FBMEI7QUFDMUUsSUFBTUMscUJBQXFCO0lBQUM7SUFBb0I7Q0FBK0I7QUFDL0UsSUFBTUMsZ0JBQWdCO0lBQUM7SUFBTTtDQUFlO0FBa090QyxTQUFVQyxVQUNkQyxNQUFXLEVBQ1hDLFNBQWlCLEVBQ2pCQyxPQUF3RCxFQUN4REMsY0FBc0M7SUFFdEMsSUFBSVQsNERBQUFBLENBQVdRLFVBQVU7UUFDdkJDLGlCQUFpQkQ7UUFDakJBLFVBQVVFOztJQUVaLElBQUlELGdCQUFnQjtRQUNsQixPQUFPSixVQUFhQyxRQUFRQyxXQUFXQyxTQUFpQ0csSUFBSSxDQUFDVix3RUFBQUEsQ0FBaUJROztJQVUxRixJQUFBRyxLQUFBQyw2Q0FBQUEsQ0FFSkMsY0FBY1IsVUFDVkgsbUJBQW1CWSxHQUFHLENBQUMsU0FBQ0MsVUFBVTtRQUFLLGdCQUFDQyxPQUFZO1lBQUssT0FBQVgsTUFBTSxDQUFDVSxXQUFXLENBQUNULFdBQVdVLFNBQVNUO1FBQXZDO0lBQWxCLEtBRXpDVSx3QkFBd0JaLFVBQ3RCSix3QkFBd0JhLEdBQUcsQ0FBQ0ksd0JBQXdCYixRQUFRQyxjQUM1RGEsMEJBQTBCZCxVQUMxQkYsY0FBY1csR0FBRyxDQUFDSSx3QkFBd0JiLFFBQVFDLGNBQ2xELEVBQUUsTUFURGMsTUFBR1QsRUFBQSxLQUFFVSxTQUFNVixFQUFBLEdBU1Y7SUFPUixJQUFJLENBQUNTLEtBQUs7UUFDUixJQUFJdEIsOERBQUFBLENBQVlPLFNBQVM7WUFDdkIsT0FBT1IsNkRBQUFBLENBQVMsU0FBQ3lCLFNBQWM7Z0JBQUssT0FBQWxCLFVBQVVrQixXQUFXaEIsV0FBV0M7WUFBaEMsR0FDbENaLGdFQUFBQSxDQUFVVTs7O0lBT2hCLElBQUksQ0FBQ2UsS0FBSztRQUNSLE1BQU0sSUFBSUcsVUFBVTs7SUFHdEIsT0FBTyxJQUFJM0IsbURBQUFBLENBQWMsU0FBQzRCLFVBQVU7UUFJbEMsSUFBTVIsVUFBVTtZQUFDLElBQUFTLE9BQUE7Z0JBQUEsSUFBQUMsS0FBQSxHQUFBQSxLQUFBQyxVQUFBQyxNQUFjLEVBQWRGLEtBQWM7Z0JBQWRELElBQUEsQ0FBQUMsR0FBQSxHQUFBQyxTQUFBLENBQUFELEdBQUE7O1lBQW1CLE9BQUFGLFdBQVdLLElBQUksQ0FBQyxJQUFJSixLQUFLRyxNQUFNLEdBQUdILE9BQU9BLElBQUksQ0FBQyxFQUFFO1FBQWhEO1FBRXBDTCxJQUFJSjtRQUVKLE9BQU87WUFBTSxPQUFBSyxPQUFRTDtRQUFSO0lBQ2Y7QUFDRjtBQVNBLFNBQVNFLHdCQUF3QmIsTUFBVyxFQUFFQyxTQUFpQjtJQUM3RCxPQUFPLFNBQUNTLFVBQWtCO1FBQUssZ0JBQUNDLE9BQVk7WUFBSyxPQUFBWCxNQUFNLENBQUNVLFdBQVcsQ0FBQ1QsV0FBV1U7UUFBOUI7SUFBbEI7QUFDakM7QUFPQSxTQUFTQyx3QkFBd0JaLE1BQVc7SUFDMUMsT0FBT04sNERBQUFBLENBQVdNLE9BQU95QixXQUFXLEtBQUsvQiw0REFBQUEsQ0FBV00sT0FBTzBCLGNBQWM7QUFDM0U7QUFPQSxTQUFTWiwwQkFBMEJkLE1BQVc7SUFDNUMsT0FBT04sNERBQUFBLENBQVdNLE9BQU8yQixFQUFFLEtBQUtqQyw0REFBQUEsQ0FBV00sT0FBTzRCLEdBQUc7QUFDdkQ7QUFPQSxTQUFTcEIsY0FBY1IsTUFBVztJQUNoQyxPQUFPTiw0REFBQUEsQ0FBV00sT0FBTzZCLGdCQUFnQixLQUFLbkMsNERBQUFBLENBQVdNLE9BQU84QixtQkFBbUI7QUFDckYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3NyYy9pbnRlcm5hbC9vYnNlcnZhYmxlL2Zyb21FdmVudC50cz9jMDYyIl0sIm5hbWVzIjpbImlubmVyRnJvbSIsIk9ic2VydmFibGUiLCJtZXJnZU1hcCIsImlzQXJyYXlMaWtlIiwiaXNGdW5jdGlvbiIsIm1hcE9uZU9yTWFueUFyZ3MiLCJub2RlRXZlbnRFbWl0dGVyTWV0aG9kcyIsImV2ZW50VGFyZ2V0TWV0aG9kcyIsImpxdWVyeU1ldGhvZHMiLCJmcm9tRXZlbnQiLCJ0YXJnZXQiLCJldmVudE5hbWUiLCJvcHRpb25zIiwicmVzdWx0U2VsZWN0b3IiLCJ1bmRlZmluZWQiLCJwaXBlIiwiX2EiLCJfX3JlYWQiLCJpc0V2ZW50VGFyZ2V0IiwibWFwIiwibWV0aG9kTmFtZSIsImhhbmRsZXIiLCJpc05vZGVTdHlsZUV2ZW50RW1pdHRlciIsInRvQ29tbW9uSGFuZGxlclJlZ2lzdHJ5IiwiaXNKUXVlcnlTdHlsZUV2ZW50RW1pdHRlciIsImFkZCIsInJlbW92ZSIsInN1YlRhcmdldCIsIlR5cGVFcnJvciIsInN1YnNjcmliZXIiLCJhcmdzIiwiX2kiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJuZXh0IiwiYWRkTGlzdGVuZXIiLCJyZW1vdmVMaXN0ZW5lciIsIm9uIiwib2ZmIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/observable/fromEvent.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/bufferCount.js":
/*!***********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/bufferCount.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bufferCount: function() { return /* binding */ bufferCount; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/lift */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/util/lift.js\");\n/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./OperatorSubscriber */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js\");\n/* harmony import */ var _util_arrRemove__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/arrRemove */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/util/arrRemove.js\");\n\n\n\n\nfunction bufferCount(bufferSize, startBufferEvery) {\n    if (startBufferEvery === void 0) {\n        startBufferEvery = null;\n    }\n    startBufferEvery = startBufferEvery !== null && startBufferEvery !== void 0 ? startBufferEvery : bufferSize;\n    return (0,_util_lift__WEBPACK_IMPORTED_MODULE_0__.operate)(function(source, subscriber) {\n        var buffers = [];\n        var count = 0;\n        source.subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__.createOperatorSubscriber)(subscriber, function(value) {\n            var e_1, _a, e_2, _b;\n            var toEmit = null;\n            if (count++ % startBufferEvery === 0) {\n                buffers.push([]);\n            }\n            try {\n                for(var buffers_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__values)(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()){\n                    var buffer = buffers_1_1.value;\n                    buffer.push(value);\n                    if (bufferSize <= buffer.length) {\n                        toEmit = toEmit !== null && toEmit !== void 0 ? toEmit : [];\n                        toEmit.push(buffer);\n                    }\n                }\n            } catch (e_1_1) {\n                e_1 = {\n                    error: e_1_1\n                };\n            } finally{\n                try {\n                    if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return)) _a.call(buffers_1);\n                } finally{\n                    if (e_1) throw e_1.error;\n                }\n            }\n            if (toEmit) {\n                try {\n                    for(var toEmit_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__values)(toEmit), toEmit_1_1 = toEmit_1.next(); !toEmit_1_1.done; toEmit_1_1 = toEmit_1.next()){\n                        var buffer = toEmit_1_1.value;\n                        (0,_util_arrRemove__WEBPACK_IMPORTED_MODULE_3__.arrRemove)(buffers, buffer);\n                        subscriber.next(buffer);\n                    }\n                } catch (e_2_1) {\n                    e_2 = {\n                        error: e_2_1\n                    };\n                } finally{\n                    try {\n                        if (toEmit_1_1 && !toEmit_1_1.done && (_b = toEmit_1.return)) _b.call(toEmit_1);\n                    } finally{\n                        if (e_2) throw e_2.error;\n                    }\n                }\n            }\n        }, function() {\n            var e_3, _a;\n            try {\n                for(var buffers_2 = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__values)(buffers), buffers_2_1 = buffers_2.next(); !buffers_2_1.done; buffers_2_1 = buffers_2.next()){\n                    var buffer = buffers_2_1.value;\n                    subscriber.next(buffer);\n                }\n            } catch (e_3_1) {\n                e_3 = {\n                    error: e_3_1\n                };\n            } finally{\n                try {\n                    if (buffers_2_1 && !buffers_2_1.done && (_a = buffers_2.return)) _a.call(buffers_2);\n                } finally{\n                    if (e_3) throw e_3.error;\n                }\n            }\n            subscriber.complete();\n        }, undefined, function() {\n            buffers = null;\n        }));\n    });\n} //# sourceMappingURL=bufferCount.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vcGVyYXRvcnMvYnVmZmVyQ291bnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQ3VDO0FBQ3lCO0FBQ2xCO0FBcUR4QyxTQUFVRyxZQUFlQyxVQUFrQixFQUFFQyxnQkFBc0M7SUFBdEMsSUFBQUEscUJBQUE7UUFBQUEsbUJBQUE7SUFBc0M7SUFHdkZBLG1CQUFtQkEscUJBQWdCLFFBQWhCQSxxQkFBZ0IsU0FBaEJBLG1CQUFvQkQ7SUFFdkMsT0FBT0osbURBQUFBLENBQVEsU0FBQ00sTUFBTSxFQUFFQyxVQUFVO1FBQ2hDLElBQUlDLFVBQWlCLEVBQUU7UUFDdkIsSUFBSUMsUUFBUTtRQUVaSCxPQUFPSSxTQUFTLENBQ2RULDZFQUFBQSxDQUNFTSxZQUNBLFNBQUNJLEtBQUs7O1lBQ0osSUFBSUMsU0FBdUI7WUFLM0IsSUFBSUgsVUFBVUoscUJBQXNCLEdBQUc7Z0JBQ3JDRyxRQUFRSyxJQUFJLENBQUMsRUFBRTs7O2dCQUlqQixJQUFxQixJQUFBQyxZQUFBQywrQ0FBQUEsQ0FBQVAsVUFBT1EsY0FBQUYsVUFBQUcsSUFBQSxLQUFBRCxZQUFBRSxJQUFBLEVBQUFGLGNBQUFGLFVBQUFHLElBQUEsR0FBRTtvQkFBekIsSUFBTUUsU0FBTUgsWUFBQUwsS0FBQTtvQkFDZlEsT0FBT04sSUFBSSxDQUFDRjtvQkFNWixJQUFJUCxjQUFjZSxPQUFPQyxNQUFNLEVBQUU7d0JBQy9CUixTQUFTQSxXQUFNLFFBQU5BLFdBQU0sU0FBTkEsU0FBVSxFQUFFO3dCQUNyQkEsT0FBT0MsSUFBSSxDQUFDTTs7Ozs7Ozs7Ozs7Ozs7WUFJaEIsSUFBSVAsUUFBUTs7b0JBSVYsSUFBcUIsSUFBQVMsV0FBQU4sK0NBQUFBLENBQUFILFNBQU1VLGFBQUFELFNBQUFKLElBQUEsS0FBQUssV0FBQUosSUFBQSxFQUFBSSxhQUFBRCxTQUFBSixJQUFBLEdBQUU7d0JBQXhCLElBQU1FLFNBQU1HLFdBQUFYLEtBQUE7d0JBQ2ZULDBEQUFBQSxDQUFVTSxTQUFTVzt3QkFDbkJaLFdBQVdVLElBQUksQ0FBQ0U7Ozs7Ozs7Ozs7Ozs7O1FBR3RCLEdBQ0E7OztnQkFHRSxJQUFxQixJQUFBSSxZQUFBUiwrQ0FBQUEsQ0FBQVAsVUFBT2dCLGNBQUFELFVBQUFOLElBQUEsS0FBQU8sWUFBQU4sSUFBQSxFQUFBTSxjQUFBRCxVQUFBTixJQUFBLEdBQUU7b0JBQXpCLElBQU1FLFNBQU1LLFlBQUFiLEtBQUE7b0JBQ2ZKLFdBQVdVLElBQUksQ0FBQ0U7Ozs7Ozs7Ozs7Ozs7WUFFbEJaLFdBQVdrQixRQUFRO1FBQ3JCLEdBRUFDLFdBQ0E7WUFFRWxCLFVBQVU7UUFDWjtJQUdOO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvYnVmZmVyQ291bnQudHM/YjUzMiJdLCJuYW1lcyI6WyJvcGVyYXRlIiwiY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyIiwiYXJyUmVtb3ZlIiwiYnVmZmVyQ291bnQiLCJidWZmZXJTaXplIiwic3RhcnRCdWZmZXJFdmVyeSIsInNvdXJjZSIsInN1YnNjcmliZXIiLCJidWZmZXJzIiwiY291bnQiLCJzdWJzY3JpYmUiLCJ2YWx1ZSIsInRvRW1pdCIsInB1c2giLCJidWZmZXJzXzEiLCJfX3ZhbHVlcyIsImJ1ZmZlcnNfMV8xIiwibmV4dCIsImRvbmUiLCJidWZmZXIiLCJsZW5ndGgiLCJ0b0VtaXRfMSIsInRvRW1pdF8xXzEiLCJidWZmZXJzXzIiLCJidWZmZXJzXzJfMSIsImNvbXBsZXRlIiwidW5kZWZpbmVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/bufferCount.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/concatMap.js":
/*!*********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/concatMap.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   concatMap: function() { return /* binding */ concatMap; }\n/* harmony export */ });\n/* harmony import */ var _mergeMap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mergeMap */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js\");\n/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/isFunction */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/util/isFunction.js\");\n\n\nfunction concatMap(project, resultSelector) {\n    return (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(resultSelector) ? (0,_mergeMap__WEBPACK_IMPORTED_MODULE_1__.mergeMap)(project, resultSelector, 1) : (0,_mergeMap__WEBPACK_IMPORTED_MODULE_1__.mergeMap)(project, 1);\n} //# sourceMappingURL=concatMap.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vcGVyYXRvcnMvY29uY2F0TWFwLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFzQztBQUVVO0FBNEUxQyxTQUFVRSxVQUNkQyxPQUF1QyxFQUN2Q0MsY0FBNkc7SUFFN0csT0FBT0gsNERBQUFBLENBQVdHLGtCQUFrQkosbURBQUFBLENBQVNHLFNBQVNDLGdCQUFnQixLQUFLSixtREFBQUEsQ0FBU0csU0FBUztBQUMvRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vc3JjL2ludGVybmFsL29wZXJhdG9ycy9jb25jYXRNYXAudHM/NDkwMyJdLCJuYW1lcyI6WyJtZXJnZU1hcCIsImlzRnVuY3Rpb24iLCJjb25jYXRNYXAiLCJwcm9qZWN0IiwicmVzdWx0U2VsZWN0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/concatMap.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js":
/*!**************************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mergeInternals: function() { return /* binding */ mergeInternals; }\n/* harmony export */ });\n/* harmony import */ var _observable_innerFrom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../observable/innerFrom */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js\");\n/* harmony import */ var _util_executeSchedule__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/executeSchedule */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js\");\n/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./OperatorSubscriber */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js\");\n\n\n\nfunction mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {\n    var buffer = [];\n    var active = 0;\n    var index = 0;\n    var isComplete = false;\n    var checkComplete = function() {\n        if (isComplete && !buffer.length && !active) {\n            subscriber.complete();\n        }\n    };\n    var outerNext = function(value) {\n        return active < concurrent ? doInnerSub(value) : buffer.push(value);\n    };\n    var doInnerSub = function(value) {\n        expand && subscriber.next(value);\n        active++;\n        var innerComplete = false;\n        (0,_observable_innerFrom__WEBPACK_IMPORTED_MODULE_0__.innerFrom)(project(value, index++)).subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__.createOperatorSubscriber)(subscriber, function(innerValue) {\n            onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);\n            if (expand) {\n                outerNext(innerValue);\n            } else {\n                subscriber.next(innerValue);\n            }\n        }, function() {\n            innerComplete = true;\n        }, undefined, function() {\n            if (innerComplete) {\n                try {\n                    active--;\n                    var _loop_1 = function() {\n                        var bufferedValue = buffer.shift();\n                        if (innerSubScheduler) {\n                            (0,_util_executeSchedule__WEBPACK_IMPORTED_MODULE_2__.executeSchedule)(subscriber, innerSubScheduler, function() {\n                                return doInnerSub(bufferedValue);\n                            });\n                        } else {\n                            doInnerSub(bufferedValue);\n                        }\n                    };\n                    while(buffer.length && active < concurrent){\n                        _loop_1();\n                    }\n                    checkComplete();\n                } catch (err) {\n                    subscriber.error(err);\n                }\n            }\n        }));\n    };\n    source.subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__.createOperatorSubscriber)(subscriber, outerNext, function() {\n        isComplete = true;\n        checkComplete();\n    }));\n    return function() {\n        additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();\n    };\n} //# sourceMappingURL=mergeInternals.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vcGVyYXRvcnMvbWVyZ2VJbnRlcm5hbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUNvRDtBQUdNO0FBQ007QUFlMUQsU0FBVUcsZUFDZEMsTUFBcUIsRUFDckJDLFVBQXlCLEVBQ3pCQyxPQUF3RCxFQUN4REMsVUFBa0IsRUFDbEJDLFlBQXNDLEVBQ3RDQyxNQUFnQixFQUNoQkMsaUJBQWlDLEVBQ2pDQyxtQkFBZ0M7SUFHaEMsSUFBTUMsU0FBYyxFQUFFO0lBRXRCLElBQUlDLFNBQVM7SUFFYixJQUFJQyxRQUFRO0lBRVosSUFBSUMsYUFBYTtJQUtqQixJQUFNQyxnQkFBZ0I7UUFJcEIsSUFBSUQsY0FBYyxDQUFDSCxPQUFPSyxNQUFNLElBQUksQ0FBQ0osUUFBUTtZQUMzQ1IsV0FBV2EsUUFBUTs7SUFFdkI7SUFHQSxJQUFNQyxZQUFZLFNBQUNDLEtBQVE7UUFBSyxPQUFDUCxTQUFTTixhQUFhYyxXQUFXRCxTQUFTUixPQUFPVSxJQUFJLENBQUNGO0lBQXZEO0lBRWhDLElBQU1DLGFBQWEsU0FBQ0QsS0FBUTtRQUkxQlgsVUFBVUosV0FBV2tCLElBQUksQ0FBQ0g7UUFJMUJQO1FBS0EsSUFBSVcsZ0JBQWdCO1FBR3BCeEIsZ0VBQUFBLENBQVVNLFFBQVFjLE9BQU9OLFVBQVVXLFNBQVMsQ0FDMUN2Qiw2RUFBQUEsQ0FDRUcsWUFDQSxTQUFDcUIsVUFBVTtZQUdUbEIsaUJBQVksUUFBWkEsaUJBQVksa0JBQVpBLGFBQWVrQjtZQUVmLElBQUlqQixRQUFRO2dCQUdWVSxVQUFVTzttQkFDTDtnQkFFTHJCLFdBQVdrQixJQUFJLENBQUNHOztRQUVwQixHQUNBO1lBR0VGLGdCQUFnQjtRQUNsQixHQUVBRyxXQUNBO1lBSUUsSUFBSUgsZUFBZTtnQkFLakIsSUFBSTtvQkFJRlg7O3dCQU1FLElBQU1lLGdCQUFnQmhCLE9BQU9pQixLQUFLO3dCQUlsQyxJQUFJbkIsbUJBQW1COzRCQUNyQlQsc0VBQUFBLENBQWdCSSxZQUFZSyxtQkFBbUI7Z0NBQU0sT0FBQVcsV0FBV087NEJBQVg7K0JBQ2hEOzRCQUNMUCxXQUFXTzs7O29CQVJmLE1BQU9oQixPQUFPSyxNQUFNLElBQUlKLFNBQVNOLFdBQVU7OztvQkFZM0NTO2tCQUNBLE9BQU9jLEtBQUs7b0JBQ1p6QixXQUFXMEIsS0FBSyxDQUFDRDs7O1FBR3ZCO0lBR047SUFHQTFCLE9BQU9xQixTQUFTLENBQ2R2Qiw2RUFBQUEsQ0FBeUJHLFlBQVljLFdBQVc7UUFFOUNKLGFBQWE7UUFDYkM7SUFDRjtJQUtGLE9BQU87UUFDTEwsd0JBQW1CLFFBQW5CQSx3QkFBbUIsa0JBQW5CQTtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvbWVyZ2VJbnRlcm5hbHMudHM/ZmU4YyJdLCJuYW1lcyI6WyJpbm5lckZyb20iLCJleGVjdXRlU2NoZWR1bGUiLCJjcmVhdGVPcGVyYXRvclN1YnNjcmliZXIiLCJtZXJnZUludGVybmFscyIsInNvdXJjZSIsInN1YnNjcmliZXIiLCJwcm9qZWN0IiwiY29uY3VycmVudCIsIm9uQmVmb3JlTmV4dCIsImV4cGFuZCIsImlubmVyU3ViU2NoZWR1bGVyIiwiYWRkaXRpb25hbEZpbmFsaXplciIsImJ1ZmZlciIsImFjdGl2ZSIsImluZGV4IiwiaXNDb21wbGV0ZSIsImNoZWNrQ29tcGxldGUiLCJsZW5ndGgiLCJjb21wbGV0ZSIsIm91dGVyTmV4dCIsInZhbHVlIiwiZG9Jbm5lclN1YiIsInB1c2giLCJuZXh0IiwiaW5uZXJDb21wbGV0ZSIsInN1YnNjcmliZSIsImlubmVyVmFsdWUiLCJ1bmRlZmluZWQiLCJidWZmZXJlZFZhbHVlIiwic2hpZnQiLCJlcnIiLCJlcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js":
/*!********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mergeMap: function() { return /* binding */ mergeMap; }\n/* harmony export */ });\n/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./map */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/map.js\");\n/* harmony import */ var _observable_innerFrom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../observable/innerFrom */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js\");\n/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/lift */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/util/lift.js\");\n/* harmony import */ var _mergeInternals__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mergeInternals */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js\");\n/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/isFunction */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/util/isFunction.js\");\n\n\n\n\n\nfunction mergeMap(project, resultSelector, concurrent) {\n    if (concurrent === void 0) {\n        concurrent = Infinity;\n    }\n    if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(resultSelector)) {\n        return mergeMap(function(a, i) {\n            return (0,_map__WEBPACK_IMPORTED_MODULE_1__.map)(function(b, ii) {\n                return resultSelector(a, b, i, ii);\n            })((0,_observable_innerFrom__WEBPACK_IMPORTED_MODULE_2__.innerFrom)(project(a, i)));\n        }, concurrent);\n    } else if (typeof resultSelector === \"number\") {\n        concurrent = resultSelector;\n    }\n    return (0,_util_lift__WEBPACK_IMPORTED_MODULE_3__.operate)(function(source, subscriber) {\n        return (0,_mergeInternals__WEBPACK_IMPORTED_MODULE_4__.mergeInternals)(source, subscriber, project, concurrent);\n    });\n} //# sourceMappingURL=mergeMap.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vcGVyYXRvcnMvbWVyZ2VNYXAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQzRCO0FBQ3dCO0FBQ2I7QUFDVztBQUNGO0FBNkUxQyxTQUFVSyxTQUNkQyxPQUF1QyxFQUN2Q0MsY0FBd0gsRUFDeEhDLFVBQTZCO0lBQTdCLElBQUFBLGVBQUE7UUFBQUEsYUFBQUM7SUFBNkI7SUFFN0IsSUFBSUwsNERBQUFBLENBQVdHLGlCQUFpQjtRQUU5QixPQUFPRixTQUFTLFNBQUNLLENBQUMsRUFBRUMsQ0FBQztZQUFLLE9BQUFYLHlDQUFBQSxDQUFJLFNBQUNZLENBQU0sRUFBRUMsRUFBVTtnQkFBSyxPQUFBTixlQUFlRyxHQUFHRSxHQUFHRCxHQUFHRTtZQUF4QixHQUE2QlosZ0VBQUFBLENBQVVLLFFBQVFJLEdBQUdDO1FBQTlFLEdBQW9GSDtXQUN6RyxJQUFJLE9BQU9ELG1CQUFtQixVQUFVO1FBQzdDQyxhQUFhRDs7SUFHZixPQUFPTCxtREFBQUEsQ0FBUSxTQUFDWSxNQUFNLEVBQUVDLFVBQVU7UUFBSyxPQUFBWiwrREFBQUEsQ0FBZVcsUUFBUUMsWUFBWVQsU0FBU0U7SUFBNUM7QUFDekMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3NyYy9pbnRlcm5hbC9vcGVyYXRvcnMvbWVyZ2VNYXAudHM/NDUyNyJdLCJuYW1lcyI6WyJtYXAiLCJpbm5lckZyb20iLCJvcGVyYXRlIiwibWVyZ2VJbnRlcm5hbHMiLCJpc0Z1bmN0aW9uIiwibWVyZ2VNYXAiLCJwcm9qZWN0IiwicmVzdWx0U2VsZWN0b3IiLCJjb25jdXJyZW50IiwiSW5maW5pdHkiLCJhIiwiaSIsImIiLCJpaSIsInNvdXJjZSIsInN1YnNjcmliZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/take.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/take.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   take: function() { return /* binding */ take; }\n/* harmony export */ });\n/* harmony import */ var _observable_empty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../observable/empty */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/observable/empty.js\");\n/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/lift */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/util/lift.js\");\n/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./OperatorSubscriber */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js\");\n\n\n\nfunction take(count) {\n    return count <= 0 ? function() {\n        return _observable_empty__WEBPACK_IMPORTED_MODULE_0__.EMPTY;\n    } : (0,_util_lift__WEBPACK_IMPORTED_MODULE_1__.operate)(function(source, subscriber) {\n        var seen = 0;\n        source.subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_2__.createOperatorSubscriber)(subscriber, function(value) {\n            if (++seen <= count) {\n                subscriber.next(value);\n                if (count <= seen) {\n                    subscriber.complete();\n                }\n            }\n        }));\n    });\n} //# sourceMappingURL=take.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vcGVyYXRvcnMvdGFrZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQzRDO0FBQ0w7QUFDeUI7QUE0QzFELFNBQVVHLEtBQVFDLEtBQWE7SUFDbkMsT0FBT0EsU0FBUyxJQUVaO1FBQU0sT0FBQUosb0RBQUFBO0lBQUEsSUFDTkMsbURBQUFBLENBQVEsU0FBQ0ksTUFBTSxFQUFFQyxVQUFVO1FBQ3pCLElBQUlDLE9BQU87UUFDWEYsT0FBT0csU0FBUyxDQUNkTiw2RUFBQUEsQ0FBeUJJLFlBQVksU0FBQ0csS0FBSztZQUl6QyxJQUFJLEVBQUVGLFFBQVFILE9BQU87Z0JBQ25CRSxXQUFXSSxJQUFJLENBQUNEO2dCQUloQixJQUFJTCxTQUFTRyxNQUFNO29CQUNqQkQsV0FBV0ssUUFBUTs7O1FBR3pCO0lBRUo7QUFDTiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vc3JjL2ludGVybmFsL29wZXJhdG9ycy90YWtlLnRzP2VhNWQiXSwibmFtZXMiOlsiRU1QVFkiLCJvcGVyYXRlIiwiY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyIiwidGFrZSIsImNvdW50Iiwic291cmNlIiwic3Vic2NyaWJlciIsInNlZW4iLCJzdWJzY3JpYmUiLCJ2YWx1ZSIsIm5leHQiLCJjb21wbGV0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/take.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/takeUntil.js":
/*!*********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/takeUntil.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   takeUntil: function() { return /* binding */ takeUntil; }\n/* harmony export */ });\n/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/lift */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/util/lift.js\");\n/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./OperatorSubscriber */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js\");\n/* harmony import */ var _observable_innerFrom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../observable/innerFrom */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js\");\n/* harmony import */ var _util_noop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/noop */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/util/noop.js\");\n\n\n\n\nfunction takeUntil(notifier) {\n    return (0,_util_lift__WEBPACK_IMPORTED_MODULE_0__.operate)(function(source, subscriber) {\n        (0,_observable_innerFrom__WEBPACK_IMPORTED_MODULE_1__.innerFrom)(notifier).subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_2__.createOperatorSubscriber)(subscriber, function() {\n            return subscriber.complete();\n        }, _util_noop__WEBPACK_IMPORTED_MODULE_3__.noop));\n        !subscriber.closed && source.subscribe(subscriber);\n    });\n} //# sourceMappingURL=takeUntil.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vcGVyYXRvcnMvdGFrZVVudGlsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQ3VDO0FBQ3lCO0FBQ1o7QUFDaEI7QUF5QzlCLFNBQVVJLFVBQWFDLFFBQThCO0lBQ3pELE9BQU9MLG1EQUFBQSxDQUFRLFNBQUNNLE1BQU0sRUFBRUMsVUFBVTtRQUNoQ0wsZ0VBQUFBLENBQVVHLFVBQVVHLFNBQVMsQ0FBQ1AsNkVBQUFBLENBQXlCTSxZQUFZO1lBQU0sT0FBQUEsV0FBV0UsUUFBUTtRQUFuQixHQUF1Qk4sNENBQUFBO1FBQ2hHLENBQUNJLFdBQVdHLE1BQU0sSUFBSUosT0FBT0UsU0FBUyxDQUFDRDtJQUN6QztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9zcmMvaW50ZXJuYWwvb3BlcmF0b3JzL3Rha2VVbnRpbC50cz83NDA1Il0sIm5hbWVzIjpbIm9wZXJhdGUiLCJjcmVhdGVPcGVyYXRvclN1YnNjcmliZXIiLCJpbm5lckZyb20iLCJub29wIiwidGFrZVVudGlsIiwibm90aWZpZXIiLCJzb3VyY2UiLCJzdWJzY3JpYmVyIiwic3Vic2NyaWJlIiwiY29tcGxldGUiLCJjbG9zZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/takeUntil.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/uuid/dist/esm-browser/native.js":
/*!******************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/native.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\nvar randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  randomUUID\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvbmF0aXZlLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBLCtEQUFlO0FBQ2Y7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvbmF0aXZlLmpzP2NjYWYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHJhbmRvbVVVSUQgPSB0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiBjcnlwdG8ucmFuZG9tVVVJRCAmJiBjcnlwdG8ucmFuZG9tVVVJRC5iaW5kKGNyeXB0byk7XG5leHBvcnQgZGVmYXVsdCB7XG4gIHJhbmRvbVVVSURcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/uuid/dist/esm-browser/native.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/uuid/dist/esm-browser/regex.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/regex.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvcmVnZXguanMiLCJtYXBwaW5ncyI6IjtBQUFBLCtEQUFlLGNBQWMsRUFBRSxVQUFVLEVBQUUsZUFBZSxFQUFFLGdCQUFnQixFQUFFLFVBQVUsR0FBRyw4RUFBOEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9yZWdleC5qcz8zMThkIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IC9eKD86WzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzEtOF1bMC05YS1mXXszfS1bODlhYl1bMC05YS1mXXszfS1bMC05YS1mXXsxMn18MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwfGZmZmZmZmZmLWZmZmYtZmZmZi1mZmZmLWZmZmZmZmZmZmZmZikkL2k7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/uuid/dist/esm-browser/regex.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/uuid/dist/esm-browser/rng.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/rng.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ rng; }\n/* harmony export */ });\n// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\n\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nfunction rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n  return getRandomValues(rnds8);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvcm5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9ybmcuanM/Y2NjOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiBJbiB0aGUgYnJvd3NlciB3ZSB0aGVyZWZvcmVcbi8vIHJlcXVpcmUgdGhlIGNyeXB0byBBUEkgYW5kIGRvIG5vdCBzdXBwb3J0IGJ1aWx0LWluIGZhbGxiYWNrIHRvIGxvd2VyIHF1YWxpdHkgcmFuZG9tIG51bWJlclxuLy8gZ2VuZXJhdG9ycyAobGlrZSBNYXRoLnJhbmRvbSgpKS5cblxudmFyIGdldFJhbmRvbVZhbHVlcztcbnZhciBybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJuZygpIHtcbiAgLy8gbGF6eSBsb2FkIHNvIHRoYXQgZW52aXJvbm1lbnRzIHRoYXQgbmVlZCB0byBwb2x5ZmlsbCBoYXZlIGEgY2hhbmNlIHRvIGRvIHNvXG4gIGlmICghZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgLy8gZ2V0UmFuZG9tVmFsdWVzIG5lZWRzIHRvIGJlIGludm9rZWQgaW4gYSBjb250ZXh0IHdoZXJlIFwidGhpc1wiIGlzIGEgQ3J5cHRvIGltcGxlbWVudGF0aW9uLlxuICAgIGdldFJhbmRvbVZhbHVlcyA9IHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKGNyeXB0byk7XG4gICAgaWYgKCFnZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcygpIG5vdCBzdXBwb3J0ZWQuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQjZ2V0cmFuZG9tdmFsdWVzLW5vdC1zdXBwb3J0ZWQnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGdldFJhbmRvbVZhbHVlcyhybmRzOCk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/uuid/dist/esm-browser/rng.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/uuid/dist/esm-browser/stringify.js":
/*!*********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/stringify.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   unsafeStringify: function() { return /* binding */ unsafeStringify; }\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/validate.js\");\n\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nfunction unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  //\n  // Note to future-self: No, you can't remove the `toLowerCase()` call.\n  // REF: https://github.com/uuidjs/uuid/pull/677#issuecomment-1757351351\n  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n  var uuid = unsafeStringify(arr, offset);\n  // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n  return uuid;\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (stringify);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvc3RyaW5naWZ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sd0RBQVE7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUFlLFNBQVMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9zdHJpbmdpZnkuanM/NjEzNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdmFsaWRhdGUgZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG5cbi8qKlxuICogQ29udmVydCBhcnJheSBvZiAxNiBieXRlIHZhbHVlcyB0byBVVUlEIHN0cmluZyBmb3JtYXQgb2YgdGhlIGZvcm06XG4gKiBYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcbiAqL1xudmFyIGJ5dGVUb0hleCA9IFtdO1xuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICBieXRlVG9IZXgucHVzaCgoaSArIDB4MTAwKS50b1N0cmluZygxNikuc2xpY2UoMSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVuc2FmZVN0cmluZ2lmeShhcnIsIG9mZnNldCA9IDApIHtcbiAgLy8gTm90ZTogQmUgY2FyZWZ1bCBlZGl0aW5nIHRoaXMgY29kZSEgIEl0J3MgYmVlbiB0dW5lZCBmb3IgcGVyZm9ybWFuY2VcbiAgLy8gYW5kIHdvcmtzIGluIHdheXMgeW91IG1heSBub3QgZXhwZWN0LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkL3B1bGwvNDM0XG4gIC8vXG4gIC8vIE5vdGUgdG8gZnV0dXJlLXNlbGY6IE5vLCB5b3UgY2FuJ3QgcmVtb3ZlIHRoZSBgdG9Mb3dlckNhc2UoKWAgY2FsbC5cbiAgLy8gUkVGOiBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQvcHVsbC82NzcjaXNzdWVjb21tZW50LTE3NTczNTEzNTFcbiAgcmV0dXJuIChieXRlVG9IZXhbYXJyW29mZnNldCArIDBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDNdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA1XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDZdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgN11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA4XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDldXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTNdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTVdXSkudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeShhcnIsIG9mZnNldCA9IDApIHtcbiAgdmFyIHV1aWQgPSB1bnNhZmVTdHJpbmdpZnkoYXJyLCBvZmZzZXQpO1xuICAvLyBDb25zaXN0ZW5jeSBjaGVjayBmb3IgdmFsaWQgVVVJRC4gIElmIHRoaXMgdGhyb3dzLCBpdCdzIGxpa2VseSBkdWUgdG8gb25lXG4gIC8vIG9mIHRoZSBmb2xsb3dpbmc6XG4gIC8vIC0gT25lIG9yIG1vcmUgaW5wdXQgYXJyYXkgdmFsdWVzIGRvbid0IG1hcCB0byBhIGhleCBvY3RldCAobGVhZGluZyB0b1xuICAvLyBcInVuZGVmaW5lZFwiIGluIHRoZSB1dWlkKVxuICAvLyAtIEludmFsaWQgaW5wdXQgdmFsdWVzIGZvciB0aGUgUkZDIGB2ZXJzaW9uYCBvciBgdmFyaWFudGAgZmllbGRzXG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZ2lmaWVkIFVVSUQgaXMgaW52YWxpZCcpO1xuICB9XG4gIHJldHVybiB1dWlkO1xufVxuZXhwb3J0IGRlZmF1bHQgc3RyaW5naWZ5OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/uuid/dist/esm-browser/stringify.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/uuid/dist/esm-browser/v4.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v4.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./native.js */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/native.js\");\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rng.js */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/stringify.js\");\n\n\n\nfunction v4(options, buf, offset) {\n  if (_native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID && !buf && !options) {\n    return _native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID();\n  }\n  options = options || {};\n  var rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    offset = offset || 0;\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n    return buf;\n  }\n  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(rnds);\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (v4);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFpQztBQUNOO0FBQ3NCO0FBQ2pEO0FBQ0EsTUFBTSxrREFBTTtBQUNaLFdBQVcsa0RBQU07QUFDakI7QUFDQTtBQUNBLCtDQUErQywrQ0FBRzs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4REFBZTtBQUN4QjtBQUNBLCtEQUFlLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci92NC5qcz8yMDA3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBuYXRpdmUgZnJvbSAnLi9uYXRpdmUuanMnO1xuaW1wb3J0IHJuZyBmcm9tICcuL3JuZy5qcyc7XG5pbXBvcnQgeyB1bnNhZmVTdHJpbmdpZnkgfSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICBpZiAobmF0aXZlLnJhbmRvbVVVSUQgJiYgIWJ1ZiAmJiAhb3B0aW9ucykge1xuICAgIHJldHVybiBuYXRpdmUucmFuZG9tVVVJRCgpO1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7XG5cbiAgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuICBybmRzWzZdID0gcm5kc1s2XSAmIDB4MGYgfCAweDQwO1xuICBybmRzWzhdID0gcm5kc1s4XSAmIDB4M2YgfCAweDgwO1xuXG4gIC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuICBpZiAoYnVmKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICBidWZbb2Zmc2V0ICsgaV0gPSBybmRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYnVmO1xuICB9XG4gIHJldHVybiB1bnNhZmVTdHJpbmdpZnkocm5kcyk7XG59XG5leHBvcnQgZGVmYXVsdCB2NDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/uuid/dist/esm-browser/v4.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/uuid/dist/esm-browser/validate.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/validate.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/regex.js\");\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].test(uuid);\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (validate);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdmFsaWRhdGUuanMiLCJtYXBwaW5ncyI6Ijs7QUFBK0I7QUFDL0I7QUFDQSxxQ0FBcUMsaURBQUs7QUFDMUM7QUFDQSwrREFBZSxRQUFRIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdmFsaWRhdGUuanM/MmY3NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUkVHRVggZnJvbSAnLi9yZWdleC5qcyc7XG5mdW5jdGlvbiB2YWxpZGF0ZSh1dWlkKSB7XG4gIHJldHVybiB0eXBlb2YgdXVpZCA9PT0gJ3N0cmluZycgJiYgUkVHRVgudGVzdCh1dWlkKTtcbn1cbmV4cG9ydCBkZWZhdWx0IHZhbGlkYXRlOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/uuid/dist/esm-browser/validate.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/xstate/actors/dist/xstate-actors.development.esm.js":
/*!**************************************************************************!*\
  !*** ./node_modules/xstate/actors/dist/xstate-actors.development.esm.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createEmptyActor: function() { return /* binding */ createEmptyActor; },\n/* harmony export */   fromCallback: function() { return /* binding */ fromCallback; },\n/* harmony export */   fromEventObservable: function() { return /* binding */ fromEventObservable; },\n/* harmony export */   fromObservable: function() { return /* binding */ fromObservable; },\n/* harmony export */   fromPromise: function() { return /* binding */ fromPromise; },\n/* harmony export */   fromTransition: function() { return /* binding */ fromTransition; }\n/* harmony export */ });\n/* harmony import */ var _dist_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dist/raise-5ea71f04.development.esm.js */ \"(app-pages-browser)/./node_modules/xstate/dist/raise-5ea71f04.development.esm.js\");\n/* harmony import */ var _dev_dist_xstate_dev_development_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../dev/dist/xstate-dev.development.esm.js */ \"(app-pages-browser)/./node_modules/xstate/dev/dist/xstate-dev.development.esm.js\");\n\n\n\n/**\n * Represents an actor created by `fromTransition`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import {\n *   fromTransition,\n *   createActor,\n *   type AnyActorSystem\n * } from 'xstate';\n *\n * //* The actor's stored context.\n * type Context = {\n *   // The current count.\n *   count: number;\n *   // The amount to increase `count` by.\n *   step: number;\n * };\n * // The events the actor receives.\n * type Event = { type: 'increment' };\n * // The actor's input.\n * type Input = { step?: number };\n *\n * // Actor logic that increments `count` by `step` when it receives an event of\n * // type `increment`.\n * const logic = fromTransition<Context, Event, AnyActorSystem, Input>(\n *   (state, event, actorScope) => {\n *     actorScope.self;\n *     //         ^? TransitionActorRef<Context, Event>\n *\n *     if (event.type === 'increment') {\n *       return {\n *         ...state,\n *         count: state.count + state.step\n *       };\n *     }\n *     return state;\n *   },\n *   ({ input, self }) => {\n *     self;\n *     // ^? TransitionActorRef<Context, Event>\n *\n *     return {\n *       count: 0,\n *       step: input.step ?? 1\n *     };\n *   }\n * );\n *\n * const actor = createActor(logic, { input: { step: 10 } });\n * //    ^? TransitionActorRef<Context, Event>\n * ```\n *\n * @see {@link fromTransition}\n */\n\n/**\n * Returns actor logic given a transition function and its initial state.\n *\n * A transition function is a function that takes the current `state` and\n * received `event` object as arguments, and returns the next state, similar to\n * a reducer.\n *\n * Actors created from transition logic (transition actors) can:\n *\n * - Receive events\n * - Emit snapshots of its state\n *\n * The transition functions `state` is used as its transition actors\n * `context`.\n *\n * Note that the \"state\" for a transition function is provided by the initial\n * state argument, and is not the same as the State object of an actor or a\n * state within a machine configuration.\n *\n * @example\n *\n * ```ts\n * const transitionLogic = fromTransition(\n *   (state, event) => {\n *     if (event.type === 'increment') {\n *       return {\n *         ...state,\n *         count: state.count + 1\n *       };\n *     }\n *     return state;\n *   },\n *   { count: 0 }\n * );\n *\n * const transitionActor = createActor(transitionLogic);\n * transitionActor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n * transitionActor.start();\n * // => {\n * //   status: 'active',\n * //   context: { count: 0 },\n * //   ...\n * // }\n *\n * transitionActor.send({ type: 'increment' });\n * // => {\n * //   status: 'active',\n * //   context: { count: 1 },\n * //   ...\n * // }\n * ```\n *\n * @param transition The transition function used to describe the transition\n *   logic. It should return the next state given the current state and event.\n *   It receives the following arguments:\n *\n *   - `state` - the current state.\n *   - `event` - the received event.\n *   - `actorScope` - the actor scope object, with properties like `self` and\n *       `system`.\n *\n * @param initialContext The initial state of the transition function, either an\n *   object representing the state, or a function which returns a state object.\n *   If a function, it will receive as its only argument an object with the\n *   following properties:\n *\n *   - `input` - the `input` provided to its parent transition actor.\n *   - `self` - a reference to its parent transition actor.\n *\n * @returns Actor logic\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n */\nfunction fromTransition(transition, initialContext) {\n  return {\n    config: transition,\n    transition: (snapshot, event, actorScope) => {\n      return {\n        ...snapshot,\n        context: transition(snapshot.context, event, actorScope)\n      };\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context: typeof initialContext === 'function' ? initialContext({\n          input\n        }) : initialContext\n      };\n    },\n    getPersistedSnapshot: snapshot => snapshot,\n    restoreSnapshot: snapshot => snapshot\n  };\n}\n\nconst instanceStates = /* #__PURE__ */new WeakMap();\n\n/**\n * Represents an actor created by `fromCallback`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import { fromCallback, createActor } from 'xstate';\n *\n * // The events the actor receives.\n * type Event = { type: 'someEvent' };\n * // The actor's input.\n * type Input = { name: string };\n *\n * // Actor logic that logs whenever it receives an event of type `someEvent`.\n * const logic = fromCallback<Event, Input>(({ self, input, receive }) => {\n *   self;\n *   // ^? CallbackActorRef<Event, Input>\n *\n *   receive((event) => {\n *     if (event.type === 'someEvent') {\n *       console.log(`${input.name}: received \"someEvent\" event`);\n *       // logs 'myActor: received \"someEvent\" event'\n *     }\n *   });\n * });\n *\n * const actor = createActor(logic, { input: { name: 'myActor' } });\n * //    ^? CallbackActorRef<Event, Input>\n * ```\n *\n * @see {@link fromCallback}\n */\n\n/**\n * An actor logic creator which returns callback logic as defined by a callback\n * function.\n *\n * @remarks\n * Useful for subscription-based or other free-form logic that can send events\n * back to the parent actor.\n *\n * Actors created from callback logic (callback actors) can:\n *\n * - Receive events via the `receive` function\n * - Send events to the parent actor via the `sendBack` function\n *\n * Callback actors are a bit different from other actors in that they:\n *\n * - Do not work with `onDone`\n * - Do not produce a snapshot using `.getSnapshot()`\n * - Do not emit values when used with `.subscribe()`\n * - Can not be stopped with `.stop()`\n *\n * @example\n *\n * ```typescript\n * const callbackLogic = fromCallback(({ sendBack, receive }) => {\n *   let lockStatus = 'unlocked';\n *\n *   const handler = (event) => {\n *     if (lockStatus === 'locked') {\n *       return;\n *     }\n *     sendBack(event);\n *   };\n *\n *   receive((event) => {\n *     if (event.type === 'lock') {\n *       lockStatus = 'locked';\n *     } else if (event.type === 'unlock') {\n *       lockStatus = 'unlocked';\n *     }\n *   });\n *\n *   document.body.addEventListener('click', handler);\n *\n *   return () => {\n *     document.body.removeEventListener('click', handler);\n *   };\n * });\n * ```\n *\n * @param callback - The callback function used to describe the callback logic\n *   The callback function is passed an object with the following properties:\n *\n *   - `receive` - A function that can send events back to the parent actor; the\n *       listener is then called whenever events are received by the callback\n *       actor\n *   - `sendBack` - A function that can send events back to the parent actor\n *   - `input` - Data that was provided to the callback actor\n *   - `self` - The parent actor of the callback actor\n *   - `system` - The actor system to which the callback actor belongs The callback\n *       function can (optionally) return a cleanup function, which is called\n *       when the actor is stopped.\n *\n * @returns Callback logic\n * @see {@link CallbackLogicFunction} for more information about the callback function and its object argument\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n */\nfunction fromCallback(callback) {\n  const logic = {\n    config: callback,\n    start: (state, actorScope) => {\n      const {\n        self,\n        system,\n        emit\n      } = actorScope;\n      const callbackState = {\n        receivers: undefined,\n        dispose: undefined\n      };\n      instanceStates.set(self, callbackState);\n      callbackState.dispose = callback({\n        input: state.input,\n        system,\n        self,\n        sendBack: event => {\n          if (self.getSnapshot().status === 'stopped') {\n            return;\n          }\n          if (self._parent) {\n            system._relay(self, self._parent, event);\n          }\n        },\n        receive: listener => {\n          callbackState.receivers ??= new Set();\n          callbackState.receivers.add(listener);\n        },\n        emit\n      });\n    },\n    transition: (state, event, actorScope) => {\n      const callbackState = instanceStates.get(actorScope.self);\n      if (event.type === _dist_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.X) {\n        state = {\n          ...state,\n          status: 'stopped',\n          error: undefined\n        };\n        callbackState.dispose?.();\n        return state;\n      }\n      callbackState.receivers?.forEach(receiver => receiver(event));\n      return state;\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        input\n      };\n    },\n    getPersistedSnapshot: snapshot => snapshot,\n    restoreSnapshot: snapshot => snapshot\n  };\n  return logic;\n}\n\nconst XSTATE_OBSERVABLE_NEXT = 'xstate.observable.next';\nconst XSTATE_OBSERVABLE_ERROR = 'xstate.observable.error';\nconst XSTATE_OBSERVABLE_COMPLETE = 'xstate.observable.complete';\n\n/**\n * Represents an actor created by `fromObservable` or `fromEventObservable`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import { fromObservable, createActor } from 'xstate';\n * import { interval } from 'rxjs';\n *\n * // The type of the value observed by the actor's logic.\n * type Context = number;\n * // The actor's input.\n * type Input = { period?: number };\n *\n * // Actor logic that observes a number incremented every `input.period`\n * // milliseconds (default: 1_000).\n * const logic = fromObservable<Context, Input>(({ input, self }) => {\n *   self;\n *   // ^? ObservableActorRef<Event, Input>\n *\n *   return interval(input.period ?? 1_000);\n * });\n *\n * const actor = createActor(logic, { input: { period: 2_000 } });\n * //    ^? ObservableActorRef<Event, Input>\n * ```\n *\n * @see {@link fromObservable}\n * @see {@link fromEventObservable}\n */\n\n/**\n * Observable actor logic is described by an observable stream of values. Actors\n * created from observable logic (observable actors) can:\n *\n * - Emit snapshots of the observables emitted value\n *\n * The observables emitted value is used as its observable actors `context`.\n *\n * Sending events to observable actors will have no effect.\n *\n * @example\n *\n * ```ts\n * import { fromObservable, createActor } from 'xstate';\n * import { interval } from 'rxjs';\n *\n * const logic = fromObservable((obj) => interval(1000));\n *\n * const actor = createActor(logic);\n *\n * actor.subscribe((snapshot) => {\n *   console.log(snapshot.context);\n * });\n *\n * actor.start();\n * // At every second:\n * // Logs 0\n * // Logs 1\n * // Logs 2\n * // ...\n * ```\n *\n * @param observableCreator A function that creates an observable. It receives\n *   one argument, an object with the following properties:\n *\n *   - `input` - Data that was provided to the observable actor\n *   - `self` - The parent actor\n *   - `system` - The actor system to which the observable actor belongs\n *\n *   It should return a {@link Subscribable}, which is compatible with an RxJS\n *   Observable, although RxJS is not required to create them.\n * @see {@link https://rxjs.dev} for documentation on RxJS Observable and observable creators.\n * @see {@link Subscribable} interface in XState, which is based on and compatible with RxJS Observable.\n */\nfunction fromObservable(observableCreator) {\n  // TODO: add event types\n  const logic = {\n    config: observableCreator,\n    transition: (snapshot, event) => {\n      if (snapshot.status !== 'active') {\n        return snapshot;\n      }\n      switch (event.type) {\n        case XSTATE_OBSERVABLE_NEXT:\n          {\n            const newSnapshot = {\n              ...snapshot,\n              context: event.data\n            };\n            return newSnapshot;\n          }\n        case XSTATE_OBSERVABLE_ERROR:\n          return {\n            ...snapshot,\n            status: 'error',\n            error: event.data,\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_OBSERVABLE_COMPLETE:\n          return {\n            ...snapshot,\n            status: 'done',\n            input: undefined,\n            _subscription: undefined\n          };\n        case _dist_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.X:\n          snapshot._subscription.unsubscribe();\n          return {\n            ...snapshot,\n            status: 'stopped',\n            input: undefined,\n            _subscription: undefined\n          };\n        default:\n          return snapshot;\n      }\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context: undefined,\n        input,\n        _subscription: undefined\n      };\n    },\n    start: (state, {\n      self,\n      system,\n      emit\n    }) => {\n      if (state.status === 'done') {\n        // Do not restart a completed observable\n        return;\n      }\n      state._subscription = observableCreator({\n        input: state.input,\n        system,\n        self,\n        emit\n      }).subscribe({\n        next: value => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_NEXT,\n            data: value\n          });\n        },\n        error: err => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_ERROR,\n            data: err\n          });\n        },\n        complete: () => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_COMPLETE\n          });\n        }\n      });\n    },\n    getPersistedSnapshot: ({\n      _subscription,\n      ...state\n    }) => state,\n    restoreSnapshot: state => ({\n      ...state,\n      _subscription: undefined\n    })\n  };\n  return logic;\n}\n\n/**\n * Creates event observable logic that listens to an observable that delivers\n * event objects.\n *\n * Event observable actor logic is described by an observable stream of\n * {@link https://stately.ai/docs/transitions#event-objects | event objects}.\n * Actors created from event observable logic (event observable actors) can:\n *\n * - Implicitly send events to its parent actor\n * - Emit snapshots of its emitted event objects\n *\n * Sending events to event observable actors will have no effect.\n *\n * @example\n *\n * ```ts\n * import {\n *   fromEventObservable,\n *   Subscribable,\n *   EventObject,\n *   createMachine,\n *   createActor\n * } from 'xstate';\n * import { fromEvent } from 'rxjs';\n *\n * const mouseClickLogic = fromEventObservable(\n *   () => fromEvent(document.body, 'click') as Subscribable<EventObject>\n * );\n *\n * const canvasMachine = createMachine({\n *   invoke: {\n *     // Will send mouse `click` events to the canvas actor\n *     src: mouseClickLogic\n *   }\n * });\n *\n * const canvasActor = createActor(canvasMachine);\n * canvasActor.start();\n * ```\n *\n * @param lazyObservable A function that creates an observable that delivers\n *   event objects. It receives one argument, an object with the following\n *   properties:\n *\n *   - `input` - Data that was provided to the event observable actor\n *   - `self` - The parent actor\n *   - `system` - The actor system to which the event observable actor belongs.\n *\n *   It should return a {@link Subscribable}, which is compatible with an RxJS\n *   Observable, although RxJS is not required to create them.\n */\nfunction fromEventObservable(lazyObservable) {\n  // TODO: event types\n  const logic = {\n    config: lazyObservable,\n    transition: (state, event) => {\n      if (state.status !== 'active') {\n        return state;\n      }\n      switch (event.type) {\n        case XSTATE_OBSERVABLE_ERROR:\n          return {\n            ...state,\n            status: 'error',\n            error: event.data,\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_OBSERVABLE_COMPLETE:\n          return {\n            ...state,\n            status: 'done',\n            input: undefined,\n            _subscription: undefined\n          };\n        case _dist_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.X:\n          state._subscription.unsubscribe();\n          return {\n            ...state,\n            status: 'stopped',\n            input: undefined,\n            _subscription: undefined\n          };\n        default:\n          return state;\n      }\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context: undefined,\n        input,\n        _subscription: undefined\n      };\n    },\n    start: (state, {\n      self,\n      system,\n      emit\n    }) => {\n      if (state.status === 'done') {\n        // Do not restart a completed observable\n        return;\n      }\n      state._subscription = lazyObservable({\n        input: state.input,\n        system,\n        self,\n        emit\n      }).subscribe({\n        next: value => {\n          if (self._parent) {\n            system._relay(self, self._parent, value);\n          }\n        },\n        error: err => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_ERROR,\n            data: err\n          });\n        },\n        complete: () => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_COMPLETE\n          });\n        }\n      });\n    },\n    getPersistedSnapshot: ({\n      _subscription,\n      ...snapshot\n    }) => snapshot,\n    restoreSnapshot: snapshot => ({\n      ...snapshot,\n      _subscription: undefined\n    })\n  };\n  return logic;\n}\n\nconst XSTATE_PROMISE_RESOLVE = 'xstate.promise.resolve';\nconst XSTATE_PROMISE_REJECT = 'xstate.promise.reject';\n\n/**\n * Represents an actor created by `fromPromise`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import { fromPromise, createActor } from 'xstate';\n *\n * // The actor's resolved output\n * type Output = string;\n * // The actor's input.\n * type Input = { message: string };\n *\n * // Actor logic that fetches the url of an image of a cat saying `input.message`.\n * const logic = fromPromise<Output, Input>(async ({ input, self }) => {\n *   self;\n *   // ^? PromiseActorRef<Output, Input>\n *\n *   const data = await fetch(\n *     `https://cataas.com/cat/says/${input.message}`\n *   );\n *   const url = await data.json();\n *   return url;\n * });\n *\n * const actor = createActor(logic, { input: { message: 'hello world' } });\n * //    ^? PromiseActorRef<Output, Input>\n * ```\n *\n * @see {@link fromPromise}\n */\n\nconst controllerMap = new WeakMap();\n\n/**\n * An actor logic creator which returns promise logic as defined by an async\n * process that resolves or rejects after some time.\n *\n * Actors created from promise actor logic (promise actors) can:\n *\n * - Emit the resolved value of the promise\n * - Output the resolved value of the promise\n *\n * Sending events to promise actors will have no effect.\n *\n * @example\n *\n * ```ts\n * const promiseLogic = fromPromise(async () => {\n *   const result = await fetch('https://example.com/...').then((data) =>\n *     data.json()\n *   );\n *\n *   return result;\n * });\n *\n * const promiseActor = createActor(promiseLogic);\n * promiseActor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n * promiseActor.start();\n * // => {\n * //   output: undefined,\n * //   status: 'active'\n * //   ...\n * // }\n *\n * // After promise resolves\n * // => {\n * //   output: { ... },\n * //   status: 'done',\n * //   ...\n * // }\n * ```\n *\n * @param promiseCreator A function which returns a Promise, and accepts an\n *   object with the following properties:\n *\n *   - `input` - Data that was provided to the promise actor\n *   - `self` - The parent actor of the promise actor\n *   - `system` - The actor system to which the promise actor belongs\n *\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n */\nfunction fromPromise(promiseCreator) {\n  const logic = {\n    config: promiseCreator,\n    transition: (state, event, scope) => {\n      if (state.status !== 'active') {\n        return state;\n      }\n      switch (event.type) {\n        case XSTATE_PROMISE_RESOLVE:\n          {\n            const resolvedValue = event.data;\n            return {\n              ...state,\n              status: 'done',\n              output: resolvedValue,\n              input: undefined\n            };\n          }\n        case XSTATE_PROMISE_REJECT:\n          return {\n            ...state,\n            status: 'error',\n            error: event.data,\n            input: undefined\n          };\n        case _dist_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.X:\n          {\n            controllerMap.get(scope.self)?.abort();\n            return {\n              ...state,\n              status: 'stopped',\n              input: undefined\n            };\n          }\n        default:\n          return state;\n      }\n    },\n    start: (state, {\n      self,\n      system,\n      emit\n    }) => {\n      // TODO: determine how to allow customizing this so that promises\n      // can be restarted if necessary\n      if (state.status !== 'active') {\n        return;\n      }\n      const controller = new AbortController();\n      controllerMap.set(self, controller);\n      const resolvedPromise = Promise.resolve(promiseCreator({\n        input: state.input,\n        system,\n        self,\n        signal: controller.signal,\n        emit\n      }));\n      resolvedPromise.then(response => {\n        if (self.getSnapshot().status !== 'active') {\n          return;\n        }\n        controllerMap.delete(self);\n        system._relay(self, self, {\n          type: XSTATE_PROMISE_RESOLVE,\n          data: response\n        });\n      }, errorData => {\n        if (self.getSnapshot().status !== 'active') {\n          return;\n        }\n        controllerMap.delete(self);\n        system._relay(self, self, {\n          type: XSTATE_PROMISE_REJECT,\n          data: errorData\n        });\n      });\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        input\n      };\n    },\n    getPersistedSnapshot: snapshot => snapshot,\n    restoreSnapshot: snapshot => snapshot\n  };\n  return logic;\n}\n\nconst emptyLogic = fromTransition(_ => undefined, undefined);\nfunction createEmptyActor() {\n  return (0,_dist_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.A)(emptyLogic);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy94c3RhdGUvYWN0b3JzL2Rpc3QveHN0YXRlLWFjdG9ycy5kZXZlbG9wbWVudC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBa0c7QUFDNUM7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLFFBQVEsYUFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxTQUFTLFlBQVk7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtQkFBbUI7QUFDN0M7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsa0RBQWtEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHNFQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLDBFQUFXO0FBQ3BCOztBQUU0RyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMveHN0YXRlL2FjdG9ycy9kaXN0L3hzdGF0ZS1hY3RvcnMuZGV2ZWxvcG1lbnQuZXNtLmpzP2QxYTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgWCBhcyBYU1RBVEVfU1RPUCwgQSBhcyBjcmVhdGVBY3RvciB9IGZyb20gJy4uLy4uL2Rpc3QvcmFpc2UtNWVhNzFmMDQuZGV2ZWxvcG1lbnQuZXNtLmpzJztcbmltcG9ydCAnLi4vLi4vZGV2L2Rpc3QveHN0YXRlLWRldi5kZXZlbG9wbWVudC5lc20uanMnO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gYWN0b3IgY3JlYXRlZCBieSBgZnJvbVRyYW5zaXRpb25gLlxuICpcbiAqIFRoZSB0eXBlIG9mIGBzZWxmYCB3aXRoaW4gdGhlIGFjdG9yJ3MgbG9naWMuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHtcbiAqICAgZnJvbVRyYW5zaXRpb24sXG4gKiAgIGNyZWF0ZUFjdG9yLFxuICogICB0eXBlIEFueUFjdG9yU3lzdGVtXG4gKiB9IGZyb20gJ3hzdGF0ZSc7XG4gKlxuICogLy8qIFRoZSBhY3RvcidzIHN0b3JlZCBjb250ZXh0LlxuICogdHlwZSBDb250ZXh0ID0ge1xuICogICAvLyBUaGUgY3VycmVudCBjb3VudC5cbiAqICAgY291bnQ6IG51bWJlcjtcbiAqICAgLy8gVGhlIGFtb3VudCB0byBpbmNyZWFzZSBgY291bnRgIGJ5LlxuICogICBzdGVwOiBudW1iZXI7XG4gKiB9O1xuICogLy8gVGhlIGV2ZW50cyB0aGUgYWN0b3IgcmVjZWl2ZXMuXG4gKiB0eXBlIEV2ZW50ID0geyB0eXBlOiAnaW5jcmVtZW50JyB9O1xuICogLy8gVGhlIGFjdG9yJ3MgaW5wdXQuXG4gKiB0eXBlIElucHV0ID0geyBzdGVwPzogbnVtYmVyIH07XG4gKlxuICogLy8gQWN0b3IgbG9naWMgdGhhdCBpbmNyZW1lbnRzIGBjb3VudGAgYnkgYHN0ZXBgIHdoZW4gaXQgcmVjZWl2ZXMgYW4gZXZlbnQgb2ZcbiAqIC8vIHR5cGUgYGluY3JlbWVudGAuXG4gKiBjb25zdCBsb2dpYyA9IGZyb21UcmFuc2l0aW9uPENvbnRleHQsIEV2ZW50LCBBbnlBY3RvclN5c3RlbSwgSW5wdXQ+KFxuICogICAoc3RhdGUsIGV2ZW50LCBhY3RvclNjb3BlKSA9PiB7XG4gKiAgICAgYWN0b3JTY29wZS5zZWxmO1xuICogICAgIC8vICAgICAgICAgXj8gVHJhbnNpdGlvbkFjdG9yUmVmPENvbnRleHQsIEV2ZW50PlxuICpcbiAqICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2luY3JlbWVudCcpIHtcbiAqICAgICAgIHJldHVybiB7XG4gKiAgICAgICAgIC4uLnN0YXRlLFxuICogICAgICAgICBjb3VudDogc3RhdGUuY291bnQgKyBzdGF0ZS5zdGVwXG4gKiAgICAgICB9O1xuICogICAgIH1cbiAqICAgICByZXR1cm4gc3RhdGU7XG4gKiAgIH0sXG4gKiAgICh7IGlucHV0LCBzZWxmIH0pID0+IHtcbiAqICAgICBzZWxmO1xuICogICAgIC8vIF4/IFRyYW5zaXRpb25BY3RvclJlZjxDb250ZXh0LCBFdmVudD5cbiAqXG4gKiAgICAgcmV0dXJuIHtcbiAqICAgICAgIGNvdW50OiAwLFxuICogICAgICAgc3RlcDogaW5wdXQuc3RlcCA/PyAxXG4gKiAgICAgfTtcbiAqICAgfVxuICogKTtcbiAqXG4gKiBjb25zdCBhY3RvciA9IGNyZWF0ZUFjdG9yKGxvZ2ljLCB7IGlucHV0OiB7IHN0ZXA6IDEwIH0gfSk7XG4gKiAvLyAgICBePyBUcmFuc2l0aW9uQWN0b3JSZWY8Q29udGV4dCwgRXZlbnQ+XG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayBmcm9tVHJhbnNpdGlvbn1cbiAqL1xuXG4vKipcbiAqIFJldHVybnMgYWN0b3IgbG9naWMgZ2l2ZW4gYSB0cmFuc2l0aW9uIGZ1bmN0aW9uIGFuZCBpdHMgaW5pdGlhbCBzdGF0ZS5cbiAqXG4gKiBBIOKAnHRyYW5zaXRpb24gZnVuY3Rpb27igJ0gaXMgYSBmdW5jdGlvbiB0aGF0IHRha2VzIHRoZSBjdXJyZW50IGBzdGF0ZWAgYW5kXG4gKiByZWNlaXZlZCBgZXZlbnRgIG9iamVjdCBhcyBhcmd1bWVudHMsIGFuZCByZXR1cm5zIHRoZSBuZXh0IHN0YXRlLCBzaW1pbGFyIHRvXG4gKiBhIHJlZHVjZXIuXG4gKlxuICogQWN0b3JzIGNyZWF0ZWQgZnJvbSB0cmFuc2l0aW9uIGxvZ2ljICjigJx0cmFuc2l0aW9uIGFjdG9yc+KAnSkgY2FuOlxuICpcbiAqIC0gUmVjZWl2ZSBldmVudHNcbiAqIC0gRW1pdCBzbmFwc2hvdHMgb2YgaXRzIHN0YXRlXG4gKlxuICogVGhlIHRyYW5zaXRpb24gZnVuY3Rpb27igJlzIGBzdGF0ZWAgaXMgdXNlZCBhcyBpdHMgdHJhbnNpdGlvbiBhY3RvcuKAmXNcbiAqIGBjb250ZXh0YC5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIFwic3RhdGVcIiBmb3IgYSB0cmFuc2l0aW9uIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIGJ5IHRoZSBpbml0aWFsXG4gKiBzdGF0ZSBhcmd1bWVudCwgYW5kIGlzIG5vdCB0aGUgc2FtZSBhcyB0aGUgU3RhdGUgb2JqZWN0IG9mIGFuIGFjdG9yIG9yIGFcbiAqIHN0YXRlIHdpdGhpbiBhIG1hY2hpbmUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCB0cmFuc2l0aW9uTG9naWMgPSBmcm9tVHJhbnNpdGlvbihcbiAqICAgKHN0YXRlLCBldmVudCkgPT4ge1xuICogICAgIGlmIChldmVudC50eXBlID09PSAnaW5jcmVtZW50Jykge1xuICogICAgICAgcmV0dXJuIHtcbiAqICAgICAgICAgLi4uc3RhdGUsXG4gKiAgICAgICAgIGNvdW50OiBzdGF0ZS5jb3VudCArIDFcbiAqICAgICAgIH07XG4gKiAgICAgfVxuICogICAgIHJldHVybiBzdGF0ZTtcbiAqICAgfSxcbiAqICAgeyBjb3VudDogMCB9XG4gKiApO1xuICpcbiAqIGNvbnN0IHRyYW5zaXRpb25BY3RvciA9IGNyZWF0ZUFjdG9yKHRyYW5zaXRpb25Mb2dpYyk7XG4gKiB0cmFuc2l0aW9uQWN0b3Iuc3Vic2NyaWJlKChzbmFwc2hvdCkgPT4ge1xuICogICBjb25zb2xlLmxvZyhzbmFwc2hvdCk7XG4gKiB9KTtcbiAqIHRyYW5zaXRpb25BY3Rvci5zdGFydCgpO1xuICogLy8gPT4ge1xuICogLy8gICBzdGF0dXM6ICdhY3RpdmUnLFxuICogLy8gICBjb250ZXh0OiB7IGNvdW50OiAwIH0sXG4gKiAvLyAgIC4uLlxuICogLy8gfVxuICpcbiAqIHRyYW5zaXRpb25BY3Rvci5zZW5kKHsgdHlwZTogJ2luY3JlbWVudCcgfSk7XG4gKiAvLyA9PiB7XG4gKiAvLyAgIHN0YXR1czogJ2FjdGl2ZScsXG4gKiAvLyAgIGNvbnRleHQ6IHsgY291bnQ6IDEgfSxcbiAqIC8vICAgLi4uXG4gKiAvLyB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdHJhbnNpdGlvbiBUaGUgdHJhbnNpdGlvbiBmdW5jdGlvbiB1c2VkIHRvIGRlc2NyaWJlIHRoZSB0cmFuc2l0aW9uXG4gKiAgIGxvZ2ljLiBJdCBzaG91bGQgcmV0dXJuIHRoZSBuZXh0IHN0YXRlIGdpdmVuIHRoZSBjdXJyZW50IHN0YXRlIGFuZCBldmVudC5cbiAqICAgSXQgcmVjZWl2ZXMgdGhlIGZvbGxvd2luZyBhcmd1bWVudHM6XG4gKlxuICogICAtIGBzdGF0ZWAgLSB0aGUgY3VycmVudCBzdGF0ZS5cbiAqICAgLSBgZXZlbnRgIC0gdGhlIHJlY2VpdmVkIGV2ZW50LlxuICogICAtIGBhY3RvclNjb3BlYCAtIHRoZSBhY3RvciBzY29wZSBvYmplY3QsIHdpdGggcHJvcGVydGllcyBsaWtlIGBzZWxmYCBhbmRcbiAqICAgICAgIGBzeXN0ZW1gLlxuICpcbiAqIEBwYXJhbSBpbml0aWFsQ29udGV4dCBUaGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgdHJhbnNpdGlvbiBmdW5jdGlvbiwgZWl0aGVyIGFuXG4gKiAgIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHN0YXRlLCBvciBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYSBzdGF0ZSBvYmplY3QuXG4gKiAgIElmIGEgZnVuY3Rpb24sIGl0IHdpbGwgcmVjZWl2ZSBhcyBpdHMgb25seSBhcmd1bWVudCBhbiBvYmplY3Qgd2l0aCB0aGVcbiAqICAgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGBpbnB1dGAgLSB0aGUgYGlucHV0YCBwcm92aWRlZCB0byBpdHMgcGFyZW50IHRyYW5zaXRpb24gYWN0b3IuXG4gKiAgIC0gYHNlbGZgIC0gYSByZWZlcmVuY2UgdG8gaXRzIHBhcmVudCB0cmFuc2l0aW9uIGFjdG9yLlxuICpcbiAqIEByZXR1cm5zIEFjdG9yIGxvZ2ljXG4gKiBAc2VlIHtAbGluayBodHRwczovL3N0YXRlbHkuYWkvZG9jcy9pbnB1dCB8IElucHV0IGRvY3N9IGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IGhvdyBpbnB1dCBpcyBwYXNzZWRcbiAqL1xuZnVuY3Rpb24gZnJvbVRyYW5zaXRpb24odHJhbnNpdGlvbiwgaW5pdGlhbENvbnRleHQpIHtcbiAgcmV0dXJuIHtcbiAgICBjb25maWc6IHRyYW5zaXRpb24sXG4gICAgdHJhbnNpdGlvbjogKHNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc25hcHNob3QsXG4gICAgICAgIGNvbnRleHQ6IHRyYW5zaXRpb24oc25hcHNob3QuY29udGV4dCwgZXZlbnQsIGFjdG9yU2NvcGUpXG4gICAgICB9O1xuICAgIH0sXG4gICAgZ2V0SW5pdGlhbFNuYXBzaG90OiAoXywgaW5wdXQpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogJ2FjdGl2ZScsXG4gICAgICAgIG91dHB1dDogdW5kZWZpbmVkLFxuICAgICAgICBlcnJvcjogdW5kZWZpbmVkLFxuICAgICAgICBjb250ZXh0OiB0eXBlb2YgaW5pdGlhbENvbnRleHQgPT09ICdmdW5jdGlvbicgPyBpbml0aWFsQ29udGV4dCh7XG4gICAgICAgICAgaW5wdXRcbiAgICAgICAgfSkgOiBpbml0aWFsQ29udGV4dFxuICAgICAgfTtcbiAgICB9LFxuICAgIGdldFBlcnNpc3RlZFNuYXBzaG90OiBzbmFwc2hvdCA9PiBzbmFwc2hvdCxcbiAgICByZXN0b3JlU25hcHNob3Q6IHNuYXBzaG90ID0+IHNuYXBzaG90XG4gIH07XG59XG5cbmNvbnN0IGluc3RhbmNlU3RhdGVzID0gLyogI19fUFVSRV9fICovbmV3IFdlYWtNYXAoKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGFjdG9yIGNyZWF0ZWQgYnkgYGZyb21DYWxsYmFja2AuXG4gKlxuICogVGhlIHR5cGUgb2YgYHNlbGZgIHdpdGhpbiB0aGUgYWN0b3IncyBsb2dpYy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBmcm9tQ2FsbGJhY2ssIGNyZWF0ZUFjdG9yIH0gZnJvbSAneHN0YXRlJztcbiAqXG4gKiAvLyBUaGUgZXZlbnRzIHRoZSBhY3RvciByZWNlaXZlcy5cbiAqIHR5cGUgRXZlbnQgPSB7IHR5cGU6ICdzb21lRXZlbnQnIH07XG4gKiAvLyBUaGUgYWN0b3IncyBpbnB1dC5cbiAqIHR5cGUgSW5wdXQgPSB7IG5hbWU6IHN0cmluZyB9O1xuICpcbiAqIC8vIEFjdG9yIGxvZ2ljIHRoYXQgbG9ncyB3aGVuZXZlciBpdCByZWNlaXZlcyBhbiBldmVudCBvZiB0eXBlIGBzb21lRXZlbnRgLlxuICogY29uc3QgbG9naWMgPSBmcm9tQ2FsbGJhY2s8RXZlbnQsIElucHV0PigoeyBzZWxmLCBpbnB1dCwgcmVjZWl2ZSB9KSA9PiB7XG4gKiAgIHNlbGY7XG4gKiAgIC8vIF4/IENhbGxiYWNrQWN0b3JSZWY8RXZlbnQsIElucHV0PlxuICpcbiAqICAgcmVjZWl2ZSgoZXZlbnQpID0+IHtcbiAqICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ3NvbWVFdmVudCcpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKGAke2lucHV0Lm5hbWV9OiByZWNlaXZlZCBcInNvbWVFdmVudFwiIGV2ZW50YCk7XG4gKiAgICAgICAvLyBsb2dzICdteUFjdG9yOiByZWNlaXZlZCBcInNvbWVFdmVudFwiIGV2ZW50J1xuICogICAgIH1cbiAqICAgfSk7XG4gKiB9KTtcbiAqXG4gKiBjb25zdCBhY3RvciA9IGNyZWF0ZUFjdG9yKGxvZ2ljLCB7IGlucHV0OiB7IG5hbWU6ICdteUFjdG9yJyB9IH0pO1xuICogLy8gICAgXj8gQ2FsbGJhY2tBY3RvclJlZjxFdmVudCwgSW5wdXQ+XG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayBmcm9tQ2FsbGJhY2t9XG4gKi9cblxuLyoqXG4gKiBBbiBhY3RvciBsb2dpYyBjcmVhdG9yIHdoaWNoIHJldHVybnMgY2FsbGJhY2sgbG9naWMgYXMgZGVmaW5lZCBieSBhIGNhbGxiYWNrXG4gKiBmdW5jdGlvbi5cbiAqXG4gKiBAcmVtYXJrc1xuICogVXNlZnVsIGZvciBzdWJzY3JpcHRpb24tYmFzZWQgb3Igb3RoZXIgZnJlZS1mb3JtIGxvZ2ljIHRoYXQgY2FuIHNlbmQgZXZlbnRzXG4gKiBiYWNrIHRvIHRoZSBwYXJlbnQgYWN0b3IuXG4gKlxuICogQWN0b3JzIGNyZWF0ZWQgZnJvbSBjYWxsYmFjayBsb2dpYyAo4oCcY2FsbGJhY2sgYWN0b3Jz4oCdKSBjYW46XG4gKlxuICogLSBSZWNlaXZlIGV2ZW50cyB2aWEgdGhlIGByZWNlaXZlYCBmdW5jdGlvblxuICogLSBTZW5kIGV2ZW50cyB0byB0aGUgcGFyZW50IGFjdG9yIHZpYSB0aGUgYHNlbmRCYWNrYCBmdW5jdGlvblxuICpcbiAqIENhbGxiYWNrIGFjdG9ycyBhcmUgYSBiaXQgZGlmZmVyZW50IGZyb20gb3RoZXIgYWN0b3JzIGluIHRoYXQgdGhleTpcbiAqXG4gKiAtIERvIG5vdCB3b3JrIHdpdGggYG9uRG9uZWBcbiAqIC0gRG8gbm90IHByb2R1Y2UgYSBzbmFwc2hvdCB1c2luZyBgLmdldFNuYXBzaG90KClgXG4gKiAtIERvIG5vdCBlbWl0IHZhbHVlcyB3aGVuIHVzZWQgd2l0aCBgLnN1YnNjcmliZSgpYFxuICogLSBDYW4gbm90IGJlIHN0b3BwZWQgd2l0aCBgLnN0b3AoKWBcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IGNhbGxiYWNrTG9naWMgPSBmcm9tQ2FsbGJhY2soKHsgc2VuZEJhY2ssIHJlY2VpdmUgfSkgPT4ge1xuICogICBsZXQgbG9ja1N0YXR1cyA9ICd1bmxvY2tlZCc7XG4gKlxuICogICBjb25zdCBoYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gKiAgICAgaWYgKGxvY2tTdGF0dXMgPT09ICdsb2NrZWQnKSB7XG4gKiAgICAgICByZXR1cm47XG4gKiAgICAgfVxuICogICAgIHNlbmRCYWNrKGV2ZW50KTtcbiAqICAgfTtcbiAqXG4gKiAgIHJlY2VpdmUoKGV2ZW50KSA9PiB7XG4gKiAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdsb2NrJykge1xuICogICAgICAgbG9ja1N0YXR1cyA9ICdsb2NrZWQnO1xuICogICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ3VubG9jaycpIHtcbiAqICAgICAgIGxvY2tTdGF0dXMgPSAndW5sb2NrZWQnO1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlcik7XG4gKlxuICogICByZXR1cm4gKCkgPT4ge1xuICogICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVyKTtcbiAqICAgfTtcbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHBhcmFtIGNhbGxiYWNrIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHVzZWQgdG8gZGVzY3JpYmUgdGhlIGNhbGxiYWNrIGxvZ2ljXG4gKiAgIFRoZSBjYWxsYmFjayBmdW5jdGlvbiBpcyBwYXNzZWQgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBgcmVjZWl2ZWAgLSBBIGZ1bmN0aW9uIHRoYXQgY2FuIHNlbmQgZXZlbnRzIGJhY2sgdG8gdGhlIHBhcmVudCBhY3RvcjsgdGhlXG4gKiAgICAgICBsaXN0ZW5lciBpcyB0aGVuIGNhbGxlZCB3aGVuZXZlciBldmVudHMgYXJlIHJlY2VpdmVkIGJ5IHRoZSBjYWxsYmFja1xuICogICAgICAgYWN0b3JcbiAqICAgLSBgc2VuZEJhY2tgIC0gQSBmdW5jdGlvbiB0aGF0IGNhbiBzZW5kIGV2ZW50cyBiYWNrIHRvIHRoZSBwYXJlbnQgYWN0b3JcbiAqICAgLSBgaW5wdXRgIC0gRGF0YSB0aGF0IHdhcyBwcm92aWRlZCB0byB0aGUgY2FsbGJhY2sgYWN0b3JcbiAqICAgLSBgc2VsZmAgLSBUaGUgcGFyZW50IGFjdG9yIG9mIHRoZSBjYWxsYmFjayBhY3RvclxuICogICAtIGBzeXN0ZW1gIC0gVGhlIGFjdG9yIHN5c3RlbSB0byB3aGljaCB0aGUgY2FsbGJhY2sgYWN0b3IgYmVsb25ncyBUaGUgY2FsbGJhY2tcbiAqICAgICAgIGZ1bmN0aW9uIGNhbiAob3B0aW9uYWxseSkgcmV0dXJuIGEgY2xlYW51cCBmdW5jdGlvbiwgd2hpY2ggaXMgY2FsbGVkXG4gKiAgICAgICB3aGVuIHRoZSBhY3RvciBpcyBzdG9wcGVkLlxuICpcbiAqIEByZXR1cm5zIENhbGxiYWNrIGxvZ2ljXG4gKiBAc2VlIHtAbGluayBDYWxsYmFja0xvZ2ljRnVuY3Rpb259IGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjYWxsYmFjayBmdW5jdGlvbiBhbmQgaXRzIG9iamVjdCBhcmd1bWVudFxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9zdGF0ZWx5LmFpL2RvY3MvaW5wdXQgfCBJbnB1dCBkb2NzfSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBob3cgaW5wdXQgaXMgcGFzc2VkXG4gKi9cbmZ1bmN0aW9uIGZyb21DYWxsYmFjayhjYWxsYmFjaykge1xuICBjb25zdCBsb2dpYyA9IHtcbiAgICBjb25maWc6IGNhbGxiYWNrLFxuICAgIHN0YXJ0OiAoc3RhdGUsIGFjdG9yU2NvcGUpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2VsZixcbiAgICAgICAgc3lzdGVtLFxuICAgICAgICBlbWl0XG4gICAgICB9ID0gYWN0b3JTY29wZTtcbiAgICAgIGNvbnN0IGNhbGxiYWNrU3RhdGUgPSB7XG4gICAgICAgIHJlY2VpdmVyczogdW5kZWZpbmVkLFxuICAgICAgICBkaXNwb3NlOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgICBpbnN0YW5jZVN0YXRlcy5zZXQoc2VsZiwgY2FsbGJhY2tTdGF0ZSk7XG4gICAgICBjYWxsYmFja1N0YXRlLmRpc3Bvc2UgPSBjYWxsYmFjayh7XG4gICAgICAgIGlucHV0OiBzdGF0ZS5pbnB1dCxcbiAgICAgICAgc3lzdGVtLFxuICAgICAgICBzZWxmLFxuICAgICAgICBzZW5kQmFjazogZXZlbnQgPT4ge1xuICAgICAgICAgIGlmIChzZWxmLmdldFNuYXBzaG90KCkuc3RhdHVzID09PSAnc3RvcHBlZCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNlbGYuX3BhcmVudCkge1xuICAgICAgICAgICAgc3lzdGVtLl9yZWxheShzZWxmLCBzZWxmLl9wYXJlbnQsIGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlY2VpdmU6IGxpc3RlbmVyID0+IHtcbiAgICAgICAgICBjYWxsYmFja1N0YXRlLnJlY2VpdmVycyA/Pz0gbmV3IFNldCgpO1xuICAgICAgICAgIGNhbGxiYWNrU3RhdGUucmVjZWl2ZXJzLmFkZChsaXN0ZW5lcik7XG4gICAgICAgIH0sXG4gICAgICAgIGVtaXRcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgdHJhbnNpdGlvbjogKHN0YXRlLCBldmVudCwgYWN0b3JTY29wZSkgPT4ge1xuICAgICAgY29uc3QgY2FsbGJhY2tTdGF0ZSA9IGluc3RhbmNlU3RhdGVzLmdldChhY3RvclNjb3BlLnNlbGYpO1xuICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IFhTVEFURV9TVE9QKSB7XG4gICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgIHN0YXR1czogJ3N0b3BwZWQnLFxuICAgICAgICAgIGVycm9yOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICAgICAgY2FsbGJhY2tTdGF0ZS5kaXNwb3NlPy4oKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2tTdGF0ZS5yZWNlaXZlcnM/LmZvckVhY2gocmVjZWl2ZXIgPT4gcmVjZWl2ZXIoZXZlbnQpKTtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9LFxuICAgIGdldEluaXRpYWxTbmFwc2hvdDogKF8sIGlucHV0KSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6ICdhY3RpdmUnLFxuICAgICAgICBvdXRwdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgZXJyb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgaW5wdXRcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXRQZXJzaXN0ZWRTbmFwc2hvdDogc25hcHNob3QgPT4gc25hcHNob3QsXG4gICAgcmVzdG9yZVNuYXBzaG90OiBzbmFwc2hvdCA9PiBzbmFwc2hvdFxuICB9O1xuICByZXR1cm4gbG9naWM7XG59XG5cbmNvbnN0IFhTVEFURV9PQlNFUlZBQkxFX05FWFQgPSAneHN0YXRlLm9ic2VydmFibGUubmV4dCc7XG5jb25zdCBYU1RBVEVfT0JTRVJWQUJMRV9FUlJPUiA9ICd4c3RhdGUub2JzZXJ2YWJsZS5lcnJvcic7XG5jb25zdCBYU1RBVEVfT0JTRVJWQUJMRV9DT01QTEVURSA9ICd4c3RhdGUub2JzZXJ2YWJsZS5jb21wbGV0ZSc7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBhY3RvciBjcmVhdGVkIGJ5IGBmcm9tT2JzZXJ2YWJsZWAgb3IgYGZyb21FdmVudE9ic2VydmFibGVgLlxuICpcbiAqIFRoZSB0eXBlIG9mIGBzZWxmYCB3aXRoaW4gdGhlIGFjdG9yJ3MgbG9naWMuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgZnJvbU9ic2VydmFibGUsIGNyZWF0ZUFjdG9yIH0gZnJvbSAneHN0YXRlJztcbiAqIGltcG9ydCB7IGludGVydmFsIH0gZnJvbSAncnhqcyc7XG4gKlxuICogLy8gVGhlIHR5cGUgb2YgdGhlIHZhbHVlIG9ic2VydmVkIGJ5IHRoZSBhY3RvcidzIGxvZ2ljLlxuICogdHlwZSBDb250ZXh0ID0gbnVtYmVyO1xuICogLy8gVGhlIGFjdG9yJ3MgaW5wdXQuXG4gKiB0eXBlIElucHV0ID0geyBwZXJpb2Q/OiBudW1iZXIgfTtcbiAqXG4gKiAvLyBBY3RvciBsb2dpYyB0aGF0IG9ic2VydmVzIGEgbnVtYmVyIGluY3JlbWVudGVkIGV2ZXJ5IGBpbnB1dC5wZXJpb2RgXG4gKiAvLyBtaWxsaXNlY29uZHMgKGRlZmF1bHQ6IDFfMDAwKS5cbiAqIGNvbnN0IGxvZ2ljID0gZnJvbU9ic2VydmFibGU8Q29udGV4dCwgSW5wdXQ+KCh7IGlucHV0LCBzZWxmIH0pID0+IHtcbiAqICAgc2VsZjtcbiAqICAgLy8gXj8gT2JzZXJ2YWJsZUFjdG9yUmVmPEV2ZW50LCBJbnB1dD5cbiAqXG4gKiAgIHJldHVybiBpbnRlcnZhbChpbnB1dC5wZXJpb2QgPz8gMV8wMDApO1xuICogfSk7XG4gKlxuICogY29uc3QgYWN0b3IgPSBjcmVhdGVBY3Rvcihsb2dpYywgeyBpbnB1dDogeyBwZXJpb2Q6IDJfMDAwIH0gfSk7XG4gKiAvLyAgICBePyBPYnNlcnZhYmxlQWN0b3JSZWY8RXZlbnQsIElucHV0PlxuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgZnJvbU9ic2VydmFibGV9XG4gKiBAc2VlIHtAbGluayBmcm9tRXZlbnRPYnNlcnZhYmxlfVxuICovXG5cbi8qKlxuICogT2JzZXJ2YWJsZSBhY3RvciBsb2dpYyBpcyBkZXNjcmliZWQgYnkgYW4gb2JzZXJ2YWJsZSBzdHJlYW0gb2YgdmFsdWVzLiBBY3RvcnNcbiAqIGNyZWF0ZWQgZnJvbSBvYnNlcnZhYmxlIGxvZ2ljICjigJxvYnNlcnZhYmxlIGFjdG9yc+KAnSkgY2FuOlxuICpcbiAqIC0gRW1pdCBzbmFwc2hvdHMgb2YgdGhlIG9ic2VydmFibGXigJlzIGVtaXR0ZWQgdmFsdWVcbiAqXG4gKiBUaGUgb2JzZXJ2YWJsZeKAmXMgZW1pdHRlZCB2YWx1ZSBpcyB1c2VkIGFzIGl0cyBvYnNlcnZhYmxlIGFjdG9y4oCZcyBgY29udGV4dGAuXG4gKlxuICogU2VuZGluZyBldmVudHMgdG8gb2JzZXJ2YWJsZSBhY3RvcnMgd2lsbCBoYXZlIG5vIGVmZmVjdC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBmcm9tT2JzZXJ2YWJsZSwgY3JlYXRlQWN0b3IgfSBmcm9tICd4c3RhdGUnO1xuICogaW1wb3J0IHsgaW50ZXJ2YWwgfSBmcm9tICdyeGpzJztcbiAqXG4gKiBjb25zdCBsb2dpYyA9IGZyb21PYnNlcnZhYmxlKChvYmopID0+IGludGVydmFsKDEwMDApKTtcbiAqXG4gKiBjb25zdCBhY3RvciA9IGNyZWF0ZUFjdG9yKGxvZ2ljKTtcbiAqXG4gKiBhY3Rvci5zdWJzY3JpYmUoKHNuYXBzaG90KSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKHNuYXBzaG90LmNvbnRleHQpO1xuICogfSk7XG4gKlxuICogYWN0b3Iuc3RhcnQoKTtcbiAqIC8vIEF0IGV2ZXJ5IHNlY29uZDpcbiAqIC8vIExvZ3MgMFxuICogLy8gTG9ncyAxXG4gKiAvLyBMb2dzIDJcbiAqIC8vIC4uLlxuICogYGBgXG4gKlxuICogQHBhcmFtIG9ic2VydmFibGVDcmVhdG9yIEEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGFuIG9ic2VydmFibGUuIEl0IHJlY2VpdmVzXG4gKiAgIG9uZSBhcmd1bWVudCwgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBgaW5wdXRgIC0gRGF0YSB0aGF0IHdhcyBwcm92aWRlZCB0byB0aGUgb2JzZXJ2YWJsZSBhY3RvclxuICogICAtIGBzZWxmYCAtIFRoZSBwYXJlbnQgYWN0b3JcbiAqICAgLSBgc3lzdGVtYCAtIFRoZSBhY3RvciBzeXN0ZW0gdG8gd2hpY2ggdGhlIG9ic2VydmFibGUgYWN0b3IgYmVsb25nc1xuICpcbiAqICAgSXQgc2hvdWxkIHJldHVybiBhIHtAbGluayBTdWJzY3JpYmFibGV9LCB3aGljaCBpcyBjb21wYXRpYmxlIHdpdGggYW4gUnhKU1xuICogICBPYnNlcnZhYmxlLCBhbHRob3VnaCBSeEpTIGlzIG5vdCByZXF1aXJlZCB0byBjcmVhdGUgdGhlbS5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vcnhqcy5kZXZ9IGZvciBkb2N1bWVudGF0aW9uIG9uIFJ4SlMgT2JzZXJ2YWJsZSBhbmQgb2JzZXJ2YWJsZSBjcmVhdG9ycy5cbiAqIEBzZWUge0BsaW5rIFN1YnNjcmliYWJsZX0gaW50ZXJmYWNlIGluIFhTdGF0ZSwgd2hpY2ggaXMgYmFzZWQgb24gYW5kIGNvbXBhdGlibGUgd2l0aCBSeEpTIE9ic2VydmFibGUuXG4gKi9cbmZ1bmN0aW9uIGZyb21PYnNlcnZhYmxlKG9ic2VydmFibGVDcmVhdG9yKSB7XG4gIC8vIFRPRE86IGFkZCBldmVudCB0eXBlc1xuICBjb25zdCBsb2dpYyA9IHtcbiAgICBjb25maWc6IG9ic2VydmFibGVDcmVhdG9yLFxuICAgIHRyYW5zaXRpb246IChzbmFwc2hvdCwgZXZlbnQpID0+IHtcbiAgICAgIGlmIChzbmFwc2hvdC5zdGF0dXMgIT09ICdhY3RpdmUnKSB7XG4gICAgICAgIHJldHVybiBzbmFwc2hvdDtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICBjYXNlIFhTVEFURV9PQlNFUlZBQkxFX05FWFQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgbmV3U25hcHNob3QgPSB7XG4gICAgICAgICAgICAgIC4uLnNuYXBzaG90LFxuICAgICAgICAgICAgICBjb250ZXh0OiBldmVudC5kYXRhXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIG5ld1NuYXBzaG90O1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBYU1RBVEVfT0JTRVJWQUJMRV9FUlJPUjpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc25hcHNob3QsXG4gICAgICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgICAgICBlcnJvcjogZXZlbnQuZGF0YSxcbiAgICAgICAgICAgIGlucHV0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBfc3Vic2NyaXB0aW9uOiB1bmRlZmluZWRcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFhTVEFURV9PQlNFUlZBQkxFX0NPTVBMRVRFOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zbmFwc2hvdCxcbiAgICAgICAgICAgIHN0YXR1czogJ2RvbmUnLFxuICAgICAgICAgICAgaW5wdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIF9zdWJzY3JpcHRpb246IHVuZGVmaW5lZFxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgWFNUQVRFX1NUT1A6XG4gICAgICAgICAgc25hcHNob3QuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zbmFwc2hvdCxcbiAgICAgICAgICAgIHN0YXR1czogJ3N0b3BwZWQnLFxuICAgICAgICAgICAgaW5wdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIF9zdWJzY3JpcHRpb246IHVuZGVmaW5lZFxuICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHNuYXBzaG90O1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0SW5pdGlhbFNuYXBzaG90OiAoXywgaW5wdXQpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogJ2FjdGl2ZScsXG4gICAgICAgIG91dHB1dDogdW5kZWZpbmVkLFxuICAgICAgICBlcnJvcjogdW5kZWZpbmVkLFxuICAgICAgICBjb250ZXh0OiB1bmRlZmluZWQsXG4gICAgICAgIGlucHV0LFxuICAgICAgICBfc3Vic2NyaXB0aW9uOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgfSxcbiAgICBzdGFydDogKHN0YXRlLCB7XG4gICAgICBzZWxmLFxuICAgICAgc3lzdGVtLFxuICAgICAgZW1pdFxuICAgIH0pID0+IHtcbiAgICAgIGlmIChzdGF0ZS5zdGF0dXMgPT09ICdkb25lJykge1xuICAgICAgICAvLyBEbyBub3QgcmVzdGFydCBhIGNvbXBsZXRlZCBvYnNlcnZhYmxlXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN0YXRlLl9zdWJzY3JpcHRpb24gPSBvYnNlcnZhYmxlQ3JlYXRvcih7XG4gICAgICAgIGlucHV0OiBzdGF0ZS5pbnB1dCxcbiAgICAgICAgc3lzdGVtLFxuICAgICAgICBzZWxmLFxuICAgICAgICBlbWl0XG4gICAgICB9KS5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiB2YWx1ZSA9PiB7XG4gICAgICAgICAgc3lzdGVtLl9yZWxheShzZWxmLCBzZWxmLCB7XG4gICAgICAgICAgICB0eXBlOiBYU1RBVEVfT0JTRVJWQUJMRV9ORVhULFxuICAgICAgICAgICAgZGF0YTogdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IGVyciA9PiB7XG4gICAgICAgICAgc3lzdGVtLl9yZWxheShzZWxmLCBzZWxmLCB7XG4gICAgICAgICAgICB0eXBlOiBYU1RBVEVfT0JTRVJWQUJMRV9FUlJPUixcbiAgICAgICAgICAgIGRhdGE6IGVyclxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAgIHN5c3RlbS5fcmVsYXkoc2VsZiwgc2VsZiwge1xuICAgICAgICAgICAgdHlwZTogWFNUQVRFX09CU0VSVkFCTEVfQ09NUExFVEVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXRQZXJzaXN0ZWRTbmFwc2hvdDogKHtcbiAgICAgIF9zdWJzY3JpcHRpb24sXG4gICAgICAuLi5zdGF0ZVxuICAgIH0pID0+IHN0YXRlLFxuICAgIHJlc3RvcmVTbmFwc2hvdDogc3RhdGUgPT4gKHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgX3N1YnNjcmlwdGlvbjogdW5kZWZpbmVkXG4gICAgfSlcbiAgfTtcbiAgcmV0dXJuIGxvZ2ljO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgZXZlbnQgb2JzZXJ2YWJsZSBsb2dpYyB0aGF0IGxpc3RlbnMgdG8gYW4gb2JzZXJ2YWJsZSB0aGF0IGRlbGl2ZXJzXG4gKiBldmVudCBvYmplY3RzLlxuICpcbiAqIEV2ZW50IG9ic2VydmFibGUgYWN0b3IgbG9naWMgaXMgZGVzY3JpYmVkIGJ5IGFuIG9ic2VydmFibGUgc3RyZWFtIG9mXG4gKiB7QGxpbmsgaHR0cHM6Ly9zdGF0ZWx5LmFpL2RvY3MvdHJhbnNpdGlvbnMjZXZlbnQtb2JqZWN0cyB8IGV2ZW50IG9iamVjdHN9LlxuICogQWN0b3JzIGNyZWF0ZWQgZnJvbSBldmVudCBvYnNlcnZhYmxlIGxvZ2ljICjigJxldmVudCBvYnNlcnZhYmxlIGFjdG9yc+KAnSkgY2FuOlxuICpcbiAqIC0gSW1wbGljaXRseSBzZW5kIGV2ZW50cyB0byBpdHMgcGFyZW50IGFjdG9yXG4gKiAtIEVtaXQgc25hcHNob3RzIG9mIGl0cyBlbWl0dGVkIGV2ZW50IG9iamVjdHNcbiAqXG4gKiBTZW5kaW5nIGV2ZW50cyB0byBldmVudCBvYnNlcnZhYmxlIGFjdG9ycyB3aWxsIGhhdmUgbm8gZWZmZWN0LlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7XG4gKiAgIGZyb21FdmVudE9ic2VydmFibGUsXG4gKiAgIFN1YnNjcmliYWJsZSxcbiAqICAgRXZlbnRPYmplY3QsXG4gKiAgIGNyZWF0ZU1hY2hpbmUsXG4gKiAgIGNyZWF0ZUFjdG9yXG4gKiB9IGZyb20gJ3hzdGF0ZSc7XG4gKiBpbXBvcnQgeyBmcm9tRXZlbnQgfSBmcm9tICdyeGpzJztcbiAqXG4gKiBjb25zdCBtb3VzZUNsaWNrTG9naWMgPSBmcm9tRXZlbnRPYnNlcnZhYmxlKFxuICogICAoKSA9PiBmcm9tRXZlbnQoZG9jdW1lbnQuYm9keSwgJ2NsaWNrJykgYXMgU3Vic2NyaWJhYmxlPEV2ZW50T2JqZWN0PlxuICogKTtcbiAqXG4gKiBjb25zdCBjYW52YXNNYWNoaW5lID0gY3JlYXRlTWFjaGluZSh7XG4gKiAgIGludm9rZToge1xuICogICAgIC8vIFdpbGwgc2VuZCBtb3VzZSBgY2xpY2tgIGV2ZW50cyB0byB0aGUgY2FudmFzIGFjdG9yXG4gKiAgICAgc3JjOiBtb3VzZUNsaWNrTG9naWNcbiAqICAgfVxuICogfSk7XG4gKlxuICogY29uc3QgY2FudmFzQWN0b3IgPSBjcmVhdGVBY3RvcihjYW52YXNNYWNoaW5lKTtcbiAqIGNhbnZhc0FjdG9yLnN0YXJ0KCk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gbGF6eU9ic2VydmFibGUgQSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYW4gb2JzZXJ2YWJsZSB0aGF0IGRlbGl2ZXJzXG4gKiAgIGV2ZW50IG9iamVjdHMuIEl0IHJlY2VpdmVzIG9uZSBhcmd1bWVudCwgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZ1xuICogICBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBgaW5wdXRgIC0gRGF0YSB0aGF0IHdhcyBwcm92aWRlZCB0byB0aGUgZXZlbnQgb2JzZXJ2YWJsZSBhY3RvclxuICogICAtIGBzZWxmYCAtIFRoZSBwYXJlbnQgYWN0b3JcbiAqICAgLSBgc3lzdGVtYCAtIFRoZSBhY3RvciBzeXN0ZW0gdG8gd2hpY2ggdGhlIGV2ZW50IG9ic2VydmFibGUgYWN0b3IgYmVsb25ncy5cbiAqXG4gKiAgIEl0IHNob3VsZCByZXR1cm4gYSB7QGxpbmsgU3Vic2NyaWJhYmxlfSwgd2hpY2ggaXMgY29tcGF0aWJsZSB3aXRoIGFuIFJ4SlNcbiAqICAgT2JzZXJ2YWJsZSwgYWx0aG91Z2ggUnhKUyBpcyBub3QgcmVxdWlyZWQgdG8gY3JlYXRlIHRoZW0uXG4gKi9cbmZ1bmN0aW9uIGZyb21FdmVudE9ic2VydmFibGUobGF6eU9ic2VydmFibGUpIHtcbiAgLy8gVE9ETzogZXZlbnQgdHlwZXNcbiAgY29uc3QgbG9naWMgPSB7XG4gICAgY29uZmlnOiBsYXp5T2JzZXJ2YWJsZSxcbiAgICB0cmFuc2l0aW9uOiAoc3RhdGUsIGV2ZW50KSA9PiB7XG4gICAgICBpZiAoc3RhdGUuc3RhdHVzICE9PSAnYWN0aXZlJykge1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgY2FzZSBYU1RBVEVfT0JTRVJWQUJMRV9FUlJPUjpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgICAgICBlcnJvcjogZXZlbnQuZGF0YSxcbiAgICAgICAgICAgIGlucHV0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBfc3Vic2NyaXB0aW9uOiB1bmRlZmluZWRcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFhTVEFURV9PQlNFUlZBQkxFX0NPTVBMRVRFOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgIHN0YXR1czogJ2RvbmUnLFxuICAgICAgICAgICAgaW5wdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIF9zdWJzY3JpcHRpb246IHVuZGVmaW5lZFxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgWFNUQVRFX1NUT1A6XG4gICAgICAgICAgc3RhdGUuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgIHN0YXR1czogJ3N0b3BwZWQnLFxuICAgICAgICAgICAgaW5wdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIF9zdWJzY3JpcHRpb246IHVuZGVmaW5lZFxuICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0SW5pdGlhbFNuYXBzaG90OiAoXywgaW5wdXQpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogJ2FjdGl2ZScsXG4gICAgICAgIG91dHB1dDogdW5kZWZpbmVkLFxuICAgICAgICBlcnJvcjogdW5kZWZpbmVkLFxuICAgICAgICBjb250ZXh0OiB1bmRlZmluZWQsXG4gICAgICAgIGlucHV0LFxuICAgICAgICBfc3Vic2NyaXB0aW9uOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgfSxcbiAgICBzdGFydDogKHN0YXRlLCB7XG4gICAgICBzZWxmLFxuICAgICAgc3lzdGVtLFxuICAgICAgZW1pdFxuICAgIH0pID0+IHtcbiAgICAgIGlmIChzdGF0ZS5zdGF0dXMgPT09ICdkb25lJykge1xuICAgICAgICAvLyBEbyBub3QgcmVzdGFydCBhIGNvbXBsZXRlZCBvYnNlcnZhYmxlXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN0YXRlLl9zdWJzY3JpcHRpb24gPSBsYXp5T2JzZXJ2YWJsZSh7XG4gICAgICAgIGlucHV0OiBzdGF0ZS5pbnB1dCxcbiAgICAgICAgc3lzdGVtLFxuICAgICAgICBzZWxmLFxuICAgICAgICBlbWl0XG4gICAgICB9KS5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiB2YWx1ZSA9PiB7XG4gICAgICAgICAgaWYgKHNlbGYuX3BhcmVudCkge1xuICAgICAgICAgICAgc3lzdGVtLl9yZWxheShzZWxmLCBzZWxmLl9wYXJlbnQsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBlcnIgPT4ge1xuICAgICAgICAgIHN5c3RlbS5fcmVsYXkoc2VsZiwgc2VsZiwge1xuICAgICAgICAgICAgdHlwZTogWFNUQVRFX09CU0VSVkFCTEVfRVJST1IsXG4gICAgICAgICAgICBkYXRhOiBlcnJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICBzeXN0ZW0uX3JlbGF5KHNlbGYsIHNlbGYsIHtcbiAgICAgICAgICAgIHR5cGU6IFhTVEFURV9PQlNFUlZBQkxFX0NPTVBMRVRFXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0UGVyc2lzdGVkU25hcHNob3Q6ICh7XG4gICAgICBfc3Vic2NyaXB0aW9uLFxuICAgICAgLi4uc25hcHNob3RcbiAgICB9KSA9PiBzbmFwc2hvdCxcbiAgICByZXN0b3JlU25hcHNob3Q6IHNuYXBzaG90ID0+ICh7XG4gICAgICAuLi5zbmFwc2hvdCxcbiAgICAgIF9zdWJzY3JpcHRpb246IHVuZGVmaW5lZFxuICAgIH0pXG4gIH07XG4gIHJldHVybiBsb2dpYztcbn1cblxuY29uc3QgWFNUQVRFX1BST01JU0VfUkVTT0xWRSA9ICd4c3RhdGUucHJvbWlzZS5yZXNvbHZlJztcbmNvbnN0IFhTVEFURV9QUk9NSVNFX1JFSkVDVCA9ICd4c3RhdGUucHJvbWlzZS5yZWplY3QnO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gYWN0b3IgY3JlYXRlZCBieSBgZnJvbVByb21pc2VgLlxuICpcbiAqIFRoZSB0eXBlIG9mIGBzZWxmYCB3aXRoaW4gdGhlIGFjdG9yJ3MgbG9naWMuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgZnJvbVByb21pc2UsIGNyZWF0ZUFjdG9yIH0gZnJvbSAneHN0YXRlJztcbiAqXG4gKiAvLyBUaGUgYWN0b3IncyByZXNvbHZlZCBvdXRwdXRcbiAqIHR5cGUgT3V0cHV0ID0gc3RyaW5nO1xuICogLy8gVGhlIGFjdG9yJ3MgaW5wdXQuXG4gKiB0eXBlIElucHV0ID0geyBtZXNzYWdlOiBzdHJpbmcgfTtcbiAqXG4gKiAvLyBBY3RvciBsb2dpYyB0aGF0IGZldGNoZXMgdGhlIHVybCBvZiBhbiBpbWFnZSBvZiBhIGNhdCBzYXlpbmcgYGlucHV0Lm1lc3NhZ2VgLlxuICogY29uc3QgbG9naWMgPSBmcm9tUHJvbWlzZTxPdXRwdXQsIElucHV0Pihhc3luYyAoeyBpbnB1dCwgc2VsZiB9KSA9PiB7XG4gKiAgIHNlbGY7XG4gKiAgIC8vIF4/IFByb21pc2VBY3RvclJlZjxPdXRwdXQsIElucHV0PlxuICpcbiAqICAgY29uc3QgZGF0YSA9IGF3YWl0IGZldGNoKFxuICogICAgIGBodHRwczovL2NhdGFhcy5jb20vY2F0L3NheXMvJHtpbnB1dC5tZXNzYWdlfWBcbiAqICAgKTtcbiAqICAgY29uc3QgdXJsID0gYXdhaXQgZGF0YS5qc29uKCk7XG4gKiAgIHJldHVybiB1cmw7XG4gKiB9KTtcbiAqXG4gKiBjb25zdCBhY3RvciA9IGNyZWF0ZUFjdG9yKGxvZ2ljLCB7IGlucHV0OiB7IG1lc3NhZ2U6ICdoZWxsbyB3b3JsZCcgfSB9KTtcbiAqIC8vICAgIF4/IFByb21pc2VBY3RvclJlZjxPdXRwdXQsIElucHV0PlxuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgZnJvbVByb21pc2V9XG4gKi9cblxuY29uc3QgY29udHJvbGxlck1hcCA9IG5ldyBXZWFrTWFwKCk7XG5cbi8qKlxuICogQW4gYWN0b3IgbG9naWMgY3JlYXRvciB3aGljaCByZXR1cm5zIHByb21pc2UgbG9naWMgYXMgZGVmaW5lZCBieSBhbiBhc3luY1xuICogcHJvY2VzcyB0aGF0IHJlc29sdmVzIG9yIHJlamVjdHMgYWZ0ZXIgc29tZSB0aW1lLlxuICpcbiAqIEFjdG9ycyBjcmVhdGVkIGZyb20gcHJvbWlzZSBhY3RvciBsb2dpYyAo4oCccHJvbWlzZSBhY3RvcnPigJ0pIGNhbjpcbiAqXG4gKiAtIEVtaXQgdGhlIHJlc29sdmVkIHZhbHVlIG9mIHRoZSBwcm9taXNlXG4gKiAtIE91dHB1dCB0aGUgcmVzb2x2ZWQgdmFsdWUgb2YgdGhlIHByb21pc2VcbiAqXG4gKiBTZW5kaW5nIGV2ZW50cyB0byBwcm9taXNlIGFjdG9ycyB3aWxsIGhhdmUgbm8gZWZmZWN0LlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IHByb21pc2VMb2dpYyA9IGZyb21Qcm9taXNlKGFzeW5jICgpID0+IHtcbiAqICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vZXhhbXBsZS5jb20vLi4uJykudGhlbigoZGF0YSkgPT5cbiAqICAgICBkYXRhLmpzb24oKVxuICogICApO1xuICpcbiAqICAgcmV0dXJuIHJlc3VsdDtcbiAqIH0pO1xuICpcbiAqIGNvbnN0IHByb21pc2VBY3RvciA9IGNyZWF0ZUFjdG9yKHByb21pc2VMb2dpYyk7XG4gKiBwcm9taXNlQWN0b3Iuc3Vic2NyaWJlKChzbmFwc2hvdCkgPT4ge1xuICogICBjb25zb2xlLmxvZyhzbmFwc2hvdCk7XG4gKiB9KTtcbiAqIHByb21pc2VBY3Rvci5zdGFydCgpO1xuICogLy8gPT4ge1xuICogLy8gICBvdXRwdXQ6IHVuZGVmaW5lZCxcbiAqIC8vICAgc3RhdHVzOiAnYWN0aXZlJ1xuICogLy8gICAuLi5cbiAqIC8vIH1cbiAqXG4gKiAvLyBBZnRlciBwcm9taXNlIHJlc29sdmVzXG4gKiAvLyA9PiB7XG4gKiAvLyAgIG91dHB1dDogeyAuLi4gfSxcbiAqIC8vICAgc3RhdHVzOiAnZG9uZScsXG4gKiAvLyAgIC4uLlxuICogLy8gfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHByb21pc2VDcmVhdG9yIEEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhIFByb21pc2UsIGFuZCBhY2NlcHRzIGFuXG4gKiAgIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gYGlucHV0YCAtIERhdGEgdGhhdCB3YXMgcHJvdmlkZWQgdG8gdGhlIHByb21pc2UgYWN0b3JcbiAqICAgLSBgc2VsZmAgLSBUaGUgcGFyZW50IGFjdG9yIG9mIHRoZSBwcm9taXNlIGFjdG9yXG4gKiAgIC0gYHN5c3RlbWAgLSBUaGUgYWN0b3Igc3lzdGVtIHRvIHdoaWNoIHRoZSBwcm9taXNlIGFjdG9yIGJlbG9uZ3NcbiAqXG4gKiBAc2VlIHtAbGluayBodHRwczovL3N0YXRlbHkuYWkvZG9jcy9pbnB1dCB8IElucHV0IGRvY3N9IGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IGhvdyBpbnB1dCBpcyBwYXNzZWRcbiAqL1xuZnVuY3Rpb24gZnJvbVByb21pc2UocHJvbWlzZUNyZWF0b3IpIHtcbiAgY29uc3QgbG9naWMgPSB7XG4gICAgY29uZmlnOiBwcm9taXNlQ3JlYXRvcixcbiAgICB0cmFuc2l0aW9uOiAoc3RhdGUsIGV2ZW50LCBzY29wZSkgPT4ge1xuICAgICAgaWYgKHN0YXRlLnN0YXR1cyAhPT0gJ2FjdGl2ZScpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgIGNhc2UgWFNUQVRFX1BST01JU0VfUkVTT0xWRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZFZhbHVlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICBzdGF0dXM6ICdkb25lJyxcbiAgICAgICAgICAgICAgb3V0cHV0OiByZXNvbHZlZFZhbHVlLFxuICAgICAgICAgICAgICBpbnB1dDogdW5kZWZpbmVkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBYU1RBVEVfUFJPTUlTRV9SRUpFQ1Q6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgICAgICAgZXJyb3I6IGV2ZW50LmRhdGEsXG4gICAgICAgICAgICBpbnB1dDogdW5kZWZpbmVkXG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBYU1RBVEVfU1RPUDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb250cm9sbGVyTWFwLmdldChzY29wZS5zZWxmKT8uYWJvcnQoKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICBzdGF0dXM6ICdzdG9wcGVkJyxcbiAgICAgICAgICAgICAgaW5wdXQ6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuICAgIH0sXG4gICAgc3RhcnQ6IChzdGF0ZSwge1xuICAgICAgc2VsZixcbiAgICAgIHN5c3RlbSxcbiAgICAgIGVtaXRcbiAgICB9KSA9PiB7XG4gICAgICAvLyBUT0RPOiBkZXRlcm1pbmUgaG93IHRvIGFsbG93IGN1c3RvbWl6aW5nIHRoaXMgc28gdGhhdCBwcm9taXNlc1xuICAgICAgLy8gY2FuIGJlIHJlc3RhcnRlZCBpZiBuZWNlc3NhcnlcbiAgICAgIGlmIChzdGF0ZS5zdGF0dXMgIT09ICdhY3RpdmUnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICBjb250cm9sbGVyTWFwLnNldChzZWxmLCBjb250cm9sbGVyKTtcbiAgICAgIGNvbnN0IHJlc29sdmVkUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShwcm9taXNlQ3JlYXRvcih7XG4gICAgICAgIGlucHV0OiBzdGF0ZS5pbnB1dCxcbiAgICAgICAgc3lzdGVtLFxuICAgICAgICBzZWxmLFxuICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICBlbWl0XG4gICAgICB9KSk7XG4gICAgICByZXNvbHZlZFByb21pc2UudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgIGlmIChzZWxmLmdldFNuYXBzaG90KCkuc3RhdHVzICE9PSAnYWN0aXZlJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sbGVyTWFwLmRlbGV0ZShzZWxmKTtcbiAgICAgICAgc3lzdGVtLl9yZWxheShzZWxmLCBzZWxmLCB7XG4gICAgICAgICAgdHlwZTogWFNUQVRFX1BST01JU0VfUkVTT0xWRSxcbiAgICAgICAgICBkYXRhOiByZXNwb25zZVxuICAgICAgICB9KTtcbiAgICAgIH0sIGVycm9yRGF0YSA9PiB7XG4gICAgICAgIGlmIChzZWxmLmdldFNuYXBzaG90KCkuc3RhdHVzICE9PSAnYWN0aXZlJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sbGVyTWFwLmRlbGV0ZShzZWxmKTtcbiAgICAgICAgc3lzdGVtLl9yZWxheShzZWxmLCBzZWxmLCB7XG4gICAgICAgICAgdHlwZTogWFNUQVRFX1BST01JU0VfUkVKRUNULFxuICAgICAgICAgIGRhdGE6IGVycm9yRGF0YVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0SW5pdGlhbFNuYXBzaG90OiAoXywgaW5wdXQpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogJ2FjdGl2ZScsXG4gICAgICAgIG91dHB1dDogdW5kZWZpbmVkLFxuICAgICAgICBlcnJvcjogdW5kZWZpbmVkLFxuICAgICAgICBpbnB1dFxuICAgICAgfTtcbiAgICB9LFxuICAgIGdldFBlcnNpc3RlZFNuYXBzaG90OiBzbmFwc2hvdCA9PiBzbmFwc2hvdCxcbiAgICByZXN0b3JlU25hcHNob3Q6IHNuYXBzaG90ID0+IHNuYXBzaG90XG4gIH07XG4gIHJldHVybiBsb2dpYztcbn1cblxuY29uc3QgZW1wdHlMb2dpYyA9IGZyb21UcmFuc2l0aW9uKF8gPT4gdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuZnVuY3Rpb24gY3JlYXRlRW1wdHlBY3RvcigpIHtcbiAgcmV0dXJuIGNyZWF0ZUFjdG9yKGVtcHR5TG9naWMpO1xufVxuXG5leHBvcnQgeyBjcmVhdGVFbXB0eUFjdG9yLCBmcm9tQ2FsbGJhY2ssIGZyb21FdmVudE9ic2VydmFibGUsIGZyb21PYnNlcnZhYmxlLCBmcm9tUHJvbWlzZSwgZnJvbVRyYW5zaXRpb24gfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/xstate/actors/dist/xstate-actors.development.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/xstate/dev/dist/xstate-dev.development.esm.js":
/*!********************************************************************!*\
  !*** ./node_modules/xstate/dev/dist/xstate-dev.development.esm.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   devToolsAdapter: function() { return /* binding */ devToolsAdapter; },\n/* harmony export */   getGlobal: function() { return /* binding */ getGlobal; },\n/* harmony export */   registerService: function() { return /* binding */ registerService; }\n/* harmony export */ });\n// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis\nfunction getGlobal() {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  }\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof __webpack_require__.g !== 'undefined') {\n    return __webpack_require__.g;\n  }\n  {\n    console.warn('XState could not find a global object in this environment. Please let the maintainers know and raise an issue here: https://github.com/statelyai/xstate/issues');\n  }\n}\nfunction getDevTools() {\n  const w = getGlobal();\n  if (!!w.__xstate__) {\n    return w.__xstate__;\n  }\n  return undefined;\n}\nfunction registerService(service) {\n  if (typeof window === 'undefined') {\n    return;\n  }\n  const devTools = getDevTools();\n  if (devTools) {\n    devTools.register(service);\n  }\n}\nconst devToolsAdapter = service => {\n  if (typeof window === 'undefined') {\n    return;\n  }\n  const devTools = getDevTools();\n  if (devTools) {\n    devTools.register(service);\n  }\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy94c3RhdGUvZGV2L2Rpc3QveHN0YXRlLWRldi5kZXZlbG9wbWVudC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEscUJBQU07QUFDbkIsV0FBVyxxQkFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy94c3RhdGUvZGV2L2Rpc3QveHN0YXRlLWRldi5kZXZlbG9wbWVudC5lc20uanM/NGZkYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBGcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL2dsb2JhbFRoaXNcbmZ1bmN0aW9uIGdldEdsb2JhbCgpIHtcbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBnbG9iYWxUaGlzO1xuICB9XG4gIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG4gIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBnbG9iYWw7XG4gIH1cbiAge1xuICAgIGNvbnNvbGUud2FybignWFN0YXRlIGNvdWxkIG5vdCBmaW5kIGEgZ2xvYmFsIG9iamVjdCBpbiB0aGlzIGVudmlyb25tZW50LiBQbGVhc2UgbGV0IHRoZSBtYWludGFpbmVycyBrbm93IGFuZCByYWlzZSBhbiBpc3N1ZSBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vc3RhdGVseWFpL3hzdGF0ZS9pc3N1ZXMnKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0RGV2VG9vbHMoKSB7XG4gIGNvbnN0IHcgPSBnZXRHbG9iYWwoKTtcbiAgaWYgKCEhdy5fX3hzdGF0ZV9fKSB7XG4gICAgcmV0dXJuIHcuX194c3RhdGVfXztcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJTZXJ2aWNlKHNlcnZpY2UpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGRldlRvb2xzID0gZ2V0RGV2VG9vbHMoKTtcbiAgaWYgKGRldlRvb2xzKSB7XG4gICAgZGV2VG9vbHMucmVnaXN0ZXIoc2VydmljZSk7XG4gIH1cbn1cbmNvbnN0IGRldlRvb2xzQWRhcHRlciA9IHNlcnZpY2UgPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZGV2VG9vbHMgPSBnZXREZXZUb29scygpO1xuICBpZiAoZGV2VG9vbHMpIHtcbiAgICBkZXZUb29scy5yZWdpc3RlcihzZXJ2aWNlKTtcbiAgfVxufTtcblxuZXhwb3J0IHsgZGV2VG9vbHNBZGFwdGVyLCBnZXRHbG9iYWwsIHJlZ2lzdGVyU2VydmljZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/xstate/dev/dist/xstate-dev.development.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/xstate/dist/log-38475d87.development.esm.js":
/*!******************************************************************!*\
  !*** ./node_modules/xstate/dist/log-38475d87.development.esm.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   S: function() { return /* binding */ SpecialTargets; },\n/* harmony export */   a: function() { return /* binding */ assign; },\n/* harmony export */   b: function() { return /* binding */ enqueueActions; },\n/* harmony export */   c: function() { return /* binding */ sendTo; },\n/* harmony export */   e: function() { return /* binding */ emit; },\n/* harmony export */   f: function() { return /* binding */ forwardTo; },\n/* harmony export */   l: function() { return /* binding */ log; },\n/* harmony export */   s: function() { return /* binding */ sendParent; }\n/* harmony export */ });\n/* harmony import */ var _raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./raise-5ea71f04.development.esm.js */ \"(app-pages-browser)/./node_modules/xstate/dist/raise-5ea71f04.development.esm.js\");\n\n\nfunction createSpawner(actorScope, {\n  machine,\n  context\n}, event, spawnedChildren) {\n  const spawn = (src, options = {}) => {\n    const {\n      systemId,\n      input\n    } = options;\n    if (typeof src === 'string') {\n      const logic = (0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.z)(machine, src);\n      if (!logic) {\n        throw new Error(`Actor logic '${src}' not implemented in machine '${machine.id}'`);\n      }\n      const actorRef = (0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.A)(logic, {\n        id: options.id,\n        parent: actorScope.self,\n        syncSnapshot: options.syncSnapshot,\n        input: typeof input === 'function' ? input({\n          context,\n          event,\n          self: actorScope.self\n        }) : input,\n        src,\n        systemId\n      });\n      spawnedChildren[actorRef.id] = actorRef;\n      return actorRef;\n    } else {\n      const actorRef = (0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.A)(src, {\n        id: options.id,\n        parent: actorScope.self,\n        syncSnapshot: options.syncSnapshot,\n        input: options.input,\n        src,\n        systemId\n      });\n      return actorRef;\n    }\n  };\n  return (src, options) => {\n    const actorRef = spawn(src, options); // TODO: fix types\n    spawnedChildren[actorRef.id] = actorRef;\n    actorScope.defer(() => {\n      if (actorRef._processingStatus === _raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.T.Stopped) {\n        return;\n      }\n      actorRef.start();\n    });\n    return actorRef;\n  };\n}\n\nfunction resolveAssign(actorScope, snapshot, actionArgs, actionParams, {\n  assignment\n}) {\n  if (!snapshot.context) {\n    throw new Error('Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.');\n  }\n  const spawnedChildren = {};\n  const assignArgs = {\n    context: snapshot.context,\n    event: actionArgs.event,\n    spawn: createSpawner(actorScope, snapshot, actionArgs.event, spawnedChildren),\n    self: actorScope.self,\n    system: actorScope.system\n  };\n  let partialUpdate = {};\n  if (typeof assignment === 'function') {\n    partialUpdate = assignment(assignArgs, actionParams);\n  } else {\n    for (const key of Object.keys(assignment)) {\n      const propAssignment = assignment[key];\n      partialUpdate[key] = typeof propAssignment === 'function' ? propAssignment(assignArgs, actionParams) : propAssignment;\n    }\n  }\n  const updatedContext = Object.assign({}, snapshot.context, partialUpdate);\n  return [(0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.U)(snapshot, {\n    context: updatedContext,\n    children: Object.keys(spawnedChildren).length ? {\n      ...snapshot.children,\n      ...spawnedChildren\n    } : snapshot.children\n  })];\n}\n/**\n * Updates the current context of the machine.\n *\n * @example\n *\n * ```ts\n * import { createMachine, assign } from 'xstate';\n *\n * const countMachine = createMachine({\n *   context: {\n *     count: 0,\n *     message: ''\n *   },\n *   on: {\n *     inc: {\n *       actions: assign({\n *         count: ({ context }) => context.count + 1\n *       })\n *     },\n *     updateMessage: {\n *       actions: assign(({ context, event }) => {\n *         return {\n *           message: event.message.trim()\n *         };\n *       })\n *     }\n *   }\n * });\n * ```\n *\n * @param assignment An object that represents the partial context to update, or\n *   a function that returns an object that represents the partial context to\n *   update.\n */\nfunction assign(assignment) {\n  if (_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.V) {\n    console.warn('Custom actions should not call `assign()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.');\n  }\n  function assign(args, params) {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  assign.type = 'xstate.assign';\n  assign.assignment = assignment;\n  assign.resolve = resolveAssign;\n  return assign;\n}\n\nfunction resolveEmit(_, snapshot, args, actionParams, {\n  event: eventOrExpr\n}) {\n  if (typeof eventOrExpr === 'string') {\n    throw new Error(`Only event objects may be used with emit; use emit({ type: \"${eventOrExpr}\" }) instead`);\n  }\n  const resolvedEvent = typeof eventOrExpr === 'function' ? eventOrExpr(args, actionParams) : eventOrExpr;\n  return [snapshot, {\n    event: resolvedEvent\n  }];\n}\nfunction executeEmit(actorScope, {\n  event\n}) {\n  actorScope.defer(() => actorScope.emit(event));\n}\n/**\n * Emits an event to event handlers registered on the actor via `actor.on(event,\n * handler)`.\n *\n * @example\n *\n * ```ts\n * import { emit } from 'xstate';\n *\n * const machine = createMachine({\n *   // ...\n *   on: {\n *     something: {\n *       actions: emit({\n *         type: 'emitted',\n *         some: 'data'\n *       })\n *     }\n *   }\n *   // ...\n * });\n *\n * const actor = createActor(machine).start();\n *\n * actor.on('emitted', (event) => {\n *   console.log(event);\n * });\n *\n * actor.send({ type: 'something' });\n * // logs:\n * // {\n * //   type: 'emitted',\n * //   some: 'data'\n * // }\n * ```\n */\nfunction emit(/** The event to emit, or an expression that returns an event to emit. */\neventOrExpr) {\n  if (_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.V) {\n    console.warn('Custom actions should not call `emit()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.');\n  }\n  function emit(args, params) {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  emit.type = 'xstate.emit';\n  emit.event = eventOrExpr;\n  emit.resolve = resolveEmit;\n  emit.execute = executeEmit;\n  return emit;\n}\n\n/**\n * @remarks\n * `T | unknown` reduces to `unknown` and that can be problematic when it comes\n * to contextual typing. It especially is a problem when the union has a\n * function member, like here:\n *\n * ```ts\n * declare function test(\n *   cbOrVal: ((arg: number) => unknown) | unknown\n * ): void;\n * test((arg) => {}); // oops, implicit any\n * ```\n *\n * This type can be used to avoid this problem. This union represents the same\n * value space as `unknown`.\n */\n\n// https://github.com/microsoft/TypeScript/issues/23182#issuecomment-379091887\n\n// @TODO: Replace with native `NoInfer` when TS issue gets fixed:\n// https://github.com/microsoft/TypeScript/pull/57673\n\n/** @deprecated Use the built-in `NoInfer` type instead */\n\n/** The full definition of an event, with a string `type`. */\n\n/**\n * The string or object representing the state value relative to the parent\n * state node.\n *\n * @remarks\n * - For a child atomic state node, this is a string, e.g., `\"pending\"`.\n * - For complex state nodes, this is an object, e.g., `{ success:\n *   \"someChildState\" }`.\n */\n\n// TODO: remove once TS fixes this type-widening issue\n\n/** @deprecated Use `AnyMachineSnapshot` instead */\n\n// TODO: possibly refactor this somehow, use even a simpler type, and maybe even make `machine.options` private or something\n/** @ignore */\n\nlet SpecialTargets = /*#__PURE__*/function (SpecialTargets) {\n  SpecialTargets[\"Parent\"] = \"#_parent\";\n  SpecialTargets[\"Internal\"] = \"#_internal\";\n  return SpecialTargets;\n}({});\n\n/** @deprecated Use `AnyActor` instead. */\n\n// Based on RxJS types\n\n// TODO: in v6, this should only accept AnyActorLogic, like ActorRefFromLogic\n\n/** @deprecated Use `Actor<T>` instead. */\n\n/**\n * Represents logic which can be used by an actor.\n *\n * @template TSnapshot - The type of the snapshot.\n * @template TEvent - The type of the event object.\n * @template TInput - The type of the input.\n * @template TSystem - The type of the actor system.\n */\n\n/** @deprecated */\n\nfunction resolveSendTo(actorScope, snapshot, args, actionParams, {\n  to,\n  event: eventOrExpr,\n  id,\n  delay\n}, extra) {\n  const delaysMap = snapshot.machine.implementations.delays;\n  if (typeof eventOrExpr === 'string') {\n    throw new Error(`Only event objects may be used with sendTo; use sendTo({ type: \"${eventOrExpr}\" }) instead`);\n  }\n  const resolvedEvent = typeof eventOrExpr === 'function' ? eventOrExpr(args, actionParams) : eventOrExpr;\n  let resolvedDelay;\n  if (typeof delay === 'string') {\n    const configDelay = delaysMap && delaysMap[delay];\n    resolvedDelay = typeof configDelay === 'function' ? configDelay(args, actionParams) : configDelay;\n  } else {\n    resolvedDelay = typeof delay === 'function' ? delay(args, actionParams) : delay;\n  }\n  const resolvedTarget = typeof to === 'function' ? to(args, actionParams) : to;\n  let targetActorRef;\n  if (typeof resolvedTarget === 'string') {\n    if (resolvedTarget === SpecialTargets.Parent) {\n      targetActorRef = actorScope.self._parent;\n    } else if (resolvedTarget === SpecialTargets.Internal) {\n      targetActorRef = actorScope.self;\n    } else if (resolvedTarget.startsWith('#_')) {\n      // SCXML compatibility: https://www.w3.org/TR/scxml/#SCXMLEventProcessor\n      // #_invokeid. If the target is the special term '#_invokeid', where invokeid is the invokeid of an SCXML session that the sending session has created by <invoke>, the Processor must add the event to the external queue of that session.\n      targetActorRef = snapshot.children[resolvedTarget.slice(2)];\n    } else {\n      targetActorRef = extra.deferredActorIds?.includes(resolvedTarget) ? resolvedTarget : snapshot.children[resolvedTarget];\n    }\n    if (!targetActorRef) {\n      throw new Error(`Unable to send event to actor '${resolvedTarget}' from machine '${snapshot.machine.id}'.`);\n    }\n  } else {\n    targetActorRef = resolvedTarget || actorScope.self;\n  }\n  return [snapshot, {\n    to: targetActorRef,\n    event: resolvedEvent,\n    id,\n    delay: resolvedDelay\n  }];\n}\nfunction retryResolveSendTo(_, snapshot, params) {\n  if (typeof params.to === 'string') {\n    params.to = snapshot.children[params.to];\n  }\n}\nfunction executeSendTo(actorScope, params) {\n  // this forms an outgoing events queue\n  // thanks to that the recipient actors are able to read the *updated* snapshot value of the sender\n  actorScope.defer(() => {\n    const {\n      to,\n      event,\n      delay,\n      id\n    } = params;\n    if (typeof delay === 'number') {\n      actorScope.system.scheduler.schedule(actorScope.self, to, event, delay, id);\n      return;\n    }\n    actorScope.system._relay(actorScope.self,\n    // at this point, in a deferred task, it should already be mutated by retryResolveSendTo\n    // if it initially started as a string\n    to, event.type === _raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.W ? (0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.Y)(actorScope.self.id, event.data) : event);\n  });\n}\n/**\n * Sends an event to an actor.\n *\n * @param actor The `ActorRef` to send the event to.\n * @param event The event to send, or an expression that evaluates to the event\n *   to send\n * @param options Send action options\n *\n *   - `id` - The unique send event identifier (used with `cancel()`).\n *   - `delay` - The number of milliseconds to delay the sending of the event.\n */\nfunction sendTo(to, eventOrExpr, options) {\n  if (_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.V) {\n    console.warn('Custom actions should not call `raise()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.');\n  }\n  function sendTo(args, params) {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  sendTo.type = 'xsnapshot.sendTo';\n  sendTo.to = to;\n  sendTo.event = eventOrExpr;\n  sendTo.id = options?.id;\n  sendTo.delay = options?.delay;\n  sendTo.resolve = resolveSendTo;\n  sendTo.retryResolve = retryResolveSendTo;\n  sendTo.execute = executeSendTo;\n  return sendTo;\n}\n\n/**\n * Sends an event to this machine's parent.\n *\n * @param event The event to send to the parent machine.\n * @param options Options to pass into the send event.\n */\nfunction sendParent(event, options) {\n  return sendTo(SpecialTargets.Parent, event, options);\n}\n/**\n * Forwards (sends) an event to the `target` actor.\n *\n * @param target The target actor to forward the event to.\n * @param options Options to pass into the send action creator.\n */\nfunction forwardTo(target, options) {\n  if ((!target || typeof target === 'function')) {\n    const originalTarget = target;\n    target = (...args) => {\n      const resolvedTarget = typeof originalTarget === 'function' ? originalTarget(...args) : originalTarget;\n      if (!resolvedTarget) {\n        throw new Error(`Attempted to forward event to undefined actor. This risks an infinite loop in the sender.`);\n      }\n      return resolvedTarget;\n    };\n  }\n  return sendTo(target, ({\n    event\n  }) => event, options);\n}\n\nfunction resolveEnqueueActions(actorScope, snapshot, args, actionParams, {\n  collect\n}) {\n  const actions = [];\n  const enqueue = function enqueue(action) {\n    actions.push(action);\n  };\n  enqueue.assign = (...args) => {\n    actions.push(assign(...args));\n  };\n  enqueue.cancel = (...args) => {\n    actions.push((0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.M)(...args));\n  };\n  enqueue.raise = (...args) => {\n    // for some reason it fails to infer `TDelay` from `...args` here and picks its default (`never`)\n    // then it fails to typecheck that because `...args` use `string` in place of `TDelay`\n    actions.push((0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.O)(...args));\n  };\n  enqueue.sendTo = (...args) => {\n    // for some reason it fails to infer `TDelay` from `...args` here and picks its default (`never`)\n    // then it fails to typecheck that because `...args` use `string` in place of `TDelay\n    actions.push(sendTo(...args));\n  };\n  enqueue.sendParent = (...args) => {\n    actions.push(sendParent(...args));\n  };\n  enqueue.spawnChild = (...args) => {\n    actions.push((0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.P)(...args));\n  };\n  enqueue.stopChild = (...args) => {\n    actions.push((0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.R)(...args));\n  };\n  enqueue.emit = (...args) => {\n    actions.push(emit(...args));\n  };\n  collect({\n    context: args.context,\n    event: args.event,\n    enqueue,\n    check: guard => (0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.e)(guard, snapshot.context, args.event, snapshot),\n    self: actorScope.self,\n    system: actorScope.system\n  }, actionParams);\n  return [snapshot, undefined, actions];\n}\n/**\n * Creates an action object that will execute actions that are queued by the\n * `enqueue(action)` function.\n *\n * @example\n *\n * ```ts\n * import { createMachine, enqueueActions } from 'xstate';\n *\n * const machine = createMachine({\n *   entry: enqueueActions(({ enqueue, check }) => {\n *     enqueue.assign({ count: 0 });\n *\n *     if (check('someGuard')) {\n *       enqueue.assign({ count: 1 });\n *     }\n *\n *     enqueue('someAction');\n *   })\n * });\n * ```\n */\nfunction enqueueActions(collect) {\n  function enqueueActions(args, params) {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  enqueueActions.type = 'xstate.enqueueActions';\n  enqueueActions.collect = collect;\n  enqueueActions.resolve = resolveEnqueueActions;\n  return enqueueActions;\n}\n\nfunction resolveLog(_, snapshot, actionArgs, actionParams, {\n  value,\n  label\n}) {\n  return [snapshot, {\n    value: typeof value === 'function' ? value(actionArgs, actionParams) : value,\n    label\n  }];\n}\nfunction executeLog({\n  logger\n}, {\n  value,\n  label\n}) {\n  if (label) {\n    logger(label, value);\n  } else {\n    logger(value);\n  }\n}\n/**\n * @param expr The expression function to evaluate which will be logged. Takes\n *   in 2 arguments:\n *\n *   - `ctx` - the current state context\n *   - `event` - the event that caused this action to be executed.\n *\n * @param label The label to give to the logged expression.\n */\nfunction log(value = ({\n  context,\n  event\n}) => ({\n  context,\n  event\n}), label) {\n  function log(args, params) {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  log.type = 'xstate.log';\n  log.value = value;\n  log.label = label;\n  log.resolve = resolveLog;\n  log.execute = executeLog;\n  return log;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy94c3RhdGUvZGlzdC9sb2ctMzg0NzVkODcuZGV2ZWxvcG1lbnQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUErUzs7QUFFL1M7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxvQkFBb0IscUVBQXNCO0FBQzFDO0FBQ0Esd0NBQXdDLElBQUksZ0NBQWdDLFdBQVc7QUFDdkY7QUFDQSx1QkFBdUIscUVBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsTUFBTTtBQUNOLHVCQUF1QixxRUFBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLHlDQUF5QyxpRUFBZ0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QyxVQUFVLHFFQUFvQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdCQUF3QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCLFVBQVU7QUFDVixRQUFRO0FBQ1I7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7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QSxpQkFBaUIscUVBQUs7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscUVBQVU7QUFDM0I7QUFDQTtBQUNBLGlCQUFpQixxRUFBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFFQUFhO0FBQ2pDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQ0FBZ0M7QUFDNUM7QUFDQTtBQUNBLDhCQUE4QixnQkFBZ0I7QUFDOUMsd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFb0kiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3hzdGF0ZS9kaXN0L2xvZy0zODQ3NWQ4Ny5kZXZlbG9wbWVudC5lc20uanM/NWU1YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUIGFzIFByb2Nlc3NpbmdTdGF0dXMsIHogYXMgcmVzb2x2ZVJlZmVyZW5jZWRBY3RvciwgQSBhcyBjcmVhdGVBY3RvciwgVSBhcyBjbG9uZU1hY2hpbmVTbmFwc2hvdCwgViBhcyBleGVjdXRpbmdDdXN0b21BY3Rpb24sIFcgYXMgWFNUQVRFX0VSUk9SLCBZIGFzIGNyZWF0ZUVycm9yQWN0b3JFdmVudCwgZSBhcyBldmFsdWF0ZUd1YXJkLCBNIGFzIGNhbmNlbCwgTyBhcyByYWlzZSwgUCBhcyBzcGF3bkNoaWxkLCBSIGFzIHN0b3BDaGlsZCB9IGZyb20gJy4vcmFpc2UtNWVhNzFmMDQuZGV2ZWxvcG1lbnQuZXNtLmpzJztcblxuZnVuY3Rpb24gY3JlYXRlU3Bhd25lcihhY3RvclNjb3BlLCB7XG4gIG1hY2hpbmUsXG4gIGNvbnRleHRcbn0sIGV2ZW50LCBzcGF3bmVkQ2hpbGRyZW4pIHtcbiAgY29uc3Qgc3Bhd24gPSAoc3JjLCBvcHRpb25zID0ge30pID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBzeXN0ZW1JZCxcbiAgICAgIGlucHV0XG4gICAgfSA9IG9wdGlvbnM7XG4gICAgaWYgKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBsb2dpYyA9IHJlc29sdmVSZWZlcmVuY2VkQWN0b3IobWFjaGluZSwgc3JjKTtcbiAgICAgIGlmICghbG9naWMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBY3RvciBsb2dpYyAnJHtzcmN9JyBub3QgaW1wbGVtZW50ZWQgaW4gbWFjaGluZSAnJHttYWNoaW5lLmlkfSdgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFjdG9yUmVmID0gY3JlYXRlQWN0b3IobG9naWMsIHtcbiAgICAgICAgaWQ6IG9wdGlvbnMuaWQsXG4gICAgICAgIHBhcmVudDogYWN0b3JTY29wZS5zZWxmLFxuICAgICAgICBzeW5jU25hcHNob3Q6IG9wdGlvbnMuc3luY1NuYXBzaG90LFxuICAgICAgICBpbnB1dDogdHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nID8gaW5wdXQoe1xuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgc2VsZjogYWN0b3JTY29wZS5zZWxmXG4gICAgICAgIH0pIDogaW5wdXQsXG4gICAgICAgIHNyYyxcbiAgICAgICAgc3lzdGVtSWRcbiAgICAgIH0pO1xuICAgICAgc3Bhd25lZENoaWxkcmVuW2FjdG9yUmVmLmlkXSA9IGFjdG9yUmVmO1xuICAgICAgcmV0dXJuIGFjdG9yUmVmO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBhY3RvclJlZiA9IGNyZWF0ZUFjdG9yKHNyYywge1xuICAgICAgICBpZDogb3B0aW9ucy5pZCxcbiAgICAgICAgcGFyZW50OiBhY3RvclNjb3BlLnNlbGYsXG4gICAgICAgIHN5bmNTbmFwc2hvdDogb3B0aW9ucy5zeW5jU25hcHNob3QsXG4gICAgICAgIGlucHV0OiBvcHRpb25zLmlucHV0LFxuICAgICAgICBzcmMsXG4gICAgICAgIHN5c3RlbUlkXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY3RvclJlZjtcbiAgICB9XG4gIH07XG4gIHJldHVybiAoc3JjLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgYWN0b3JSZWYgPSBzcGF3bihzcmMsIG9wdGlvbnMpOyAvLyBUT0RPOiBmaXggdHlwZXNcbiAgICBzcGF3bmVkQ2hpbGRyZW5bYWN0b3JSZWYuaWRdID0gYWN0b3JSZWY7XG4gICAgYWN0b3JTY29wZS5kZWZlcigoKSA9PiB7XG4gICAgICBpZiAoYWN0b3JSZWYuX3Byb2Nlc3NpbmdTdGF0dXMgPT09IFByb2Nlc3NpbmdTdGF0dXMuU3RvcHBlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhY3RvclJlZi5zdGFydCgpO1xuICAgIH0pO1xuICAgIHJldHVybiBhY3RvclJlZjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUFzc2lnbihhY3RvclNjb3BlLCBzbmFwc2hvdCwgYWN0aW9uQXJncywgYWN0aW9uUGFyYW1zLCB7XG4gIGFzc2lnbm1lbnRcbn0pIHtcbiAgaWYgKCFzbmFwc2hvdC5jb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYXNzaWduIHRvIHVuZGVmaW5lZCBgY29udGV4dGAuIEVuc3VyZSB0aGF0IGBjb250ZXh0YCBpcyBkZWZpbmVkIGluIHRoZSBtYWNoaW5lIGNvbmZpZy4nKTtcbiAgfVxuICBjb25zdCBzcGF3bmVkQ2hpbGRyZW4gPSB7fTtcbiAgY29uc3QgYXNzaWduQXJncyA9IHtcbiAgICBjb250ZXh0OiBzbmFwc2hvdC5jb250ZXh0LFxuICAgIGV2ZW50OiBhY3Rpb25BcmdzLmV2ZW50LFxuICAgIHNwYXduOiBjcmVhdGVTcGF3bmVyKGFjdG9yU2NvcGUsIHNuYXBzaG90LCBhY3Rpb25BcmdzLmV2ZW50LCBzcGF3bmVkQ2hpbGRyZW4pLFxuICAgIHNlbGY6IGFjdG9yU2NvcGUuc2VsZixcbiAgICBzeXN0ZW06IGFjdG9yU2NvcGUuc3lzdGVtXG4gIH07XG4gIGxldCBwYXJ0aWFsVXBkYXRlID0ge307XG4gIGlmICh0eXBlb2YgYXNzaWdubWVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHBhcnRpYWxVcGRhdGUgPSBhc3NpZ25tZW50KGFzc2lnbkFyZ3MsIGFjdGlvblBhcmFtcyk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoYXNzaWdubWVudCkpIHtcbiAgICAgIGNvbnN0IHByb3BBc3NpZ25tZW50ID0gYXNzaWdubWVudFtrZXldO1xuICAgICAgcGFydGlhbFVwZGF0ZVtrZXldID0gdHlwZW9mIHByb3BBc3NpZ25tZW50ID09PSAnZnVuY3Rpb24nID8gcHJvcEFzc2lnbm1lbnQoYXNzaWduQXJncywgYWN0aW9uUGFyYW1zKSA6IHByb3BBc3NpZ25tZW50O1xuICAgIH1cbiAgfVxuICBjb25zdCB1cGRhdGVkQ29udGV4dCA9IE9iamVjdC5hc3NpZ24oe30sIHNuYXBzaG90LmNvbnRleHQsIHBhcnRpYWxVcGRhdGUpO1xuICByZXR1cm4gW2Nsb25lTWFjaGluZVNuYXBzaG90KHNuYXBzaG90LCB7XG4gICAgY29udGV4dDogdXBkYXRlZENvbnRleHQsXG4gICAgY2hpbGRyZW46IE9iamVjdC5rZXlzKHNwYXduZWRDaGlsZHJlbikubGVuZ3RoID8ge1xuICAgICAgLi4uc25hcHNob3QuY2hpbGRyZW4sXG4gICAgICAuLi5zcGF3bmVkQ2hpbGRyZW5cbiAgICB9IDogc25hcHNob3QuY2hpbGRyZW5cbiAgfSldO1xufVxuLyoqXG4gKiBVcGRhdGVzIHRoZSBjdXJyZW50IGNvbnRleHQgb2YgdGhlIG1hY2hpbmUuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgY3JlYXRlTWFjaGluZSwgYXNzaWduIH0gZnJvbSAneHN0YXRlJztcbiAqXG4gKiBjb25zdCBjb3VudE1hY2hpbmUgPSBjcmVhdGVNYWNoaW5lKHtcbiAqICAgY29udGV4dDoge1xuICogICAgIGNvdW50OiAwLFxuICogICAgIG1lc3NhZ2U6ICcnXG4gKiAgIH0sXG4gKiAgIG9uOiB7XG4gKiAgICAgaW5jOiB7XG4gKiAgICAgICBhY3Rpb25zOiBhc3NpZ24oe1xuICogICAgICAgICBjb3VudDogKHsgY29udGV4dCB9KSA9PiBjb250ZXh0LmNvdW50ICsgMVxuICogICAgICAgfSlcbiAqICAgICB9LFxuICogICAgIHVwZGF0ZU1lc3NhZ2U6IHtcbiAqICAgICAgIGFjdGlvbnM6IGFzc2lnbigoeyBjb250ZXh0LCBldmVudCB9KSA9PiB7XG4gKiAgICAgICAgIHJldHVybiB7XG4gKiAgICAgICAgICAgbWVzc2FnZTogZXZlbnQubWVzc2FnZS50cmltKClcbiAqICAgICAgICAgfTtcbiAqICAgICAgIH0pXG4gKiAgICAgfVxuICogICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhc3NpZ25tZW50IEFuIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHBhcnRpYWwgY29udGV4dCB0byB1cGRhdGUsIG9yXG4gKiAgIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHBhcnRpYWwgY29udGV4dCB0b1xuICogICB1cGRhdGUuXG4gKi9cbmZ1bmN0aW9uIGFzc2lnbihhc3NpZ25tZW50KSB7XG4gIGlmIChleGVjdXRpbmdDdXN0b21BY3Rpb24pIHtcbiAgICBjb25zb2xlLndhcm4oJ0N1c3RvbSBhY3Rpb25zIHNob3VsZCBub3QgY2FsbCBgYXNzaWduKClgIGRpcmVjdGx5LCBhcyBpdCBpcyBub3QgaW1wZXJhdGl2ZS4gU2VlIGh0dHBzOi8vc3RhdGVseS5haS9kb2NzL2FjdGlvbnMjYnVpbHQtaW4tYWN0aW9ucyBmb3IgbW9yZSBkZXRhaWxzLicpO1xuICB9XG4gIGZ1bmN0aW9uIGFzc2lnbihhcmdzLCBwYXJhbXMpIHtcbiAgICB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgaXNuJ3Qgc3VwcG9zZWQgdG8gYmUgY2FsbGVkYCk7XG4gICAgfVxuICB9XG4gIGFzc2lnbi50eXBlID0gJ3hzdGF0ZS5hc3NpZ24nO1xuICBhc3NpZ24uYXNzaWdubWVudCA9IGFzc2lnbm1lbnQ7XG4gIGFzc2lnbi5yZXNvbHZlID0gcmVzb2x2ZUFzc2lnbjtcbiAgcmV0dXJuIGFzc2lnbjtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUVtaXQoXywgc25hcHNob3QsIGFyZ3MsIGFjdGlvblBhcmFtcywge1xuICBldmVudDogZXZlbnRPckV4cHJcbn0pIHtcbiAgaWYgKHR5cGVvZiBldmVudE9yRXhwciA9PT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE9ubHkgZXZlbnQgb2JqZWN0cyBtYXkgYmUgdXNlZCB3aXRoIGVtaXQ7IHVzZSBlbWl0KHsgdHlwZTogXCIke2V2ZW50T3JFeHByfVwiIH0pIGluc3RlYWRgKTtcbiAgfVxuICBjb25zdCByZXNvbHZlZEV2ZW50ID0gdHlwZW9mIGV2ZW50T3JFeHByID09PSAnZnVuY3Rpb24nID8gZXZlbnRPckV4cHIoYXJncywgYWN0aW9uUGFyYW1zKSA6IGV2ZW50T3JFeHByO1xuICByZXR1cm4gW3NuYXBzaG90LCB7XG4gICAgZXZlbnQ6IHJlc29sdmVkRXZlbnRcbiAgfV07XG59XG5mdW5jdGlvbiBleGVjdXRlRW1pdChhY3RvclNjb3BlLCB7XG4gIGV2ZW50XG59KSB7XG4gIGFjdG9yU2NvcGUuZGVmZXIoKCkgPT4gYWN0b3JTY29wZS5lbWl0KGV2ZW50KSk7XG59XG4vKipcbiAqIEVtaXRzIGFuIGV2ZW50IHRvIGV2ZW50IGhhbmRsZXJzIHJlZ2lzdGVyZWQgb24gdGhlIGFjdG9yIHZpYSBgYWN0b3Iub24oZXZlbnQsXG4gKiBoYW5kbGVyKWAuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgZW1pdCB9IGZyb20gJ3hzdGF0ZSc7XG4gKlxuICogY29uc3QgbWFjaGluZSA9IGNyZWF0ZU1hY2hpbmUoe1xuICogICAvLyAuLi5cbiAqICAgb246IHtcbiAqICAgICBzb21ldGhpbmc6IHtcbiAqICAgICAgIGFjdGlvbnM6IGVtaXQoe1xuICogICAgICAgICB0eXBlOiAnZW1pdHRlZCcsXG4gKiAgICAgICAgIHNvbWU6ICdkYXRhJ1xuICogICAgICAgfSlcbiAqICAgICB9XG4gKiAgIH1cbiAqICAgLy8gLi4uXG4gKiB9KTtcbiAqXG4gKiBjb25zdCBhY3RvciA9IGNyZWF0ZUFjdG9yKG1hY2hpbmUpLnN0YXJ0KCk7XG4gKlxuICogYWN0b3Iub24oJ2VtaXR0ZWQnLCAoZXZlbnQpID0+IHtcbiAqICAgY29uc29sZS5sb2coZXZlbnQpO1xuICogfSk7XG4gKlxuICogYWN0b3Iuc2VuZCh7IHR5cGU6ICdzb21ldGhpbmcnIH0pO1xuICogLy8gbG9nczpcbiAqIC8vIHtcbiAqIC8vICAgdHlwZTogJ2VtaXR0ZWQnLFxuICogLy8gICBzb21lOiAnZGF0YSdcbiAqIC8vIH1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiBlbWl0KC8qKiBUaGUgZXZlbnQgdG8gZW1pdCwgb3IgYW4gZXhwcmVzc2lvbiB0aGF0IHJldHVybnMgYW4gZXZlbnQgdG8gZW1pdC4gKi9cbmV2ZW50T3JFeHByKSB7XG4gIGlmIChleGVjdXRpbmdDdXN0b21BY3Rpb24pIHtcbiAgICBjb25zb2xlLndhcm4oJ0N1c3RvbSBhY3Rpb25zIHNob3VsZCBub3QgY2FsbCBgZW1pdCgpYCBkaXJlY3RseSwgYXMgaXQgaXMgbm90IGltcGVyYXRpdmUuIFNlZSBodHRwczovL3N0YXRlbHkuYWkvZG9jcy9hY3Rpb25zI2J1aWx0LWluLWFjdGlvbnMgZm9yIG1vcmUgZGV0YWlscy4nKTtcbiAgfVxuICBmdW5jdGlvbiBlbWl0KGFyZ3MsIHBhcmFtcykge1xuICAgIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhpcyBpc24ndCBzdXBwb3NlZCB0byBiZSBjYWxsZWRgKTtcbiAgICB9XG4gIH1cbiAgZW1pdC50eXBlID0gJ3hzdGF0ZS5lbWl0JztcbiAgZW1pdC5ldmVudCA9IGV2ZW50T3JFeHByO1xuICBlbWl0LnJlc29sdmUgPSByZXNvbHZlRW1pdDtcbiAgZW1pdC5leGVjdXRlID0gZXhlY3V0ZUVtaXQ7XG4gIHJldHVybiBlbWl0O1xufVxuXG4vKipcbiAqIEByZW1hcmtzXG4gKiBgVCB8IHVua25vd25gIHJlZHVjZXMgdG8gYHVua25vd25gIGFuZCB0aGF0IGNhbiBiZSBwcm9ibGVtYXRpYyB3aGVuIGl0IGNvbWVzXG4gKiB0byBjb250ZXh0dWFsIHR5cGluZy4gSXQgZXNwZWNpYWxseSBpcyBhIHByb2JsZW0gd2hlbiB0aGUgdW5pb24gaGFzIGFcbiAqIGZ1bmN0aW9uIG1lbWJlciwgbGlrZSBoZXJlOlxuICpcbiAqIGBgYHRzXG4gKiBkZWNsYXJlIGZ1bmN0aW9uIHRlc3QoXG4gKiAgIGNiT3JWYWw6ICgoYXJnOiBudW1iZXIpID0+IHVua25vd24pIHwgdW5rbm93blxuICogKTogdm9pZDtcbiAqIHRlc3QoKGFyZykgPT4ge30pOyAvLyBvb3BzLCBpbXBsaWNpdCBhbnlcbiAqIGBgYFxuICpcbiAqIFRoaXMgdHlwZSBjYW4gYmUgdXNlZCB0byBhdm9pZCB0aGlzIHByb2JsZW0uIFRoaXMgdW5pb24gcmVwcmVzZW50cyB0aGUgc2FtZVxuICogdmFsdWUgc3BhY2UgYXMgYHVua25vd25gLlxuICovXG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMjMxODIjaXNzdWVjb21tZW50LTM3OTA5MTg4N1xuXG4vLyBAVE9ETzogUmVwbGFjZSB3aXRoIG5hdGl2ZSBgTm9JbmZlcmAgd2hlbiBUUyBpc3N1ZSBnZXRzIGZpeGVkOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L3B1bGwvNTc2NzNcblxuLyoqIEBkZXByZWNhdGVkIFVzZSB0aGUgYnVpbHQtaW4gYE5vSW5mZXJgIHR5cGUgaW5zdGVhZCAqL1xuXG4vKiogVGhlIGZ1bGwgZGVmaW5pdGlvbiBvZiBhbiBldmVudCwgd2l0aCBhIHN0cmluZyBgdHlwZWAuICovXG5cbi8qKlxuICogVGhlIHN0cmluZyBvciBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzdGF0ZSB2YWx1ZSByZWxhdGl2ZSB0byB0aGUgcGFyZW50XG4gKiBzdGF0ZSBub2RlLlxuICpcbiAqIEByZW1hcmtzXG4gKiAtIEZvciBhIGNoaWxkIGF0b21pYyBzdGF0ZSBub2RlLCB0aGlzIGlzIGEgc3RyaW5nLCBlLmcuLCBgXCJwZW5kaW5nXCJgLlxuICogLSBGb3IgY29tcGxleCBzdGF0ZSBub2RlcywgdGhpcyBpcyBhbiBvYmplY3QsIGUuZy4sIGB7IHN1Y2Nlc3M6XG4gKiAgIFwic29tZUNoaWxkU3RhdGVcIiB9YC5cbiAqL1xuXG4vLyBUT0RPOiByZW1vdmUgb25jZSBUUyBmaXhlcyB0aGlzIHR5cGUtd2lkZW5pbmcgaXNzdWVcblxuLyoqIEBkZXByZWNhdGVkIFVzZSBgQW55TWFjaGluZVNuYXBzaG90YCBpbnN0ZWFkICovXG5cbi8vIFRPRE86IHBvc3NpYmx5IHJlZmFjdG9yIHRoaXMgc29tZWhvdywgdXNlIGV2ZW4gYSBzaW1wbGVyIHR5cGUsIGFuZCBtYXliZSBldmVuIG1ha2UgYG1hY2hpbmUub3B0aW9uc2AgcHJpdmF0ZSBvciBzb21ldGhpbmdcbi8qKiBAaWdub3JlICovXG5cbmxldCBTcGVjaWFsVGFyZ2V0cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoU3BlY2lhbFRhcmdldHMpIHtcbiAgU3BlY2lhbFRhcmdldHNbXCJQYXJlbnRcIl0gPSBcIiNfcGFyZW50XCI7XG4gIFNwZWNpYWxUYXJnZXRzW1wiSW50ZXJuYWxcIl0gPSBcIiNfaW50ZXJuYWxcIjtcbiAgcmV0dXJuIFNwZWNpYWxUYXJnZXRzO1xufSh7fSk7XG5cbi8qKiBAZGVwcmVjYXRlZCBVc2UgYEFueUFjdG9yYCBpbnN0ZWFkLiAqL1xuXG4vLyBCYXNlZCBvbiBSeEpTIHR5cGVzXG5cbi8vIFRPRE86IGluIHY2LCB0aGlzIHNob3VsZCBvbmx5IGFjY2VwdCBBbnlBY3RvckxvZ2ljLCBsaWtlIEFjdG9yUmVmRnJvbUxvZ2ljXG5cbi8qKiBAZGVwcmVjYXRlZCBVc2UgYEFjdG9yPFQ+YCBpbnN0ZWFkLiAqL1xuXG4vKipcbiAqIFJlcHJlc2VudHMgbG9naWMgd2hpY2ggY2FuIGJlIHVzZWQgYnkgYW4gYWN0b3IuXG4gKlxuICogQHRlbXBsYXRlIFRTbmFwc2hvdCAtIFRoZSB0eXBlIG9mIHRoZSBzbmFwc2hvdC5cbiAqIEB0ZW1wbGF0ZSBURXZlbnQgLSBUaGUgdHlwZSBvZiB0aGUgZXZlbnQgb2JqZWN0LlxuICogQHRlbXBsYXRlIFRJbnB1dCAtIFRoZSB0eXBlIG9mIHRoZSBpbnB1dC5cbiAqIEB0ZW1wbGF0ZSBUU3lzdGVtIC0gVGhlIHR5cGUgb2YgdGhlIGFjdG9yIHN5c3RlbS5cbiAqL1xuXG4vKiogQGRlcHJlY2F0ZWQgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVNlbmRUbyhhY3RvclNjb3BlLCBzbmFwc2hvdCwgYXJncywgYWN0aW9uUGFyYW1zLCB7XG4gIHRvLFxuICBldmVudDogZXZlbnRPckV4cHIsXG4gIGlkLFxuICBkZWxheVxufSwgZXh0cmEpIHtcbiAgY29uc3QgZGVsYXlzTWFwID0gc25hcHNob3QubWFjaGluZS5pbXBsZW1lbnRhdGlvbnMuZGVsYXlzO1xuICBpZiAodHlwZW9mIGV2ZW50T3JFeHByID09PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcihgT25seSBldmVudCBvYmplY3RzIG1heSBiZSB1c2VkIHdpdGggc2VuZFRvOyB1c2Ugc2VuZFRvKHsgdHlwZTogXCIke2V2ZW50T3JFeHByfVwiIH0pIGluc3RlYWRgKTtcbiAgfVxuICBjb25zdCByZXNvbHZlZEV2ZW50ID0gdHlwZW9mIGV2ZW50T3JFeHByID09PSAnZnVuY3Rpb24nID8gZXZlbnRPckV4cHIoYXJncywgYWN0aW9uUGFyYW1zKSA6IGV2ZW50T3JFeHByO1xuICBsZXQgcmVzb2x2ZWREZWxheTtcbiAgaWYgKHR5cGVvZiBkZWxheSA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBjb25maWdEZWxheSA9IGRlbGF5c01hcCAmJiBkZWxheXNNYXBbZGVsYXldO1xuICAgIHJlc29sdmVkRGVsYXkgPSB0eXBlb2YgY29uZmlnRGVsYXkgPT09ICdmdW5jdGlvbicgPyBjb25maWdEZWxheShhcmdzLCBhY3Rpb25QYXJhbXMpIDogY29uZmlnRGVsYXk7XG4gIH0gZWxzZSB7XG4gICAgcmVzb2x2ZWREZWxheSA9IHR5cGVvZiBkZWxheSA9PT0gJ2Z1bmN0aW9uJyA/IGRlbGF5KGFyZ3MsIGFjdGlvblBhcmFtcykgOiBkZWxheTtcbiAgfVxuICBjb25zdCByZXNvbHZlZFRhcmdldCA9IHR5cGVvZiB0byA9PT0gJ2Z1bmN0aW9uJyA/IHRvKGFyZ3MsIGFjdGlvblBhcmFtcykgOiB0bztcbiAgbGV0IHRhcmdldEFjdG9yUmVmO1xuICBpZiAodHlwZW9mIHJlc29sdmVkVGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgIGlmIChyZXNvbHZlZFRhcmdldCA9PT0gU3BlY2lhbFRhcmdldHMuUGFyZW50KSB7XG4gICAgICB0YXJnZXRBY3RvclJlZiA9IGFjdG9yU2NvcGUuc2VsZi5fcGFyZW50O1xuICAgIH0gZWxzZSBpZiAocmVzb2x2ZWRUYXJnZXQgPT09IFNwZWNpYWxUYXJnZXRzLkludGVybmFsKSB7XG4gICAgICB0YXJnZXRBY3RvclJlZiA9IGFjdG9yU2NvcGUuc2VsZjtcbiAgICB9IGVsc2UgaWYgKHJlc29sdmVkVGFyZ2V0LnN0YXJ0c1dpdGgoJyNfJykpIHtcbiAgICAgIC8vIFNDWE1MIGNvbXBhdGliaWxpdHk6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9zY3htbC8jU0NYTUxFdmVudFByb2Nlc3NvclxuICAgICAgLy8gI19pbnZva2VpZC4gSWYgdGhlIHRhcmdldCBpcyB0aGUgc3BlY2lhbCB0ZXJtICcjX2ludm9rZWlkJywgd2hlcmUgaW52b2tlaWQgaXMgdGhlIGludm9rZWlkIG9mIGFuIFNDWE1MIHNlc3Npb24gdGhhdCB0aGUgc2VuZGluZyBzZXNzaW9uIGhhcyBjcmVhdGVkIGJ5IDxpbnZva2U+LCB0aGUgUHJvY2Vzc29yIG11c3QgYWRkIHRoZSBldmVudCB0byB0aGUgZXh0ZXJuYWwgcXVldWUgb2YgdGhhdCBzZXNzaW9uLlxuICAgICAgdGFyZ2V0QWN0b3JSZWYgPSBzbmFwc2hvdC5jaGlsZHJlbltyZXNvbHZlZFRhcmdldC5zbGljZSgyKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldEFjdG9yUmVmID0gZXh0cmEuZGVmZXJyZWRBY3Rvcklkcz8uaW5jbHVkZXMocmVzb2x2ZWRUYXJnZXQpID8gcmVzb2x2ZWRUYXJnZXQgOiBzbmFwc2hvdC5jaGlsZHJlbltyZXNvbHZlZFRhcmdldF07XG4gICAgfVxuICAgIGlmICghdGFyZ2V0QWN0b3JSZWYpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHNlbmQgZXZlbnQgdG8gYWN0b3IgJyR7cmVzb2x2ZWRUYXJnZXR9JyBmcm9tIG1hY2hpbmUgJyR7c25hcHNob3QubWFjaGluZS5pZH0nLmApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0YXJnZXRBY3RvclJlZiA9IHJlc29sdmVkVGFyZ2V0IHx8IGFjdG9yU2NvcGUuc2VsZjtcbiAgfVxuICByZXR1cm4gW3NuYXBzaG90LCB7XG4gICAgdG86IHRhcmdldEFjdG9yUmVmLFxuICAgIGV2ZW50OiByZXNvbHZlZEV2ZW50LFxuICAgIGlkLFxuICAgIGRlbGF5OiByZXNvbHZlZERlbGF5XG4gIH1dO1xufVxuZnVuY3Rpb24gcmV0cnlSZXNvbHZlU2VuZFRvKF8sIHNuYXBzaG90LCBwYXJhbXMpIHtcbiAgaWYgKHR5cGVvZiBwYXJhbXMudG8gPT09ICdzdHJpbmcnKSB7XG4gICAgcGFyYW1zLnRvID0gc25hcHNob3QuY2hpbGRyZW5bcGFyYW1zLnRvXTtcbiAgfVxufVxuZnVuY3Rpb24gZXhlY3V0ZVNlbmRUbyhhY3RvclNjb3BlLCBwYXJhbXMpIHtcbiAgLy8gdGhpcyBmb3JtcyBhbiBvdXRnb2luZyBldmVudHMgcXVldWVcbiAgLy8gdGhhbmtzIHRvIHRoYXQgdGhlIHJlY2lwaWVudCBhY3RvcnMgYXJlIGFibGUgdG8gcmVhZCB0aGUgKnVwZGF0ZWQqIHNuYXBzaG90IHZhbHVlIG9mIHRoZSBzZW5kZXJcbiAgYWN0b3JTY29wZS5kZWZlcigoKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgdG8sXG4gICAgICBldmVudCxcbiAgICAgIGRlbGF5LFxuICAgICAgaWRcbiAgICB9ID0gcGFyYW1zO1xuICAgIGlmICh0eXBlb2YgZGVsYXkgPT09ICdudW1iZXInKSB7XG4gICAgICBhY3RvclNjb3BlLnN5c3RlbS5zY2hlZHVsZXIuc2NoZWR1bGUoYWN0b3JTY29wZS5zZWxmLCB0bywgZXZlbnQsIGRlbGF5LCBpZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFjdG9yU2NvcGUuc3lzdGVtLl9yZWxheShhY3RvclNjb3BlLnNlbGYsXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgaW4gYSBkZWZlcnJlZCB0YXNrLCBpdCBzaG91bGQgYWxyZWFkeSBiZSBtdXRhdGVkIGJ5IHJldHJ5UmVzb2x2ZVNlbmRUb1xuICAgIC8vIGlmIGl0IGluaXRpYWxseSBzdGFydGVkIGFzIGEgc3RyaW5nXG4gICAgdG8sIGV2ZW50LnR5cGUgPT09IFhTVEFURV9FUlJPUiA/IGNyZWF0ZUVycm9yQWN0b3JFdmVudChhY3RvclNjb3BlLnNlbGYuaWQsIGV2ZW50LmRhdGEpIDogZXZlbnQpO1xuICB9KTtcbn1cbi8qKlxuICogU2VuZHMgYW4gZXZlbnQgdG8gYW4gYWN0b3IuXG4gKlxuICogQHBhcmFtIGFjdG9yIFRoZSBgQWN0b3JSZWZgIHRvIHNlbmQgdGhlIGV2ZW50IHRvLlxuICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCB0byBzZW5kLCBvciBhbiBleHByZXNzaW9uIHRoYXQgZXZhbHVhdGVzIHRvIHRoZSBldmVudFxuICogICB0byBzZW5kXG4gKiBAcGFyYW0gb3B0aW9ucyBTZW5kIGFjdGlvbiBvcHRpb25zXG4gKlxuICogICAtIGBpZGAgLSBUaGUgdW5pcXVlIHNlbmQgZXZlbnQgaWRlbnRpZmllciAodXNlZCB3aXRoIGBjYW5jZWwoKWApLlxuICogICAtIGBkZWxheWAgLSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSB0aGUgc2VuZGluZyBvZiB0aGUgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIHNlbmRUbyh0bywgZXZlbnRPckV4cHIsIG9wdGlvbnMpIHtcbiAgaWYgKGV4ZWN1dGluZ0N1c3RvbUFjdGlvbikge1xuICAgIGNvbnNvbGUud2FybignQ3VzdG9tIGFjdGlvbnMgc2hvdWxkIG5vdCBjYWxsIGByYWlzZSgpYCBkaXJlY3RseSwgYXMgaXQgaXMgbm90IGltcGVyYXRpdmUuIFNlZSBodHRwczovL3N0YXRlbHkuYWkvZG9jcy9hY3Rpb25zI2J1aWx0LWluLWFjdGlvbnMgZm9yIG1vcmUgZGV0YWlscy4nKTtcbiAgfVxuICBmdW5jdGlvbiBzZW5kVG8oYXJncywgcGFyYW1zKSB7XG4gICAge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIGlzbid0IHN1cHBvc2VkIHRvIGJlIGNhbGxlZGApO1xuICAgIH1cbiAgfVxuICBzZW5kVG8udHlwZSA9ICd4c25hcHNob3Quc2VuZFRvJztcbiAgc2VuZFRvLnRvID0gdG87XG4gIHNlbmRUby5ldmVudCA9IGV2ZW50T3JFeHByO1xuICBzZW5kVG8uaWQgPSBvcHRpb25zPy5pZDtcbiAgc2VuZFRvLmRlbGF5ID0gb3B0aW9ucz8uZGVsYXk7XG4gIHNlbmRUby5yZXNvbHZlID0gcmVzb2x2ZVNlbmRUbztcbiAgc2VuZFRvLnJldHJ5UmVzb2x2ZSA9IHJldHJ5UmVzb2x2ZVNlbmRUbztcbiAgc2VuZFRvLmV4ZWN1dGUgPSBleGVjdXRlU2VuZFRvO1xuICByZXR1cm4gc2VuZFRvO1xufVxuXG4vKipcbiAqIFNlbmRzIGFuIGV2ZW50IHRvIHRoaXMgbWFjaGluZSdzIHBhcmVudC5cbiAqXG4gKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHRvIHNlbmQgdG8gdGhlIHBhcmVudCBtYWNoaW5lLlxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyB0byBwYXNzIGludG8gdGhlIHNlbmQgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIHNlbmRQYXJlbnQoZXZlbnQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHNlbmRUbyhTcGVjaWFsVGFyZ2V0cy5QYXJlbnQsIGV2ZW50LCBvcHRpb25zKTtcbn1cbi8qKlxuICogRm9yd2FyZHMgKHNlbmRzKSBhbiBldmVudCB0byB0aGUgYHRhcmdldGAgYWN0b3IuXG4gKlxuICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IGFjdG9yIHRvIGZvcndhcmQgdGhlIGV2ZW50IHRvLlxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyB0byBwYXNzIGludG8gdGhlIHNlbmQgYWN0aW9uIGNyZWF0b3IuXG4gKi9cbmZ1bmN0aW9uIGZvcndhcmRUbyh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgaWYgKCghdGFyZ2V0IHx8IHR5cGVvZiB0YXJnZXQgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxUYXJnZXQgPSB0YXJnZXQ7XG4gICAgdGFyZ2V0ID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IHJlc29sdmVkVGFyZ2V0ID0gdHlwZW9mIG9yaWdpbmFsVGFyZ2V0ID09PSAnZnVuY3Rpb24nID8gb3JpZ2luYWxUYXJnZXQoLi4uYXJncykgOiBvcmlnaW5hbFRhcmdldDtcbiAgICAgIGlmICghcmVzb2x2ZWRUYXJnZXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdHRlbXB0ZWQgdG8gZm9yd2FyZCBldmVudCB0byB1bmRlZmluZWQgYWN0b3IuIFRoaXMgcmlza3MgYW4gaW5maW5pdGUgbG9vcCBpbiB0aGUgc2VuZGVyLmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc29sdmVkVGFyZ2V0O1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHNlbmRUbyh0YXJnZXQsICh7XG4gICAgZXZlbnRcbiAgfSkgPT4gZXZlbnQsIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRW5xdWV1ZUFjdGlvbnMoYWN0b3JTY29wZSwgc25hcHNob3QsIGFyZ3MsIGFjdGlvblBhcmFtcywge1xuICBjb2xsZWN0XG59KSB7XG4gIGNvbnN0IGFjdGlvbnMgPSBbXTtcbiAgY29uc3QgZW5xdWV1ZSA9IGZ1bmN0aW9uIGVucXVldWUoYWN0aW9uKSB7XG4gICAgYWN0aW9ucy5wdXNoKGFjdGlvbik7XG4gIH07XG4gIGVucXVldWUuYXNzaWduID0gKC4uLmFyZ3MpID0+IHtcbiAgICBhY3Rpb25zLnB1c2goYXNzaWduKC4uLmFyZ3MpKTtcbiAgfTtcbiAgZW5xdWV1ZS5jYW5jZWwgPSAoLi4uYXJncykgPT4ge1xuICAgIGFjdGlvbnMucHVzaChjYW5jZWwoLi4uYXJncykpO1xuICB9O1xuICBlbnF1ZXVlLnJhaXNlID0gKC4uLmFyZ3MpID0+IHtcbiAgICAvLyBmb3Igc29tZSByZWFzb24gaXQgZmFpbHMgdG8gaW5mZXIgYFREZWxheWAgZnJvbSBgLi4uYXJnc2AgaGVyZSBhbmQgcGlja3MgaXRzIGRlZmF1bHQgKGBuZXZlcmApXG4gICAgLy8gdGhlbiBpdCBmYWlscyB0byB0eXBlY2hlY2sgdGhhdCBiZWNhdXNlIGAuLi5hcmdzYCB1c2UgYHN0cmluZ2AgaW4gcGxhY2Ugb2YgYFREZWxheWBcbiAgICBhY3Rpb25zLnB1c2gocmFpc2UoLi4uYXJncykpO1xuICB9O1xuICBlbnF1ZXVlLnNlbmRUbyA9ICguLi5hcmdzKSA9PiB7XG4gICAgLy8gZm9yIHNvbWUgcmVhc29uIGl0IGZhaWxzIHRvIGluZmVyIGBURGVsYXlgIGZyb20gYC4uLmFyZ3NgIGhlcmUgYW5kIHBpY2tzIGl0cyBkZWZhdWx0IChgbmV2ZXJgKVxuICAgIC8vIHRoZW4gaXQgZmFpbHMgdG8gdHlwZWNoZWNrIHRoYXQgYmVjYXVzZSBgLi4uYXJnc2AgdXNlIGBzdHJpbmdgIGluIHBsYWNlIG9mIGBURGVsYXlcbiAgICBhY3Rpb25zLnB1c2goc2VuZFRvKC4uLmFyZ3MpKTtcbiAgfTtcbiAgZW5xdWV1ZS5zZW5kUGFyZW50ID0gKC4uLmFyZ3MpID0+IHtcbiAgICBhY3Rpb25zLnB1c2goc2VuZFBhcmVudCguLi5hcmdzKSk7XG4gIH07XG4gIGVucXVldWUuc3Bhd25DaGlsZCA9ICguLi5hcmdzKSA9PiB7XG4gICAgYWN0aW9ucy5wdXNoKHNwYXduQ2hpbGQoLi4uYXJncykpO1xuICB9O1xuICBlbnF1ZXVlLnN0b3BDaGlsZCA9ICguLi5hcmdzKSA9PiB7XG4gICAgYWN0aW9ucy5wdXNoKHN0b3BDaGlsZCguLi5hcmdzKSk7XG4gIH07XG4gIGVucXVldWUuZW1pdCA9ICguLi5hcmdzKSA9PiB7XG4gICAgYWN0aW9ucy5wdXNoKGVtaXQoLi4uYXJncykpO1xuICB9O1xuICBjb2xsZWN0KHtcbiAgICBjb250ZXh0OiBhcmdzLmNvbnRleHQsXG4gICAgZXZlbnQ6IGFyZ3MuZXZlbnQsXG4gICAgZW5xdWV1ZSxcbiAgICBjaGVjazogZ3VhcmQgPT4gZXZhbHVhdGVHdWFyZChndWFyZCwgc25hcHNob3QuY29udGV4dCwgYXJncy5ldmVudCwgc25hcHNob3QpLFxuICAgIHNlbGY6IGFjdG9yU2NvcGUuc2VsZixcbiAgICBzeXN0ZW06IGFjdG9yU2NvcGUuc3lzdGVtXG4gIH0sIGFjdGlvblBhcmFtcyk7XG4gIHJldHVybiBbc25hcHNob3QsIHVuZGVmaW5lZCwgYWN0aW9uc107XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gYWN0aW9uIG9iamVjdCB0aGF0IHdpbGwgZXhlY3V0ZSBhY3Rpb25zIHRoYXQgYXJlIHF1ZXVlZCBieSB0aGVcbiAqIGBlbnF1ZXVlKGFjdGlvbilgIGZ1bmN0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGNyZWF0ZU1hY2hpbmUsIGVucXVldWVBY3Rpb25zIH0gZnJvbSAneHN0YXRlJztcbiAqXG4gKiBjb25zdCBtYWNoaW5lID0gY3JlYXRlTWFjaGluZSh7XG4gKiAgIGVudHJ5OiBlbnF1ZXVlQWN0aW9ucygoeyBlbnF1ZXVlLCBjaGVjayB9KSA9PiB7XG4gKiAgICAgZW5xdWV1ZS5hc3NpZ24oeyBjb3VudDogMCB9KTtcbiAqXG4gKiAgICAgaWYgKGNoZWNrKCdzb21lR3VhcmQnKSkge1xuICogICAgICAgZW5xdWV1ZS5hc3NpZ24oeyBjb3VudDogMSB9KTtcbiAqICAgICB9XG4gKlxuICogICAgIGVucXVldWUoJ3NvbWVBY3Rpb24nKTtcbiAqICAgfSlcbiAqIH0pO1xuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGVucXVldWVBY3Rpb25zKGNvbGxlY3QpIHtcbiAgZnVuY3Rpb24gZW5xdWV1ZUFjdGlvbnMoYXJncywgcGFyYW1zKSB7XG4gICAge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIGlzbid0IHN1cHBvc2VkIHRvIGJlIGNhbGxlZGApO1xuICAgIH1cbiAgfVxuICBlbnF1ZXVlQWN0aW9ucy50eXBlID0gJ3hzdGF0ZS5lbnF1ZXVlQWN0aW9ucyc7XG4gIGVucXVldWVBY3Rpb25zLmNvbGxlY3QgPSBjb2xsZWN0O1xuICBlbnF1ZXVlQWN0aW9ucy5yZXNvbHZlID0gcmVzb2x2ZUVucXVldWVBY3Rpb25zO1xuICByZXR1cm4gZW5xdWV1ZUFjdGlvbnM7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVMb2coXywgc25hcHNob3QsIGFjdGlvbkFyZ3MsIGFjdGlvblBhcmFtcywge1xuICB2YWx1ZSxcbiAgbGFiZWxcbn0pIHtcbiAgcmV0dXJuIFtzbmFwc2hvdCwge1xuICAgIHZhbHVlOiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgPyB2YWx1ZShhY3Rpb25BcmdzLCBhY3Rpb25QYXJhbXMpIDogdmFsdWUsXG4gICAgbGFiZWxcbiAgfV07XG59XG5mdW5jdGlvbiBleGVjdXRlTG9nKHtcbiAgbG9nZ2VyXG59LCB7XG4gIHZhbHVlLFxuICBsYWJlbFxufSkge1xuICBpZiAobGFiZWwpIHtcbiAgICBsb2dnZXIobGFiZWwsIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBsb2dnZXIodmFsdWUpO1xuICB9XG59XG4vKipcbiAqIEBwYXJhbSBleHByIFRoZSBleHByZXNzaW9uIGZ1bmN0aW9uIHRvIGV2YWx1YXRlIHdoaWNoIHdpbGwgYmUgbG9nZ2VkLiBUYWtlc1xuICogICBpbiAyIGFyZ3VtZW50czpcbiAqXG4gKiAgIC0gYGN0eGAgLSB0aGUgY3VycmVudCBzdGF0ZSBjb250ZXh0XG4gKiAgIC0gYGV2ZW50YCAtIHRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGFjdGlvbiB0byBiZSBleGVjdXRlZC5cbiAqXG4gKiBAcGFyYW0gbGFiZWwgVGhlIGxhYmVsIHRvIGdpdmUgdG8gdGhlIGxvZ2dlZCBleHByZXNzaW9uLlxuICovXG5mdW5jdGlvbiBsb2codmFsdWUgPSAoe1xuICBjb250ZXh0LFxuICBldmVudFxufSkgPT4gKHtcbiAgY29udGV4dCxcbiAgZXZlbnRcbn0pLCBsYWJlbCkge1xuICBmdW5jdGlvbiBsb2coYXJncywgcGFyYW1zKSB7XG4gICAge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIGlzbid0IHN1cHBvc2VkIHRvIGJlIGNhbGxlZGApO1xuICAgIH1cbiAgfVxuICBsb2cudHlwZSA9ICd4c3RhdGUubG9nJztcbiAgbG9nLnZhbHVlID0gdmFsdWU7XG4gIGxvZy5sYWJlbCA9IGxhYmVsO1xuICBsb2cucmVzb2x2ZSA9IHJlc29sdmVMb2c7XG4gIGxvZy5leGVjdXRlID0gZXhlY3V0ZUxvZztcbiAgcmV0dXJuIGxvZztcbn1cblxuZXhwb3J0IHsgU3BlY2lhbFRhcmdldHMgYXMgUywgYXNzaWduIGFzIGEsIGVucXVldWVBY3Rpb25zIGFzIGIsIHNlbmRUbyBhcyBjLCBlbWl0IGFzIGUsIGZvcndhcmRUbyBhcyBmLCBsb2cgYXMgbCwgc2VuZFBhcmVudCBhcyBzIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/xstate/dist/log-38475d87.development.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/xstate/dist/raise-5ea71f04.development.esm.js":
/*!********************************************************************!*\
  !*** ./node_modules/xstate/dist/raise-5ea71f04.development.esm.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $: function() { return /* binding */ $$ACTOR_TYPE; },\n/* harmony export */   A: function() { return /* binding */ createActor; },\n/* harmony export */   B: function() { return /* binding */ Actor; },\n/* harmony export */   C: function() { return /* binding */ interpret; },\n/* harmony export */   D: function() { return /* binding */ and; },\n/* harmony export */   E: function() { return /* binding */ not; },\n/* harmony export */   F: function() { return /* binding */ or; },\n/* harmony export */   G: function() { return /* binding */ stateIn; },\n/* harmony export */   H: function() { return /* binding */ isMachineSnapshot; },\n/* harmony export */   I: function() { return /* binding */ getAllOwnEventDescriptors; },\n/* harmony export */   J: function() { return /* binding */ matchesState; },\n/* harmony export */   K: function() { return /* binding */ pathToStateValue; },\n/* harmony export */   L: function() { return /* binding */ toObserver; },\n/* harmony export */   M: function() { return /* binding */ cancel; },\n/* harmony export */   N: function() { return /* binding */ NULL_EVENT; },\n/* harmony export */   O: function() { return /* binding */ raise; },\n/* harmony export */   P: function() { return /* binding */ spawnChild; },\n/* harmony export */   Q: function() { return /* binding */ stop; },\n/* harmony export */   R: function() { return /* binding */ stopChild; },\n/* harmony export */   S: function() { return /* binding */ STATE_DELIMITER; },\n/* harmony export */   T: function() { return /* binding */ ProcessingStatus; },\n/* harmony export */   U: function() { return /* binding */ cloneMachineSnapshot; },\n/* harmony export */   V: function() { return /* binding */ executingCustomAction; },\n/* harmony export */   W: function() { return /* binding */ XSTATE_ERROR; },\n/* harmony export */   X: function() { return /* binding */ XSTATE_STOP; },\n/* harmony export */   Y: function() { return /* binding */ createErrorActorEvent; },\n/* harmony export */   a: function() { return /* binding */ toTransitionConfigArray; },\n/* harmony export */   b: function() { return /* binding */ formatTransition; },\n/* harmony export */   c: function() { return /* binding */ createInvokeId; },\n/* harmony export */   d: function() { return /* binding */ formatInitialTransition; },\n/* harmony export */   e: function() { return /* binding */ evaluateGuard; },\n/* harmony export */   f: function() { return /* binding */ formatTransitions; },\n/* harmony export */   g: function() { return /* binding */ getDelayedTransitions; },\n/* harmony export */   h: function() { return /* binding */ getCandidates; },\n/* harmony export */   i: function() { return /* binding */ getAllStateNodes; },\n/* harmony export */   j: function() { return /* binding */ getStateNodes; },\n/* harmony export */   k: function() { return /* binding */ createMachineSnapshot; },\n/* harmony export */   l: function() { return /* binding */ isInFinalState; },\n/* harmony export */   m: function() { return /* binding */ mapValues; },\n/* harmony export */   n: function() { return /* binding */ macrostep; },\n/* harmony export */   o: function() { return /* binding */ transitionNode; },\n/* harmony export */   p: function() { return /* binding */ resolveActionsAndContext; },\n/* harmony export */   q: function() { return /* binding */ createInitEvent; },\n/* harmony export */   r: function() { return /* binding */ resolveStateValue; },\n/* harmony export */   s: function() { return /* binding */ microstep; },\n/* harmony export */   t: function() { return /* binding */ toArray; },\n/* harmony export */   u: function() { return /* binding */ getInitialStateNodes; },\n/* harmony export */   v: function() { return /* binding */ toStatePath; },\n/* harmony export */   w: function() { return /* binding */ isStateId; },\n/* harmony export */   x: function() { return /* binding */ getStateNodeByPath; },\n/* harmony export */   y: function() { return /* binding */ getPersistedSnapshot; },\n/* harmony export */   z: function() { return /* binding */ resolveReferencedActor; }\n/* harmony export */ });\n/* harmony import */ var _dev_dist_xstate_dev_development_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dev/dist/xstate-dev.development.esm.js */ \"(app-pages-browser)/./node_modules/xstate/dev/dist/xstate-dev.development.esm.js\");\n\n\nclass Mailbox {\n  constructor(_process) {\n    this._process = _process;\n    this._active = false;\n    this._current = null;\n    this._last = null;\n  }\n  start() {\n    this._active = true;\n    this.flush();\n  }\n  clear() {\n    // we can't set _current to null because we might be currently processing\n    // and enqueue following clear shouldnt start processing the enqueued item immediately\n    if (this._current) {\n      this._current.next = null;\n      this._last = this._current;\n    }\n  }\n  enqueue(event) {\n    const enqueued = {\n      value: event,\n      next: null\n    };\n    if (this._current) {\n      this._last.next = enqueued;\n      this._last = enqueued;\n      return;\n    }\n    this._current = enqueued;\n    this._last = enqueued;\n    if (this._active) {\n      this.flush();\n    }\n  }\n  flush() {\n    while (this._current) {\n      // atm the given _process is responsible for implementing proper try/catch handling\n      // we assume here that this won't throw in a way that can affect this mailbox\n      const consumed = this._current;\n      this._process(consumed.value);\n      this._current = consumed.next;\n    }\n    this._last = null;\n  }\n}\n\nconst STATE_DELIMITER = '.';\nconst TARGETLESS_KEY = '';\nconst NULL_EVENT = '';\nconst STATE_IDENTIFIER = '#';\nconst WILDCARD = '*';\nconst XSTATE_INIT = 'xstate.init';\nconst XSTATE_ERROR = 'xstate.error';\nconst XSTATE_STOP = 'xstate.stop';\n\n/**\n * Returns an event that represents an implicit event that is sent after the\n * specified `delay`.\n *\n * @param delayRef The delay in milliseconds\n * @param id The state node ID where this event is handled\n */\nfunction createAfterEvent(delayRef, id) {\n  return {\n    type: `xstate.after.${delayRef}.${id}`\n  };\n}\n\n/**\n * Returns an event that represents that a final state node has been reached in\n * the parent state node.\n *\n * @param id The final state node's parent state node `id`\n * @param output The data to pass into the event\n */\nfunction createDoneStateEvent(id, output) {\n  return {\n    type: `xstate.done.state.${id}`,\n    output\n  };\n}\n\n/**\n * Returns an event that represents that an invoked service has terminated.\n *\n * An invoked service is terminated when it has reached a top-level final state\n * node, but not when it is canceled.\n *\n * @param invokeId The invoked service ID\n * @param output The data to pass into the event\n */\nfunction createDoneActorEvent(invokeId, output) {\n  return {\n    type: `xstate.done.actor.${invokeId}`,\n    output,\n    actorId: invokeId\n  };\n}\nfunction createErrorActorEvent(id, error) {\n  return {\n    type: `xstate.error.actor.${id}`,\n    error,\n    actorId: id\n  };\n}\nfunction createInitEvent(input) {\n  return {\n    type: XSTATE_INIT,\n    input\n  };\n}\n\n/**\n * This function makes sure that unhandled errors are thrown in a separate\n * macrotask. It allows those errors to be detected by global error handlers and\n * reported to bug tracking services without interrupting our own stack of\n * execution.\n *\n * @param err Error to be thrown\n */\nfunction reportUnhandledError(err) {\n  setTimeout(() => {\n    throw err;\n  });\n}\n\nconst symbolObservable = (() => typeof Symbol === 'function' && Symbol.observable || '@@observable')();\n\nfunction matchesState(parentStateId, childStateId) {\n  const parentStateValue = toStateValue(parentStateId);\n  const childStateValue = toStateValue(childStateId);\n  if (typeof childStateValue === 'string') {\n    if (typeof parentStateValue === 'string') {\n      return childStateValue === parentStateValue;\n    }\n\n    // Parent more specific than child\n    return false;\n  }\n  if (typeof parentStateValue === 'string') {\n    return parentStateValue in childStateValue;\n  }\n  return Object.keys(parentStateValue).every(key => {\n    if (!(key in childStateValue)) {\n      return false;\n    }\n    return matchesState(parentStateValue[key], childStateValue[key]);\n  });\n}\nfunction toStatePath(stateId) {\n  if (isArray(stateId)) {\n    return stateId;\n  }\n  let result = [];\n  let segment = '';\n  for (let i = 0; i < stateId.length; i++) {\n    const char = stateId.charCodeAt(i);\n    switch (char) {\n      // \\\n      case 92:\n        // consume the next character\n        segment += stateId[i + 1];\n        // and skip over it\n        i++;\n        continue;\n      // .\n      case 46:\n        result.push(segment);\n        segment = '';\n        continue;\n    }\n    segment += stateId[i];\n  }\n  result.push(segment);\n  return result;\n}\nfunction toStateValue(stateValue) {\n  if (isMachineSnapshot(stateValue)) {\n    return stateValue.value;\n  }\n  if (typeof stateValue !== 'string') {\n    return stateValue;\n  }\n  const statePath = toStatePath(stateValue);\n  return pathToStateValue(statePath);\n}\nfunction pathToStateValue(statePath) {\n  if (statePath.length === 1) {\n    return statePath[0];\n  }\n  const value = {};\n  let marker = value;\n  for (let i = 0; i < statePath.length - 1; i++) {\n    if (i === statePath.length - 2) {\n      marker[statePath[i]] = statePath[i + 1];\n    } else {\n      const previous = marker;\n      marker = {};\n      previous[statePath[i]] = marker;\n    }\n  }\n  return value;\n}\nfunction mapValues(collection, iteratee) {\n  const result = {};\n  const collectionKeys = Object.keys(collection);\n  for (let i = 0; i < collectionKeys.length; i++) {\n    const key = collectionKeys[i];\n    result[key] = iteratee(collection[key], key, collection, i);\n  }\n  return result;\n}\nfunction toArrayStrict(value) {\n  if (isArray(value)) {\n    return value;\n  }\n  return [value];\n}\nfunction toArray(value) {\n  if (value === undefined) {\n    return [];\n  }\n  return toArrayStrict(value);\n}\nfunction resolveOutput(mapper, context, event, self) {\n  if (typeof mapper === 'function') {\n    return mapper({\n      context,\n      event,\n      self\n    });\n  }\n  if (!!mapper && typeof mapper === 'object' && Object.values(mapper).some(val => typeof val === 'function')) {\n    console.warn(`Dynamically mapping values to individual properties is deprecated. Use a single function that returns the mapped object instead.\\nFound object containing properties whose values are possibly mapping functions: ${Object.entries(mapper).filter(([key, value]) => typeof value === 'function').map(([key, value]) => `\\n - ${key}: ${value.toString().replace(/\\n\\s*/g, '')}`).join('')}`);\n  }\n  return mapper;\n}\nfunction isArray(value) {\n  return Array.isArray(value);\n}\nfunction isErrorActorEvent(event) {\n  return event.type.startsWith('xstate.error.actor');\n}\nfunction toTransitionConfigArray(configLike) {\n  return toArrayStrict(configLike).map(transitionLike => {\n    if (typeof transitionLike === 'undefined' || typeof transitionLike === 'string') {\n      return {\n        target: transitionLike\n      };\n    }\n    return transitionLike;\n  });\n}\nfunction normalizeTarget(target) {\n  if (target === undefined || target === TARGETLESS_KEY) {\n    return undefined;\n  }\n  return toArray(target);\n}\nfunction toObserver(nextHandler, errorHandler, completionHandler) {\n  const isObserver = typeof nextHandler === 'object';\n  const self = isObserver ? nextHandler : undefined;\n  return {\n    next: (isObserver ? nextHandler.next : nextHandler)?.bind(self),\n    error: (isObserver ? nextHandler.error : errorHandler)?.bind(self),\n    complete: (isObserver ? nextHandler.complete : completionHandler)?.bind(self)\n  };\n}\nfunction createInvokeId(stateNodeId, index) {\n  return `${index}.${stateNodeId}`;\n}\nfunction resolveReferencedActor(machine, src) {\n  const match = src.match(/^xstate\\.invoke\\.(\\d+)\\.(.*)/);\n  if (!match) {\n    return machine.implementations.actors[src];\n  }\n  const [, indexStr, nodeId] = match;\n  const node = machine.getStateNodeById(nodeId);\n  const invokeConfig = node.config.invoke;\n  return (Array.isArray(invokeConfig) ? invokeConfig[indexStr] : invokeConfig).src;\n}\nfunction getAllOwnEventDescriptors(snapshot) {\n  return [...new Set([...snapshot._nodes.flatMap(sn => sn.ownEvents)])];\n}\n\nfunction createScheduledEventId(actorRef, id) {\n  return `${actorRef.sessionId}.${id}`;\n}\nlet idCounter = 0;\nfunction createSystem(rootActor, options) {\n  const children = new Map();\n  const keyedActors = new Map();\n  const reverseKeyedActors = new WeakMap();\n  const inspectionObservers = new Set();\n  const timerMap = {};\n  const {\n    clock,\n    logger\n  } = options;\n  const scheduler = {\n    schedule: (source, target, event, delay, id = Math.random().toString(36).slice(2)) => {\n      const scheduledEvent = {\n        source,\n        target,\n        event,\n        delay,\n        id,\n        startedAt: Date.now()\n      };\n      const scheduledEventId = createScheduledEventId(source, id);\n      system._snapshot._scheduledEvents[scheduledEventId] = scheduledEvent;\n      const timeout = clock.setTimeout(() => {\n        delete timerMap[scheduledEventId];\n        delete system._snapshot._scheduledEvents[scheduledEventId];\n        system._relay(source, target, event);\n      }, delay);\n      timerMap[scheduledEventId] = timeout;\n    },\n    cancel: (source, id) => {\n      const scheduledEventId = createScheduledEventId(source, id);\n      const timeout = timerMap[scheduledEventId];\n      delete timerMap[scheduledEventId];\n      delete system._snapshot._scheduledEvents[scheduledEventId];\n      if (timeout !== undefined) {\n        clock.clearTimeout(timeout);\n      }\n    },\n    cancelAll: actorRef => {\n      for (const scheduledEventId in system._snapshot._scheduledEvents) {\n        const scheduledEvent = system._snapshot._scheduledEvents[scheduledEventId];\n        if (scheduledEvent.source === actorRef) {\n          scheduler.cancel(actorRef, scheduledEvent.id);\n        }\n      }\n    }\n  };\n  const sendInspectionEvent = event => {\n    if (!inspectionObservers.size) {\n      return;\n    }\n    const resolvedInspectionEvent = {\n      ...event,\n      rootId: rootActor.sessionId\n    };\n    inspectionObservers.forEach(observer => observer.next?.(resolvedInspectionEvent));\n  };\n  const system = {\n    _snapshot: {\n      _scheduledEvents: (options?.snapshot && options.snapshot.scheduler) ?? {}\n    },\n    _bookId: () => `x:${idCounter++}`,\n    _register: (sessionId, actorRef) => {\n      children.set(sessionId, actorRef);\n      return sessionId;\n    },\n    _unregister: actorRef => {\n      children.delete(actorRef.sessionId);\n      const systemId = reverseKeyedActors.get(actorRef);\n      if (systemId !== undefined) {\n        keyedActors.delete(systemId);\n        reverseKeyedActors.delete(actorRef);\n      }\n    },\n    get: systemId => {\n      return keyedActors.get(systemId);\n    },\n    _set: (systemId, actorRef) => {\n      const existing = keyedActors.get(systemId);\n      if (existing && existing !== actorRef) {\n        throw new Error(`Actor with system ID '${systemId}' already exists.`);\n      }\n      keyedActors.set(systemId, actorRef);\n      reverseKeyedActors.set(actorRef, systemId);\n    },\n    inspect: observerOrFn => {\n      const observer = toObserver(observerOrFn);\n      inspectionObservers.add(observer);\n      return {\n        unsubscribe() {\n          inspectionObservers.delete(observer);\n        }\n      };\n    },\n    _sendInspectionEvent: sendInspectionEvent,\n    _relay: (source, target, event) => {\n      system._sendInspectionEvent({\n        type: '@xstate.event',\n        sourceRef: source,\n        actorRef: target,\n        event\n      });\n      target._send(event);\n    },\n    scheduler,\n    getSnapshot: () => {\n      return {\n        _scheduledEvents: {\n          ...system._snapshot._scheduledEvents\n        }\n      };\n    },\n    start: () => {\n      const scheduledEvents = system._snapshot._scheduledEvents;\n      system._snapshot._scheduledEvents = {};\n      for (const scheduledId in scheduledEvents) {\n        const {\n          source,\n          target,\n          event,\n          delay,\n          id\n        } = scheduledEvents[scheduledId];\n        scheduler.schedule(source, target, event, delay, id);\n      }\n    },\n    _clock: clock,\n    _logger: logger\n  };\n  return system;\n}\n\nconst $$ACTOR_TYPE = 1;\n\n// those values are currently used by @xstate/react directly so it's important to keep the assigned values in sync\nlet ProcessingStatus = /*#__PURE__*/function (ProcessingStatus) {\n  ProcessingStatus[ProcessingStatus[\"NotStarted\"] = 0] = \"NotStarted\";\n  ProcessingStatus[ProcessingStatus[\"Running\"] = 1] = \"Running\";\n  ProcessingStatus[ProcessingStatus[\"Stopped\"] = 2] = \"Stopped\";\n  return ProcessingStatus;\n}({});\nconst defaultOptions = {\n  clock: {\n    setTimeout: (fn, ms) => {\n      return setTimeout(fn, ms);\n    },\n    clearTimeout: id => {\n      return clearTimeout(id);\n    }\n  },\n  logger: console.log.bind(console),\n  devTools: false\n};\n\n/**\n * An Actor is a running process that can receive events, send events and change\n * its behavior based on the events it receives, which can cause effects outside\n * of the actor. When you run a state machine, it becomes an actor.\n */\nclass Actor {\n  /**\n   * Creates a new actor instance for the given logic with the provided options,\n   * if any.\n   *\n   * @param logic The logic to create an actor from\n   * @param options Actor options\n   */\n  constructor(logic, options) {\n    this.logic = logic;\n    /** The current internal state of the actor. */\n    this._snapshot = void 0;\n    /**\n     * The clock that is responsible for setting and clearing timeouts, such as\n     * delayed events and transitions.\n     */\n    this.clock = void 0;\n    this.options = void 0;\n    /** The unique identifier for this actor relative to its parent. */\n    this.id = void 0;\n    this.mailbox = new Mailbox(this._process.bind(this));\n    this.observers = new Set();\n    this.eventListeners = new Map();\n    this.logger = void 0;\n    /** @internal */\n    this._processingStatus = ProcessingStatus.NotStarted;\n    // Actor Ref\n    this._parent = void 0;\n    /** @internal */\n    this._syncSnapshot = void 0;\n    this.ref = void 0;\n    // TODO: add typings for system\n    this._actorScope = void 0;\n    this._systemId = void 0;\n    /** The globally unique process ID for this invocation. */\n    this.sessionId = void 0;\n    /** The system to which this actor belongs. */\n    this.system = void 0;\n    this._doneEvent = void 0;\n    this.src = void 0;\n    // array of functions to defer\n    this._deferred = [];\n    const resolvedOptions = {\n      ...defaultOptions,\n      ...options\n    };\n    const {\n      clock,\n      logger,\n      parent,\n      syncSnapshot,\n      id,\n      systemId,\n      inspect\n    } = resolvedOptions;\n    this.system = parent ? parent.system : createSystem(this, {\n      clock,\n      logger\n    });\n    if (inspect && !parent) {\n      // Always inspect at the system-level\n      this.system.inspect(toObserver(inspect));\n    }\n    this.sessionId = this.system._bookId();\n    this.id = id ?? this.sessionId;\n    this.logger = options?.logger ?? this.system._logger;\n    this.clock = options?.clock ?? this.system._clock;\n    this._parent = parent;\n    this._syncSnapshot = syncSnapshot;\n    this.options = resolvedOptions;\n    this.src = resolvedOptions.src ?? logic;\n    this.ref = this;\n    this._actorScope = {\n      self: this,\n      id: this.id,\n      sessionId: this.sessionId,\n      logger: this.logger,\n      defer: fn => {\n        this._deferred.push(fn);\n      },\n      system: this.system,\n      stopChild: child => {\n        if (child._parent !== this) {\n          throw new Error(`Cannot stop child actor ${child.id} of ${this.id} because it is not a child`);\n        }\n        child._stop();\n      },\n      emit: emittedEvent => {\n        const listeners = this.eventListeners.get(emittedEvent.type);\n        const wildcardListener = this.eventListeners.get('*');\n        if (!listeners && !wildcardListener) {\n          return;\n        }\n        const allListeners = new Set([...(listeners ? listeners.values() : []), ...(wildcardListener ? wildcardListener.values() : [])]);\n        for (const handler of Array.from(allListeners)) {\n          handler(emittedEvent);\n        }\n      }\n    };\n\n    // Ensure that the send method is bound to this Actor instance\n    // if destructured\n    this.send = this.send.bind(this);\n    this.system._sendInspectionEvent({\n      type: '@xstate.actor',\n      actorRef: this\n    });\n    if (systemId) {\n      this._systemId = systemId;\n      this.system._set(systemId, this);\n    }\n    this._initState(options?.snapshot ?? options?.state);\n    if (systemId && this._snapshot.status !== 'active') {\n      this.system._unregister(this);\n    }\n  }\n  _initState(persistedState) {\n    try {\n      this._snapshot = persistedState ? this.logic.restoreSnapshot ? this.logic.restoreSnapshot(persistedState, this._actorScope) : persistedState : this.logic.getInitialSnapshot(this._actorScope, this.options?.input);\n    } catch (err) {\n      // if we get here then it means that we assign a value to this._snapshot that is not of the correct type\n      // we can't get the true `TSnapshot & { status: 'error'; }`, it's impossible\n      // so right now this is a lie of sorts\n      this._snapshot = {\n        status: 'error',\n        output: undefined,\n        error: err\n      };\n    }\n  }\n  update(snapshot, event) {\n    // Update state\n    this._snapshot = snapshot;\n\n    // Execute deferred effects\n    let deferredFn;\n    while (deferredFn = this._deferred.shift()) {\n      try {\n        deferredFn();\n      } catch (err) {\n        // this error can only be caught when executing *initial* actions\n        // it's the only time when we call actions provided by the user through those deferreds\n        // when the actor is already running we always execute them synchronously while transitioning\n        // no \"builtin deferred\" should actually throw an error since they are either safe\n        // or the control flow is passed through the mailbox and errors should be caught by the `_process` used by the mailbox\n        this._deferred.length = 0;\n        this._snapshot = {\n          ...snapshot,\n          status: 'error',\n          error: err\n        };\n      }\n    }\n    switch (this._snapshot.status) {\n      case 'active':\n        for (const observer of this.observers) {\n          try {\n            observer.next?.(snapshot);\n          } catch (err) {\n            reportUnhandledError(err);\n          }\n        }\n        break;\n      case 'done':\n        // next observers are meant to be notified about done snapshots\n        // this can be seen as something that is different from how observable work\n        // but with observables `complete` callback is called without any arguments\n        // it's more ergonomic for XState to treat a done snapshot as a \"next\" value\n        // and the completion event as something that is separate,\n        // something that merely follows emitting that done snapshot\n        for (const observer of this.observers) {\n          try {\n            observer.next?.(snapshot);\n          } catch (err) {\n            reportUnhandledError(err);\n          }\n        }\n        this._stopProcedure();\n        this._complete();\n        this._doneEvent = createDoneActorEvent(this.id, this._snapshot.output);\n        if (this._parent) {\n          this.system._relay(this, this._parent, this._doneEvent);\n        }\n        break;\n      case 'error':\n        this._error(this._snapshot.error);\n        break;\n    }\n    this.system._sendInspectionEvent({\n      type: '@xstate.snapshot',\n      actorRef: this,\n      event,\n      snapshot\n    });\n  }\n\n  /**\n   * Subscribe an observer to an actors snapshot values.\n   *\n   * @remarks\n   * The observer will receive the actors snapshot value when it is emitted.\n   * The observer can be:\n   *\n   * - A plain function that receives the latest snapshot, or\n   * - An observer object whose `.next(snapshot)` method receives the latest\n   *   snapshot\n   *\n   * @example\n   *\n   * ```ts\n   * // Observer as a plain function\n   * const subscription = actor.subscribe((snapshot) => {\n   *   console.log(snapshot);\n   * });\n   * ```\n   *\n   * @example\n   *\n   * ```ts\n   * // Observer as an object\n   * const subscription = actor.subscribe({\n   *   next(snapshot) {\n   *     console.log(snapshot);\n   *   },\n   *   error(err) {\n   *     // ...\n   *   },\n   *   complete() {\n   *     // ...\n   *   }\n   * });\n   * ```\n   *\n   * The return value of `actor.subscribe(observer)` is a subscription object\n   * that has an `.unsubscribe()` method. You can call\n   * `subscription.unsubscribe()` to unsubscribe the observer:\n   *\n   * @example\n   *\n   * ```ts\n   * const subscription = actor.subscribe((snapshot) => {\n   *   // ...\n   * });\n   *\n   * // Unsubscribe the observer\n   * subscription.unsubscribe();\n   * ```\n   *\n   * When the actor is stopped, all of its observers will automatically be\n   * unsubscribed.\n   *\n   * @param observer - Either a plain function that receives the latest\n   *   snapshot, or an observer object whose `.next(snapshot)` method receives\n   *   the latest snapshot\n   */\n\n  subscribe(nextListenerOrObserver, errorListener, completeListener) {\n    const observer = toObserver(nextListenerOrObserver, errorListener, completeListener);\n    if (this._processingStatus !== ProcessingStatus.Stopped) {\n      this.observers.add(observer);\n    } else {\n      switch (this._snapshot.status) {\n        case 'done':\n          try {\n            observer.complete?.();\n          } catch (err) {\n            reportUnhandledError(err);\n          }\n          break;\n        case 'error':\n          {\n            const err = this._snapshot.error;\n            if (!observer.error) {\n              reportUnhandledError(err);\n            } else {\n              try {\n                observer.error(err);\n              } catch (err) {\n                reportUnhandledError(err);\n              }\n            }\n            break;\n          }\n      }\n    }\n    return {\n      unsubscribe: () => {\n        this.observers.delete(observer);\n      }\n    };\n  }\n  on(type, handler) {\n    let listeners = this.eventListeners.get(type);\n    if (!listeners) {\n      listeners = new Set();\n      this.eventListeners.set(type, listeners);\n    }\n    const wrappedHandler = handler.bind(undefined);\n    listeners.add(wrappedHandler);\n    return {\n      unsubscribe: () => {\n        listeners.delete(wrappedHandler);\n      }\n    };\n  }\n\n  /** Starts the Actor from the initial state */\n  start() {\n    if (this._processingStatus === ProcessingStatus.Running) {\n      // Do not restart the service if it is already started\n      return this;\n    }\n    if (this._syncSnapshot) {\n      this.subscribe({\n        next: snapshot => {\n          if (snapshot.status === 'active') {\n            this.system._relay(this, this._parent, {\n              type: `xstate.snapshot.${this.id}`,\n              snapshot\n            });\n          }\n        },\n        error: () => {}\n      });\n    }\n    this.system._register(this.sessionId, this);\n    if (this._systemId) {\n      this.system._set(this._systemId, this);\n    }\n    this._processingStatus = ProcessingStatus.Running;\n\n    // TODO: this isn't correct when rehydrating\n    const initEvent = createInitEvent(this.options.input);\n    this.system._sendInspectionEvent({\n      type: '@xstate.event',\n      sourceRef: this._parent,\n      actorRef: this,\n      event: initEvent\n    });\n    const status = this._snapshot.status;\n    switch (status) {\n      case 'done':\n        // a state machine can be \"done\" upon initialization (it could reach a final state using initial microsteps)\n        // we still need to complete observers, flush deferreds etc\n        this.update(this._snapshot, initEvent);\n        // TODO: rethink cleanup of observers, mailbox, etc\n        return this;\n      case 'error':\n        this._error(this._snapshot.error);\n        return this;\n    }\n    if (!this._parent) {\n      this.system.start();\n    }\n    if (this.logic.start) {\n      try {\n        this.logic.start(this._snapshot, this._actorScope);\n      } catch (err) {\n        this._snapshot = {\n          ...this._snapshot,\n          status: 'error',\n          error: err\n        };\n        this._error(err);\n        return this;\n      }\n    }\n\n    // TODO: this notifies all subscribers but usually this is redundant\n    // there is no real change happening here\n    // we need to rethink if this needs to be refactored\n    this.update(this._snapshot, initEvent);\n    if (this.options.devTools) {\n      this.attachDevTools();\n    }\n    this.mailbox.start();\n    return this;\n  }\n  _process(event) {\n    let nextState;\n    let caughtError;\n    try {\n      nextState = this.logic.transition(this._snapshot, event, this._actorScope);\n    } catch (err) {\n      // we wrap it in a box so we can rethrow it later even if falsy value gets caught here\n      caughtError = {\n        err\n      };\n    }\n    if (caughtError) {\n      const {\n        err\n      } = caughtError;\n      this._snapshot = {\n        ...this._snapshot,\n        status: 'error',\n        error: err\n      };\n      this._error(err);\n      return;\n    }\n    this.update(nextState, event);\n    if (event.type === XSTATE_STOP) {\n      this._stopProcedure();\n      this._complete();\n    }\n  }\n  _stop() {\n    if (this._processingStatus === ProcessingStatus.Stopped) {\n      return this;\n    }\n    this.mailbox.clear();\n    if (this._processingStatus === ProcessingStatus.NotStarted) {\n      this._processingStatus = ProcessingStatus.Stopped;\n      return this;\n    }\n    this.mailbox.enqueue({\n      type: XSTATE_STOP\n    });\n    return this;\n  }\n\n  /** Stops the Actor and unsubscribe all listeners. */\n  stop() {\n    if (this._parent) {\n      throw new Error('A non-root actor cannot be stopped directly.');\n    }\n    return this._stop();\n  }\n  _complete() {\n    for (const observer of this.observers) {\n      try {\n        observer.complete?.();\n      } catch (err) {\n        reportUnhandledError(err);\n      }\n    }\n    this.observers.clear();\n  }\n  _reportError(err) {\n    if (!this.observers.size) {\n      if (!this._parent) {\n        reportUnhandledError(err);\n      }\n      return;\n    }\n    let reportError = false;\n    for (const observer of this.observers) {\n      const errorListener = observer.error;\n      reportError ||= !errorListener;\n      try {\n        errorListener?.(err);\n      } catch (err2) {\n        reportUnhandledError(err2);\n      }\n    }\n    this.observers.clear();\n    if (reportError) {\n      reportUnhandledError(err);\n    }\n  }\n  _error(err) {\n    this._stopProcedure();\n    this._reportError(err);\n    if (this._parent) {\n      this.system._relay(this, this._parent, createErrorActorEvent(this.id, err));\n    }\n  }\n  // TODO: atm children don't belong entirely to the actor so\n  // in a way - it's not even super aware of them\n  // so we can't stop them from here but we really should!\n  // right now, they are being stopped within the machine's transition\n  // but that could throw and leave us with \"orphaned\" active actors\n  _stopProcedure() {\n    if (this._processingStatus !== ProcessingStatus.Running) {\n      // Actor already stopped; do nothing\n      return this;\n    }\n\n    // Cancel all delayed events\n    this.system.scheduler.cancelAll(this);\n\n    // TODO: mailbox.reset\n    this.mailbox.clear();\n    // TODO: after `stop` we must prepare ourselves for receiving events again\n    // events sent *after* stop signal must be queued\n    // it seems like this should be the common behavior for all of our consumers\n    // so perhaps this should be unified somehow for all of them\n    this.mailbox = new Mailbox(this._process.bind(this));\n    this._processingStatus = ProcessingStatus.Stopped;\n    this.system._unregister(this);\n    return this;\n  }\n\n  /** @internal */\n  _send(event) {\n    if (this._processingStatus === ProcessingStatus.Stopped) {\n      // do nothing\n      {\n        const eventString = JSON.stringify(event);\n        console.warn(`Event \"${event.type}\" was sent to stopped actor \"${this.id} (${this.sessionId})\". This actor has already reached its final state, and will not transition.\\nEvent: ${eventString}`);\n      }\n      return;\n    }\n    this.mailbox.enqueue(event);\n  }\n\n  /**\n   * Sends an event to the running Actor to trigger a transition.\n   *\n   * @param event The event to send\n   */\n  send(event) {\n    if (typeof event === 'string') {\n      throw new Error(`Only event objects may be sent to actors; use .send({ type: \"${event}\" }) instead`);\n    }\n    this.system._relay(undefined, this, event);\n  }\n  attachDevTools() {\n    const {\n      devTools\n    } = this.options;\n    if (devTools) {\n      const resolvedDevToolsAdapter = typeof devTools === 'function' ? devTools : _dev_dist_xstate_dev_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.devToolsAdapter;\n      resolvedDevToolsAdapter(this);\n    }\n  }\n  toJSON() {\n    return {\n      xstate$$type: $$ACTOR_TYPE,\n      id: this.id\n    };\n  }\n\n  /**\n   * Obtain the internal state of the actor, which can be persisted.\n   *\n   * @remarks\n   * The internal state can be persisted from any actor, not only machines.\n   *\n   * Note that the persisted state is not the same as the snapshot from\n   * {@link Actor.getSnapshot}. Persisted state represents the internal state of\n   * the actor, while snapshots represent the actor's last emitted value.\n   *\n   * Can be restored with {@link ActorOptions.state}\n   * @see https://stately.ai/docs/persistence\n   */\n\n  getPersistedSnapshot(options) {\n    return this.logic.getPersistedSnapshot(this._snapshot, options);\n  }\n  [symbolObservable]() {\n    return this;\n  }\n\n  /**\n   * Read an actors snapshot synchronously.\n   *\n   * @remarks\n   * The snapshot represent an actor's last emitted value.\n   *\n   * When an actor receives an event, its internal state may change. An actor\n   * may emit a snapshot when a state transition occurs.\n   *\n   * Note that some actors, such as callback actors generated with\n   * `fromCallback`, will not emit snapshots.\n   * @see {@link Actor.subscribe} to subscribe to an actors snapshot values.\n   * @see {@link Actor.getPersistedSnapshot} to persist the internal state of an actor (which is more than just a snapshot).\n   */\n  getSnapshot() {\n    if (!this._snapshot) {\n      throw new Error(`Snapshot can't be read while the actor initializes itself`);\n    }\n    return this._snapshot;\n  }\n}\n/**\n * Creates a new actor instance for the given actor logic with the provided\n * options, if any.\n *\n * @remarks\n * When you create an actor from actor logic via `createActor(logic)`, you\n * implicitly create an actor system where the created actor is the root actor.\n * Any actors spawned from this root actor and its descendants are part of that\n * actor system.\n * @example\n *\n * ```ts\n * import { createActor } from 'xstate';\n * import { someActorLogic } from './someActorLogic.ts';\n *\n * // Creating the actor, which implicitly creates an actor system with itself as the root actor\n * const actor = createActor(someActorLogic);\n *\n * actor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n *\n * // Actors must be started by calling `actor.start()`, which will also start the actor system.\n * actor.start();\n *\n * // Actors can receive events\n * actor.send({ type: 'someEvent' });\n *\n * // You can stop root actors by calling `actor.stop()`, which will also stop the actor system and all actors in that system.\n * actor.stop();\n * ```\n *\n * @param logic - The actor logic to create an actor from. For a state machine\n *   actor logic creator, see {@link createMachine}. Other actor logic creators\n *   include {@link fromCallback}, {@link fromEventObservable},\n *   {@link fromObservable}, {@link fromPromise}, and {@link fromTransition}.\n * @param options - Actor options\n */\nfunction createActor(logic, ...[options]) {\n  return new Actor(logic, options);\n}\n\n/**\n * Creates a new Interpreter instance for the given machine with the provided\n * options, if any.\n *\n * @deprecated Use `createActor` instead\n * @alias\n */\nconst interpret = createActor;\n\n/**\n * @deprecated Use `Actor` instead.\n * @alias\n */\n\nfunction resolveCancel(_, snapshot, actionArgs, actionParams, {\n  sendId\n}) {\n  const resolvedSendId = typeof sendId === 'function' ? sendId(actionArgs, actionParams) : sendId;\n  return [snapshot, resolvedSendId];\n}\nfunction executeCancel(actorScope, resolvedSendId) {\n  actorScope.defer(() => {\n    actorScope.system.scheduler.cancel(actorScope.self, resolvedSendId);\n  });\n}\n/**\n * Cancels a delayed `sendTo(...)` action that is waiting to be executed. The\n * canceled `sendTo(...)` action will not send its event or execute, unless the\n * `delay` has already elapsed before `cancel(...)` is called.\n *\n * @example\n *\n * ```ts\n * import { createMachine, sendTo, cancel } from 'xstate';\n *\n * const machine = createMachine({\n *   // ...\n *   on: {\n *     sendEvent: {\n *       actions: sendTo(\n *         'some-actor',\n *         { type: 'someEvent' },\n *         {\n *           id: 'some-id',\n *           delay: 1000\n *         }\n *       )\n *     },\n *     cancelEvent: {\n *       actions: cancel('some-id')\n *     }\n *   }\n * });\n * ```\n *\n * @param sendId The `id` of the `sendTo(...)` action to cancel.\n */\nfunction cancel(sendId) {\n  function cancel(args, params) {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  cancel.type = 'xstate.cancel';\n  cancel.sendId = sendId;\n  cancel.resolve = resolveCancel;\n  cancel.execute = executeCancel;\n  return cancel;\n}\n\nfunction resolveSpawn(actorScope, snapshot, actionArgs, _actionParams, {\n  id,\n  systemId,\n  src,\n  input,\n  syncSnapshot\n}) {\n  const logic = typeof src === 'string' ? resolveReferencedActor(snapshot.machine, src) : src;\n  const resolvedId = typeof id === 'function' ? id(actionArgs) : id;\n  let actorRef;\n  if (logic) {\n    actorRef = createActor(logic, {\n      id: resolvedId,\n      src,\n      parent: actorScope.self,\n      syncSnapshot,\n      systemId,\n      input: typeof input === 'function' ? input({\n        context: snapshot.context,\n        event: actionArgs.event,\n        self: actorScope.self\n      }) : input\n    });\n  }\n  if (!actorRef) {\n    console.warn(`Actor type '${src}' not found in machine '${actorScope.id}'.`);\n  }\n  return [cloneMachineSnapshot(snapshot, {\n    children: {\n      ...snapshot.children,\n      [resolvedId]: actorRef\n    }\n  }), {\n    id,\n    actorRef\n  }];\n}\nfunction executeSpawn(actorScope, {\n  id,\n  actorRef\n}) {\n  if (!actorRef) {\n    return;\n  }\n  actorScope.defer(() => {\n    if (actorRef._processingStatus === ProcessingStatus.Stopped) {\n      return;\n    }\n    actorRef.start();\n  });\n}\nfunction spawnChild(...[src, {\n  id,\n  systemId,\n  input,\n  syncSnapshot = false\n} = {}]) {\n  function spawnChild(args, params) {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  spawnChild.type = 'snapshot.spawnChild';\n  spawnChild.id = id;\n  spawnChild.systemId = systemId;\n  spawnChild.src = src;\n  spawnChild.input = input;\n  spawnChild.syncSnapshot = syncSnapshot;\n  spawnChild.resolve = resolveSpawn;\n  spawnChild.execute = executeSpawn;\n  return spawnChild;\n}\n\nfunction resolveStop(_, snapshot, args, actionParams, {\n  actorRef\n}) {\n  const actorRefOrString = typeof actorRef === 'function' ? actorRef(args, actionParams) : actorRef;\n  const resolvedActorRef = typeof actorRefOrString === 'string' ? snapshot.children[actorRefOrString] : actorRefOrString;\n  let children = snapshot.children;\n  if (resolvedActorRef) {\n    children = {\n      ...children\n    };\n    delete children[resolvedActorRef.id];\n  }\n  return [cloneMachineSnapshot(snapshot, {\n    children\n  }), resolvedActorRef];\n}\nfunction executeStop(actorScope, actorRef) {\n  if (!actorRef) {\n    return;\n  }\n\n  // we need to eagerly unregister it here so a new actor with the same systemId can be registered immediately\n  // since we defer actual stopping of the actor but we don't defer actor creations (and we can't do that)\n  // this could throw on `systemId` collision, for example, when dealing with reentering transitions\n  actorScope.system._unregister(actorRef);\n\n  // this allows us to prevent an actor from being started if it gets stopped within the same macrostep\n  // this can happen, for example, when the invoking state is being exited immediately by an always transition\n  if (actorRef._processingStatus !== ProcessingStatus.Running) {\n    actorScope.stopChild(actorRef);\n    return;\n  }\n  // stopping a child enqueues a stop event in the child actor's mailbox\n  // we need for all of the already enqueued events to be processed before we stop the child\n  // the parent itself might want to send some events to a child (for example from exit actions on the invoking state)\n  // and we don't want to ignore those events\n  actorScope.defer(() => {\n    actorScope.stopChild(actorRef);\n  });\n}\n/**\n * Stops a child actor.\n *\n * @param actorRef The actor to stop.\n */\nfunction stopChild(actorRef) {\n  function stop(args, params) {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  stop.type = 'xstate.stopChild';\n  stop.actorRef = actorRef;\n  stop.resolve = resolveStop;\n  stop.execute = executeStop;\n  return stop;\n}\n\n/**\n * Stops a child actor.\n *\n * @deprecated Use `stopChild(...)` instead\n * @alias\n */\nconst stop = stopChild;\n\nfunction checkStateIn(snapshot, _, {\n  stateValue\n}) {\n  if (typeof stateValue === 'string' && isStateId(stateValue)) {\n    const target = snapshot.machine.getStateNodeById(stateValue);\n    return snapshot._nodes.some(sn => sn === target);\n  }\n  return snapshot.matches(stateValue);\n}\nfunction stateIn(stateValue) {\n  function stateIn(args, params) {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  stateIn.check = checkStateIn;\n  stateIn.stateValue = stateValue;\n  return stateIn;\n}\nfunction checkNot(snapshot, {\n  context,\n  event\n}, {\n  guards\n}) {\n  return !evaluateGuard(guards[0], context, event, snapshot);\n}\n\n/**\n * Higher-order guard that evaluates to `true` if the `guard` passed to it\n * evaluates to `false`.\n *\n * @category Guards\n * @example\n *\n * ```ts\n * import { setup, not } from 'xstate';\n *\n * const machine = setup({\n *   guards: {\n *     someNamedGuard: () => false\n *   }\n * }).createMachine({\n *   on: {\n *     someEvent: {\n *       guard: not('someNamedGuard'),\n *       actions: () => {\n *         // will be executed if guard in `not(...)`\n *         // evaluates to `false`\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @returns A guard\n */\nfunction not(guard) {\n  function not(args, params) {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  not.check = checkNot;\n  not.guards = [guard];\n  return not;\n}\nfunction checkAnd(snapshot, {\n  context,\n  event\n}, {\n  guards\n}) {\n  return guards.every(guard => evaluateGuard(guard, context, event, snapshot));\n}\n\n/**\n * Higher-order guard that evaluates to `true` if all `guards` passed to it\n * evaluate to `true`.\n *\n * @category Guards\n * @example\n *\n * ```ts\n * import { setup, and } from 'xstate';\n *\n * const machine = setup({\n *   guards: {\n *     someNamedGuard: () => true\n *   }\n * }).createMachine({\n *   on: {\n *     someEvent: {\n *       guard: and([({ context }) => context.value > 0, 'someNamedGuard']),\n *       actions: () => {\n *         // will be executed if all guards in `and(...)`\n *         // evaluate to true\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @returns A guard action object\n */\nfunction and(guards) {\n  function and(args, params) {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  and.check = checkAnd;\n  and.guards = guards;\n  return and;\n}\nfunction checkOr(snapshot, {\n  context,\n  event\n}, {\n  guards\n}) {\n  return guards.some(guard => evaluateGuard(guard, context, event, snapshot));\n}\n\n/**\n * Higher-order guard that evaluates to `true` if any of the `guards` passed to\n * it evaluate to `true`.\n *\n * @category Guards\n * @example\n *\n * ```ts\n * import { setup, or } from 'xstate';\n *\n * const machine = setup({\n *   guards: {\n *     someNamedGuard: () => true\n *   }\n * }).createMachine({\n *   on: {\n *     someEvent: {\n *       guard: or([({ context }) => context.value > 0, 'someNamedGuard']),\n *       actions: () => {\n *         // will be executed if any of the guards in `or(...)`\n *         // evaluate to true\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @returns A guard action object\n */\nfunction or(guards) {\n  function or(args, params) {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  or.check = checkOr;\n  or.guards = guards;\n  return or;\n}\n\n// TODO: throw on cycles (depth check should be enough)\nfunction evaluateGuard(guard, context, event, snapshot) {\n  const {\n    machine\n  } = snapshot;\n  const isInline = typeof guard === 'function';\n  const resolved = isInline ? guard : machine.implementations.guards[typeof guard === 'string' ? guard : guard.type];\n  if (!isInline && !resolved) {\n    throw new Error(`Guard '${typeof guard === 'string' ? guard : guard.type}' is not implemented.'.`);\n  }\n  if (typeof resolved !== 'function') {\n    return evaluateGuard(resolved, context, event, snapshot);\n  }\n  const guardArgs = {\n    context,\n    event\n  };\n  const guardParams = isInline || typeof guard === 'string' ? undefined : 'params' in guard ? typeof guard.params === 'function' ? guard.params({\n    context,\n    event\n  }) : guard.params : undefined;\n  if (!('check' in resolved)) {\n    // the existing type of `.guards` assumes non-nullable `TExpressionGuard`\n    // inline guards expect `TExpressionGuard` to be set to `undefined`\n    // it's fine to cast this here, our logic makes sure that we call those 2 \"variants\" correctly\n    return resolved(guardArgs, guardParams);\n  }\n  const builtinGuard = resolved;\n  return builtinGuard.check(snapshot, guardArgs, resolved // this holds all params\n  );\n}\n\nconst isAtomicStateNode = stateNode => stateNode.type === 'atomic' || stateNode.type === 'final';\nfunction getChildren(stateNode) {\n  return Object.values(stateNode.states).filter(sn => sn.type !== 'history');\n}\nfunction getProperAncestors(stateNode, toStateNode) {\n  const ancestors = [];\n  if (toStateNode === stateNode) {\n    return ancestors;\n  }\n\n  // add all ancestors\n  let m = stateNode.parent;\n  while (m && m !== toStateNode) {\n    ancestors.push(m);\n    m = m.parent;\n  }\n  return ancestors;\n}\nfunction getAllStateNodes(stateNodes) {\n  const nodeSet = new Set(stateNodes);\n  const adjList = getAdjList(nodeSet);\n\n  // add descendants\n  for (const s of nodeSet) {\n    // if previously active, add existing child nodes\n    if (s.type === 'compound' && (!adjList.get(s) || !adjList.get(s).length)) {\n      getInitialStateNodesWithTheirAncestors(s).forEach(sn => nodeSet.add(sn));\n    } else {\n      if (s.type === 'parallel') {\n        for (const child of getChildren(s)) {\n          if (child.type === 'history') {\n            continue;\n          }\n          if (!nodeSet.has(child)) {\n            const initialStates = getInitialStateNodesWithTheirAncestors(child);\n            for (const initialStateNode of initialStates) {\n              nodeSet.add(initialStateNode);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // add all ancestors\n  for (const s of nodeSet) {\n    let m = s.parent;\n    while (m) {\n      nodeSet.add(m);\n      m = m.parent;\n    }\n  }\n  return nodeSet;\n}\nfunction getValueFromAdj(baseNode, adjList) {\n  const childStateNodes = adjList.get(baseNode);\n  if (!childStateNodes) {\n    return {}; // todo: fix?\n  }\n  if (baseNode.type === 'compound') {\n    const childStateNode = childStateNodes[0];\n    if (childStateNode) {\n      if (isAtomicStateNode(childStateNode)) {\n        return childStateNode.key;\n      }\n    } else {\n      return {};\n    }\n  }\n  const stateValue = {};\n  for (const childStateNode of childStateNodes) {\n    stateValue[childStateNode.key] = getValueFromAdj(childStateNode, adjList);\n  }\n  return stateValue;\n}\nfunction getAdjList(stateNodes) {\n  const adjList = new Map();\n  for (const s of stateNodes) {\n    if (!adjList.has(s)) {\n      adjList.set(s, []);\n    }\n    if (s.parent) {\n      if (!adjList.has(s.parent)) {\n        adjList.set(s.parent, []);\n      }\n      adjList.get(s.parent).push(s);\n    }\n  }\n  return adjList;\n}\nfunction getStateValue(rootNode, stateNodes) {\n  const config = getAllStateNodes(stateNodes);\n  return getValueFromAdj(rootNode, getAdjList(config));\n}\nfunction isInFinalState(stateNodeSet, stateNode) {\n  if (stateNode.type === 'compound') {\n    return getChildren(stateNode).some(s => s.type === 'final' && stateNodeSet.has(s));\n  }\n  if (stateNode.type === 'parallel') {\n    return getChildren(stateNode).every(sn => isInFinalState(stateNodeSet, sn));\n  }\n  return stateNode.type === 'final';\n}\nconst isStateId = str => str[0] === STATE_IDENTIFIER;\nfunction getCandidates(stateNode, receivedEventType) {\n  const candidates = stateNode.transitions.get(receivedEventType) || [...stateNode.transitions.keys()].filter(eventDescriptor => {\n    // check if transition is a wildcard transition,\n    // which matches any non-transient events\n    if (eventDescriptor === WILDCARD) {\n      return true;\n    }\n    if (!eventDescriptor.endsWith('.*')) {\n      return false;\n    }\n    if (/.*\\*.+/.test(eventDescriptor)) {\n      console.warn(`Wildcards can only be the last token of an event descriptor (e.g., \"event.*\") or the entire event descriptor (\"*\"). Check the \"${eventDescriptor}\" event.`);\n    }\n    const partialEventTokens = eventDescriptor.split('.');\n    const eventTokens = receivedEventType.split('.');\n    for (let tokenIndex = 0; tokenIndex < partialEventTokens.length; tokenIndex++) {\n      const partialEventToken = partialEventTokens[tokenIndex];\n      const eventToken = eventTokens[tokenIndex];\n      if (partialEventToken === '*') {\n        const isLastToken = tokenIndex === partialEventTokens.length - 1;\n        if (!isLastToken) {\n          console.warn(`Infix wildcards in transition events are not allowed. Check the \"${eventDescriptor}\" transition.`);\n        }\n        return isLastToken;\n      }\n      if (partialEventToken !== eventToken) {\n        return false;\n      }\n    }\n    return true;\n  }).sort((a, b) => b.length - a.length).flatMap(key => stateNode.transitions.get(key));\n  return candidates;\n}\n\n/** All delayed transitions from the config. */\nfunction getDelayedTransitions(stateNode) {\n  const afterConfig = stateNode.config.after;\n  if (!afterConfig) {\n    return [];\n  }\n  const mutateEntryExit = (delay, i) => {\n    const afterEvent = createAfterEvent(delay, stateNode.id);\n    const eventType = afterEvent.type;\n    stateNode.entry.push(raise(afterEvent, {\n      id: eventType,\n      delay\n    }));\n    stateNode.exit.push(cancel(eventType));\n    return eventType;\n  };\n  const delayedTransitions = Object.keys(afterConfig).flatMap((delay, i) => {\n    const configTransition = afterConfig[delay];\n    const resolvedTransition = typeof configTransition === 'string' ? {\n      target: configTransition\n    } : configTransition;\n    const resolvedDelay = Number.isNaN(+delay) ? delay : +delay;\n    const eventType = mutateEntryExit(resolvedDelay);\n    return toArray(resolvedTransition).map(transition => ({\n      ...transition,\n      event: eventType,\n      delay: resolvedDelay\n    }));\n  });\n  return delayedTransitions.map(delayedTransition => {\n    const {\n      delay\n    } = delayedTransition;\n    return {\n      ...formatTransition(stateNode, delayedTransition.event, delayedTransition),\n      delay\n    };\n  });\n}\nfunction formatTransition(stateNode, descriptor, transitionConfig) {\n  const normalizedTarget = normalizeTarget(transitionConfig.target);\n  const reenter = transitionConfig.reenter ?? false;\n  const target = resolveTarget(stateNode, normalizedTarget);\n\n  // TODO: should this be part of a lint rule instead?\n  if (transitionConfig.cond) {\n    throw new Error(`State \"${stateNode.id}\" has declared \\`cond\\` for one of its transitions. This property has been renamed to \\`guard\\`. Please update your code.`);\n  }\n  const transition = {\n    ...transitionConfig,\n    actions: toArray(transitionConfig.actions),\n    guard: transitionConfig.guard,\n    target,\n    source: stateNode,\n    reenter,\n    eventType: descriptor,\n    toJSON: () => ({\n      ...transition,\n      source: `#${stateNode.id}`,\n      target: target ? target.map(t => `#${t.id}`) : undefined\n    })\n  };\n  return transition;\n}\nfunction formatTransitions(stateNode) {\n  const transitions = new Map();\n  if (stateNode.config.on) {\n    for (const descriptor of Object.keys(stateNode.config.on)) {\n      if (descriptor === NULL_EVENT) {\n        throw new Error('Null events (\"\") cannot be specified as a transition key. Use `always: { ... }` instead.');\n      }\n      const transitionsConfig = stateNode.config.on[descriptor];\n      transitions.set(descriptor, toTransitionConfigArray(transitionsConfig).map(t => formatTransition(stateNode, descriptor, t)));\n    }\n  }\n  if (stateNode.config.onDone) {\n    const descriptor = `xstate.done.state.${stateNode.id}`;\n    transitions.set(descriptor, toTransitionConfigArray(stateNode.config.onDone).map(t => formatTransition(stateNode, descriptor, t)));\n  }\n  for (const invokeDef of stateNode.invoke) {\n    if (invokeDef.onDone) {\n      const descriptor = `xstate.done.actor.${invokeDef.id}`;\n      transitions.set(descriptor, toTransitionConfigArray(invokeDef.onDone).map(t => formatTransition(stateNode, descriptor, t)));\n    }\n    if (invokeDef.onError) {\n      const descriptor = `xstate.error.actor.${invokeDef.id}`;\n      transitions.set(descriptor, toTransitionConfigArray(invokeDef.onError).map(t => formatTransition(stateNode, descriptor, t)));\n    }\n    if (invokeDef.onSnapshot) {\n      const descriptor = `xstate.snapshot.${invokeDef.id}`;\n      transitions.set(descriptor, toTransitionConfigArray(invokeDef.onSnapshot).map(t => formatTransition(stateNode, descriptor, t)));\n    }\n  }\n  for (const delayedTransition of stateNode.after) {\n    let existing = transitions.get(delayedTransition.eventType);\n    if (!existing) {\n      existing = [];\n      transitions.set(delayedTransition.eventType, existing);\n    }\n    existing.push(delayedTransition);\n  }\n  return transitions;\n}\nfunction formatInitialTransition(stateNode, _target) {\n  const resolvedTarget = typeof _target === 'string' ? stateNode.states[_target] : _target ? stateNode.states[_target.target] : undefined;\n  if (!resolvedTarget && _target) {\n    throw new Error(`Initial state node \"${_target}\" not found on parent state node #${stateNode.id}`);\n  }\n  const transition = {\n    source: stateNode,\n    actions: !_target || typeof _target === 'string' ? [] : toArray(_target.actions),\n    eventType: null,\n    reenter: false,\n    target: resolvedTarget ? [resolvedTarget] : [],\n    toJSON: () => ({\n      ...transition,\n      source: `#${stateNode.id}`,\n      target: resolvedTarget ? [`#${resolvedTarget.id}`] : []\n    })\n  };\n  return transition;\n}\nfunction resolveTarget(stateNode, targets) {\n  if (targets === undefined) {\n    // an undefined target signals that the state node should not transition from that state when receiving that event\n    return undefined;\n  }\n  return targets.map(target => {\n    if (typeof target !== 'string') {\n      return target;\n    }\n    if (isStateId(target)) {\n      return stateNode.machine.getStateNodeById(target);\n    }\n    const isInternalTarget = target[0] === STATE_DELIMITER;\n    // If internal target is defined on machine,\n    // do not include machine key on target\n    if (isInternalTarget && !stateNode.parent) {\n      return getStateNodeByPath(stateNode, target.slice(1));\n    }\n    const resolvedTarget = isInternalTarget ? stateNode.key + target : target;\n    if (stateNode.parent) {\n      try {\n        const targetStateNode = getStateNodeByPath(stateNode.parent, resolvedTarget);\n        return targetStateNode;\n      } catch (err) {\n        throw new Error(`Invalid transition definition for state node '${stateNode.id}':\\n${err.message}`);\n      }\n    } else {\n      throw new Error(`Invalid target: \"${target}\" is not a valid target from the root node. Did you mean \".${target}\"?`);\n    }\n  });\n}\nfunction resolveHistoryDefaultTransition(stateNode) {\n  const normalizedTarget = normalizeTarget(stateNode.config.target);\n  if (!normalizedTarget) {\n    return stateNode.parent.initial;\n  }\n  return {\n    target: normalizedTarget.map(t => typeof t === 'string' ? getStateNodeByPath(stateNode.parent, t) : t)\n  };\n}\nfunction isHistoryNode(stateNode) {\n  return stateNode.type === 'history';\n}\nfunction getInitialStateNodesWithTheirAncestors(stateNode) {\n  const states = getInitialStateNodes(stateNode);\n  for (const initialState of states) {\n    for (const ancestor of getProperAncestors(initialState, stateNode)) {\n      states.add(ancestor);\n    }\n  }\n  return states;\n}\nfunction getInitialStateNodes(stateNode) {\n  const set = new Set();\n  function iter(descStateNode) {\n    if (set.has(descStateNode)) {\n      return;\n    }\n    set.add(descStateNode);\n    if (descStateNode.type === 'compound') {\n      iter(descStateNode.initial.target[0]);\n    } else if (descStateNode.type === 'parallel') {\n      for (const child of getChildren(descStateNode)) {\n        iter(child);\n      }\n    }\n  }\n  iter(stateNode);\n  return set;\n}\n/** Returns the child state node from its relative `stateKey`, or throws. */\nfunction getStateNode(stateNode, stateKey) {\n  if (isStateId(stateKey)) {\n    return stateNode.machine.getStateNodeById(stateKey);\n  }\n  if (!stateNode.states) {\n    throw new Error(`Unable to retrieve child state '${stateKey}' from '${stateNode.id}'; no child states exist.`);\n  }\n  const result = stateNode.states[stateKey];\n  if (!result) {\n    throw new Error(`Child state '${stateKey}' does not exist on '${stateNode.id}'`);\n  }\n  return result;\n}\n\n/**\n * Returns the relative state node from the given `statePath`, or throws.\n *\n * @param statePath The string or string array relative path to the state node.\n */\nfunction getStateNodeByPath(stateNode, statePath) {\n  if (typeof statePath === 'string' && isStateId(statePath)) {\n    try {\n      return stateNode.machine.getStateNodeById(statePath);\n    } catch (e) {\n      // try individual paths\n      // throw e;\n    }\n  }\n  const arrayStatePath = toStatePath(statePath).slice();\n  let currentStateNode = stateNode;\n  while (arrayStatePath.length) {\n    const key = arrayStatePath.shift();\n    if (!key.length) {\n      break;\n    }\n    currentStateNode = getStateNode(currentStateNode, key);\n  }\n  return currentStateNode;\n}\n\n/**\n * Returns the state nodes represented by the current state value.\n *\n * @param stateValue The state value or State instance\n */\nfunction getStateNodes(stateNode, stateValue) {\n  if (typeof stateValue === 'string') {\n    const childStateNode = stateNode.states[stateValue];\n    if (!childStateNode) {\n      throw new Error(`State '${stateValue}' does not exist on '${stateNode.id}'`);\n    }\n    return [stateNode, childStateNode];\n  }\n  const childStateKeys = Object.keys(stateValue);\n  const childStateNodes = childStateKeys.map(subStateKey => getStateNode(stateNode, subStateKey)).filter(Boolean);\n  return [stateNode.machine.root, stateNode].concat(childStateNodes, childStateKeys.reduce((allSubStateNodes, subStateKey) => {\n    const subStateNode = getStateNode(stateNode, subStateKey);\n    if (!subStateNode) {\n      return allSubStateNodes;\n    }\n    const subStateNodes = getStateNodes(subStateNode, stateValue[subStateKey]);\n    return allSubStateNodes.concat(subStateNodes);\n  }, []));\n}\nfunction transitionAtomicNode(stateNode, stateValue, snapshot, event) {\n  const childStateNode = getStateNode(stateNode, stateValue);\n  const next = childStateNode.next(snapshot, event);\n  if (!next || !next.length) {\n    return stateNode.next(snapshot, event);\n  }\n  return next;\n}\nfunction transitionCompoundNode(stateNode, stateValue, snapshot, event) {\n  const subStateKeys = Object.keys(stateValue);\n  const childStateNode = getStateNode(stateNode, subStateKeys[0]);\n  const next = transitionNode(childStateNode, stateValue[subStateKeys[0]], snapshot, event);\n  if (!next || !next.length) {\n    return stateNode.next(snapshot, event);\n  }\n  return next;\n}\nfunction transitionParallelNode(stateNode, stateValue, snapshot, event) {\n  const allInnerTransitions = [];\n  for (const subStateKey of Object.keys(stateValue)) {\n    const subStateValue = stateValue[subStateKey];\n    if (!subStateValue) {\n      continue;\n    }\n    const subStateNode = getStateNode(stateNode, subStateKey);\n    const innerTransitions = transitionNode(subStateNode, subStateValue, snapshot, event);\n    if (innerTransitions) {\n      allInnerTransitions.push(...innerTransitions);\n    }\n  }\n  if (!allInnerTransitions.length) {\n    return stateNode.next(snapshot, event);\n  }\n  return allInnerTransitions;\n}\nfunction transitionNode(stateNode, stateValue, snapshot, event) {\n  // leaf node\n  if (typeof stateValue === 'string') {\n    return transitionAtomicNode(stateNode, stateValue, snapshot, event);\n  }\n\n  // compound node\n  if (Object.keys(stateValue).length === 1) {\n    return transitionCompoundNode(stateNode, stateValue, snapshot, event);\n  }\n\n  // parallel node\n  return transitionParallelNode(stateNode, stateValue, snapshot, event);\n}\nfunction getHistoryNodes(stateNode) {\n  return Object.keys(stateNode.states).map(key => stateNode.states[key]).filter(sn => sn.type === 'history');\n}\nfunction isDescendant(childStateNode, parentStateNode) {\n  let marker = childStateNode;\n  while (marker.parent && marker.parent !== parentStateNode) {\n    marker = marker.parent;\n  }\n  return marker.parent === parentStateNode;\n}\nfunction hasIntersection(s1, s2) {\n  const set1 = new Set(s1);\n  const set2 = new Set(s2);\n  for (const item of set1) {\n    if (set2.has(item)) {\n      return true;\n    }\n  }\n  for (const item of set2) {\n    if (set1.has(item)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction removeConflictingTransitions(enabledTransitions, stateNodeSet, historyValue) {\n  const filteredTransitions = new Set();\n  for (const t1 of enabledTransitions) {\n    let t1Preempted = false;\n    const transitionsToRemove = new Set();\n    for (const t2 of filteredTransitions) {\n      if (hasIntersection(computeExitSet([t1], stateNodeSet, historyValue), computeExitSet([t2], stateNodeSet, historyValue))) {\n        if (isDescendant(t1.source, t2.source)) {\n          transitionsToRemove.add(t2);\n        } else {\n          t1Preempted = true;\n          break;\n        }\n      }\n    }\n    if (!t1Preempted) {\n      for (const t3 of transitionsToRemove) {\n        filteredTransitions.delete(t3);\n      }\n      filteredTransitions.add(t1);\n    }\n  }\n  return Array.from(filteredTransitions);\n}\nfunction findLeastCommonAncestor(stateNodes) {\n  const [head, ...tail] = stateNodes;\n  for (const ancestor of getProperAncestors(head, undefined)) {\n    if (tail.every(sn => isDescendant(sn, ancestor))) {\n      return ancestor;\n    }\n  }\n}\nfunction getEffectiveTargetStates(transition, historyValue) {\n  if (!transition.target) {\n    return [];\n  }\n  const targets = new Set();\n  for (const targetNode of transition.target) {\n    if (isHistoryNode(targetNode)) {\n      if (historyValue[targetNode.id]) {\n        for (const node of historyValue[targetNode.id]) {\n          targets.add(node);\n        }\n      } else {\n        for (const node of getEffectiveTargetStates(resolveHistoryDefaultTransition(targetNode), historyValue)) {\n          targets.add(node);\n        }\n      }\n    } else {\n      targets.add(targetNode);\n    }\n  }\n  return [...targets];\n}\nfunction getTransitionDomain(transition, historyValue) {\n  const targetStates = getEffectiveTargetStates(transition, historyValue);\n  if (!targetStates) {\n    return;\n  }\n  if (!transition.reenter && targetStates.every(target => target === transition.source || isDescendant(target, transition.source))) {\n    return transition.source;\n  }\n  const lca = findLeastCommonAncestor(targetStates.concat(transition.source));\n  if (lca) {\n    return lca;\n  }\n\n  // at this point we know that it's a root transition since LCA couldn't be found\n  if (transition.reenter) {\n    return;\n  }\n  return transition.source.machine.root;\n}\nfunction computeExitSet(transitions, stateNodeSet, historyValue) {\n  const statesToExit = new Set();\n  for (const t of transitions) {\n    if (t.target?.length) {\n      const domain = getTransitionDomain(t, historyValue);\n      if (t.reenter && t.source === domain) {\n        statesToExit.add(domain);\n      }\n      for (const stateNode of stateNodeSet) {\n        if (isDescendant(stateNode, domain)) {\n          statesToExit.add(stateNode);\n        }\n      }\n    }\n  }\n  return [...statesToExit];\n}\nfunction areStateNodeCollectionsEqual(prevStateNodes, nextStateNodeSet) {\n  if (prevStateNodes.length !== nextStateNodeSet.size) {\n    return false;\n  }\n  for (const node of prevStateNodes) {\n    if (!nextStateNodeSet.has(node)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/** https://www.w3.org/TR/scxml/#microstepProcedure */\nfunction microstep(transitions, currentSnapshot, actorScope, event, isInitial, internalQueue) {\n  if (!transitions.length) {\n    return currentSnapshot;\n  }\n  const mutStateNodeSet = new Set(currentSnapshot._nodes);\n  let historyValue = currentSnapshot.historyValue;\n  const filteredTransitions = removeConflictingTransitions(transitions, mutStateNodeSet, historyValue);\n  let nextState = currentSnapshot;\n\n  // Exit states\n  if (!isInitial) {\n    [nextState, historyValue] = exitStates(nextState, event, actorScope, filteredTransitions, mutStateNodeSet, historyValue, internalQueue);\n  }\n\n  // Execute transition content\n  nextState = resolveActionsAndContext(nextState, event, actorScope, filteredTransitions.flatMap(t => t.actions), internalQueue);\n\n  // Enter states\n  nextState = enterStates(nextState, event, actorScope, filteredTransitions, mutStateNodeSet, internalQueue, historyValue, isInitial);\n  const nextStateNodes = [...mutStateNodeSet];\n  if (nextState.status === 'done') {\n    nextState = resolveActionsAndContext(nextState, event, actorScope, nextStateNodes.sort((a, b) => b.order - a.order).flatMap(state => state.exit), internalQueue);\n  }\n  try {\n    if (historyValue === currentSnapshot.historyValue && areStateNodeCollectionsEqual(currentSnapshot._nodes, mutStateNodeSet)) {\n      return nextState;\n    }\n    return cloneMachineSnapshot(nextState, {\n      _nodes: nextStateNodes,\n      historyValue\n    });\n  } catch (e) {\n    // TODO: Refactor this once proper error handling is implemented.\n    // See https://github.com/statelyai/rfcs/pull/4\n    throw e;\n  }\n}\nfunction getMachineOutput(snapshot, event, actorScope, rootNode, rootCompletionNode) {\n  if (rootNode.output === undefined) {\n    return;\n  }\n  const doneStateEvent = createDoneStateEvent(rootCompletionNode.id, rootCompletionNode.output !== undefined && rootCompletionNode.parent ? resolveOutput(rootCompletionNode.output, snapshot.context, event, actorScope.self) : undefined);\n  return resolveOutput(rootNode.output, snapshot.context, doneStateEvent, actorScope.self);\n}\nfunction enterStates(currentSnapshot, event, actorScope, filteredTransitions, mutStateNodeSet, internalQueue, historyValue, isInitial) {\n  let nextSnapshot = currentSnapshot;\n  const statesToEnter = new Set();\n  // those are states that were directly targeted or indirectly targeted by the explicit target\n  // in other words, those are states for which initial actions should be executed\n  // when we target `#deep_child` initial actions of its ancestors shouldn't be executed\n  const statesForDefaultEntry = new Set();\n  computeEntrySet(filteredTransitions, historyValue, statesForDefaultEntry, statesToEnter);\n\n  // In the initial state, the root state node is \"entered\".\n  if (isInitial) {\n    statesForDefaultEntry.add(currentSnapshot.machine.root);\n  }\n  const completedNodes = new Set();\n  for (const stateNodeToEnter of [...statesToEnter].sort((a, b) => a.order - b.order)) {\n    mutStateNodeSet.add(stateNodeToEnter);\n    const actions = [];\n\n    // Add entry actions\n    actions.push(...stateNodeToEnter.entry);\n    for (const invokeDef of stateNodeToEnter.invoke) {\n      actions.push(spawnChild(invokeDef.src, {\n        ...invokeDef,\n        syncSnapshot: !!invokeDef.onSnapshot\n      }));\n    }\n    if (statesForDefaultEntry.has(stateNodeToEnter)) {\n      const initialActions = stateNodeToEnter.initial.actions;\n      actions.push(...initialActions);\n    }\n    nextSnapshot = resolveActionsAndContext(nextSnapshot, event, actorScope, actions, internalQueue, stateNodeToEnter.invoke.map(invokeDef => invokeDef.id));\n    if (stateNodeToEnter.type === 'final') {\n      const parent = stateNodeToEnter.parent;\n      let ancestorMarker = parent?.type === 'parallel' ? parent : parent?.parent;\n      let rootCompletionNode = ancestorMarker || stateNodeToEnter;\n      if (parent?.type === 'compound') {\n        internalQueue.push(createDoneStateEvent(parent.id, stateNodeToEnter.output !== undefined ? resolveOutput(stateNodeToEnter.output, nextSnapshot.context, event, actorScope.self) : undefined));\n      }\n      while (ancestorMarker?.type === 'parallel' && !completedNodes.has(ancestorMarker) && isInFinalState(mutStateNodeSet, ancestorMarker)) {\n        completedNodes.add(ancestorMarker);\n        internalQueue.push(createDoneStateEvent(ancestorMarker.id));\n        rootCompletionNode = ancestorMarker;\n        ancestorMarker = ancestorMarker.parent;\n      }\n      if (ancestorMarker) {\n        continue;\n      }\n      nextSnapshot = cloneMachineSnapshot(nextSnapshot, {\n        status: 'done',\n        output: getMachineOutput(nextSnapshot, event, actorScope, nextSnapshot.machine.root, rootCompletionNode)\n      });\n    }\n  }\n  return nextSnapshot;\n}\nfunction computeEntrySet(transitions, historyValue, statesForDefaultEntry, statesToEnter) {\n  for (const t of transitions) {\n    const domain = getTransitionDomain(t, historyValue);\n    for (const s of t.target || []) {\n      if (!isHistoryNode(s) && (\n      // if the target is different than the source then it will *definitely* be entered\n      t.source !== s ||\n      // we know that the domain can't lie within the source\n      // if it's different than the source then it's outside of it and it means that the target has to be entered as well\n      t.source !== domain ||\n      // reentering transitions always enter the target, even if it's the source itself\n      t.reenter)) {\n        statesToEnter.add(s);\n        statesForDefaultEntry.add(s);\n      }\n      addDescendantStatesToEnter(s, historyValue, statesForDefaultEntry, statesToEnter);\n    }\n    const targetStates = getEffectiveTargetStates(t, historyValue);\n    for (const s of targetStates) {\n      const ancestors = getProperAncestors(s, domain);\n      if (domain?.type === 'parallel') {\n        ancestors.push(domain);\n      }\n      addAncestorStatesToEnter(statesToEnter, historyValue, statesForDefaultEntry, ancestors, !t.source.parent && t.reenter ? undefined : domain);\n    }\n  }\n}\nfunction addDescendantStatesToEnter(stateNode, historyValue, statesForDefaultEntry, statesToEnter) {\n  if (isHistoryNode(stateNode)) {\n    if (historyValue[stateNode.id]) {\n      const historyStateNodes = historyValue[stateNode.id];\n      for (const s of historyStateNodes) {\n        statesToEnter.add(s);\n        addDescendantStatesToEnter(s, historyValue, statesForDefaultEntry, statesToEnter);\n      }\n      for (const s of historyStateNodes) {\n        addProperAncestorStatesToEnter(s, stateNode.parent, statesToEnter, historyValue, statesForDefaultEntry);\n      }\n    } else {\n      const historyDefaultTransition = resolveHistoryDefaultTransition(stateNode);\n      for (const s of historyDefaultTransition.target) {\n        statesToEnter.add(s);\n        if (historyDefaultTransition === stateNode.parent?.initial) {\n          statesForDefaultEntry.add(stateNode.parent);\n        }\n        addDescendantStatesToEnter(s, historyValue, statesForDefaultEntry, statesToEnter);\n      }\n      for (const s of historyDefaultTransition.target) {\n        addProperAncestorStatesToEnter(s, stateNode.parent, statesToEnter, historyValue, statesForDefaultEntry);\n      }\n    }\n  } else {\n    if (stateNode.type === 'compound') {\n      const [initialState] = stateNode.initial.target;\n      if (!isHistoryNode(initialState)) {\n        statesToEnter.add(initialState);\n        statesForDefaultEntry.add(initialState);\n      }\n      addDescendantStatesToEnter(initialState, historyValue, statesForDefaultEntry, statesToEnter);\n      addProperAncestorStatesToEnter(initialState, stateNode, statesToEnter, historyValue, statesForDefaultEntry);\n    } else {\n      if (stateNode.type === 'parallel') {\n        for (const child of getChildren(stateNode).filter(sn => !isHistoryNode(sn))) {\n          if (![...statesToEnter].some(s => isDescendant(s, child))) {\n            if (!isHistoryNode(child)) {\n              statesToEnter.add(child);\n              statesForDefaultEntry.add(child);\n            }\n            addDescendantStatesToEnter(child, historyValue, statesForDefaultEntry, statesToEnter);\n          }\n        }\n      }\n    }\n  }\n}\nfunction addAncestorStatesToEnter(statesToEnter, historyValue, statesForDefaultEntry, ancestors, reentrancyDomain) {\n  for (const anc of ancestors) {\n    if (!reentrancyDomain || isDescendant(anc, reentrancyDomain)) {\n      statesToEnter.add(anc);\n    }\n    if (anc.type === 'parallel') {\n      for (const child of getChildren(anc).filter(sn => !isHistoryNode(sn))) {\n        if (![...statesToEnter].some(s => isDescendant(s, child))) {\n          statesToEnter.add(child);\n          addDescendantStatesToEnter(child, historyValue, statesForDefaultEntry, statesToEnter);\n        }\n      }\n    }\n  }\n}\nfunction addProperAncestorStatesToEnter(stateNode, toStateNode, statesToEnter, historyValue, statesForDefaultEntry) {\n  addAncestorStatesToEnter(statesToEnter, historyValue, statesForDefaultEntry, getProperAncestors(stateNode, toStateNode));\n}\nfunction exitStates(currentSnapshot, event, actorScope, transitions, mutStateNodeSet, historyValue, internalQueue) {\n  let nextSnapshot = currentSnapshot;\n  const statesToExit = computeExitSet(transitions, mutStateNodeSet, historyValue);\n  statesToExit.sort((a, b) => b.order - a.order);\n  let changedHistory;\n\n  // From SCXML algorithm: https://www.w3.org/TR/scxml/#exitStates\n  for (const exitStateNode of statesToExit) {\n    for (const historyNode of getHistoryNodes(exitStateNode)) {\n      let predicate;\n      if (historyNode.history === 'deep') {\n        predicate = sn => isAtomicStateNode(sn) && isDescendant(sn, exitStateNode);\n      } else {\n        predicate = sn => {\n          return sn.parent === exitStateNode;\n        };\n      }\n      changedHistory ??= {\n        ...historyValue\n      };\n      changedHistory[historyNode.id] = Array.from(mutStateNodeSet).filter(predicate);\n    }\n  }\n  for (const s of statesToExit) {\n    nextSnapshot = resolveActionsAndContext(nextSnapshot, event, actorScope, [...s.exit, ...s.invoke.map(def => stopChild(def.id))], internalQueue);\n    mutStateNodeSet.delete(s);\n  }\n  return [nextSnapshot, changedHistory || historyValue];\n}\nlet executingCustomAction = false;\nfunction resolveAndExecuteActionsWithContext(currentSnapshot, event, actorScope, actions, extra, retries) {\n  const {\n    machine\n  } = currentSnapshot;\n  let intermediateSnapshot = currentSnapshot;\n  for (const action of actions) {\n    const isInline = typeof action === 'function';\n    const resolvedAction = isInline ? action :\n    // the existing type of `.actions` assumes non-nullable `TExpressionAction`\n    // it's fine to cast this here to get a common type and lack of errors in the rest of the code\n    // our logic below makes sure that we call those 2 \"variants\" correctly\n    machine.implementations.actions[typeof action === 'string' ? action : action.type];\n    if (!resolvedAction) {\n      continue;\n    }\n    const actionArgs = {\n      context: intermediateSnapshot.context,\n      event,\n      self: actorScope.self,\n      system: actorScope.system\n    };\n    const actionParams = isInline || typeof action === 'string' ? undefined : 'params' in action ? typeof action.params === 'function' ? action.params({\n      context: intermediateSnapshot.context,\n      event\n    }) : action.params : undefined;\n    function executeAction() {\n      actorScope.system._sendInspectionEvent({\n        type: '@xstate.action',\n        actorRef: actorScope.self,\n        action: {\n          type: typeof action === 'string' ? action : typeof action === 'object' ? action.type : action.name || '(anonymous)',\n          params: actionParams\n        }\n      });\n      try {\n        executingCustomAction = resolvedAction;\n        resolvedAction(actionArgs, actionParams);\n      } finally {\n        executingCustomAction = false;\n      }\n    }\n    if (!('resolve' in resolvedAction)) {\n      if (actorScope.self._processingStatus === ProcessingStatus.Running) {\n        executeAction();\n      } else {\n        actorScope.defer(() => {\n          executeAction();\n        });\n      }\n      continue;\n    }\n    const builtinAction = resolvedAction;\n    const [nextState, params, actions] = builtinAction.resolve(actorScope, intermediateSnapshot, actionArgs, actionParams, resolvedAction,\n    // this holds all params\n    extra);\n    intermediateSnapshot = nextState;\n    if ('retryResolve' in builtinAction) {\n      retries?.push([builtinAction, params]);\n    }\n    if ('execute' in builtinAction) {\n      if (actorScope.self._processingStatus === ProcessingStatus.Running) {\n        builtinAction.execute(actorScope, params);\n      } else {\n        actorScope.defer(builtinAction.execute.bind(null, actorScope, params));\n      }\n    }\n    if (actions) {\n      intermediateSnapshot = resolveAndExecuteActionsWithContext(intermediateSnapshot, event, actorScope, actions, extra, retries);\n    }\n  }\n  return intermediateSnapshot;\n}\nfunction resolveActionsAndContext(currentSnapshot, event, actorScope, actions, internalQueue, deferredActorIds) {\n  const retries = deferredActorIds ? [] : undefined;\n  const nextState = resolveAndExecuteActionsWithContext(currentSnapshot, event, actorScope, actions, {\n    internalQueue,\n    deferredActorIds\n  }, retries);\n  retries?.forEach(([builtinAction, params]) => {\n    builtinAction.retryResolve(actorScope, nextState, params);\n  });\n  return nextState;\n}\nfunction macrostep(snapshot, event, actorScope, internalQueue = []) {\n  if (event.type === WILDCARD) {\n    throw new Error(`An event cannot have the wildcard type ('${WILDCARD}')`);\n  }\n  let nextSnapshot = snapshot;\n  const microstates = [];\n  function addMicrostate(microstate, event, transitions) {\n    actorScope.system._sendInspectionEvent({\n      type: '@xstate.microstep',\n      actorRef: actorScope.self,\n      event,\n      snapshot: microstate,\n      _transitions: transitions\n    });\n    microstates.push(microstate);\n  }\n\n  // Handle stop event\n  if (event.type === XSTATE_STOP) {\n    nextSnapshot = cloneMachineSnapshot(stopChildren(nextSnapshot, event, actorScope), {\n      status: 'stopped'\n    });\n    addMicrostate(nextSnapshot, event, []);\n    return {\n      snapshot: nextSnapshot,\n      microstates\n    };\n  }\n  let nextEvent = event;\n\n  // Assume the state is at rest (no raised events)\n  // Determine the next state based on the next microstep\n  if (nextEvent.type !== XSTATE_INIT) {\n    const currentEvent = nextEvent;\n    const isErr = isErrorActorEvent(currentEvent);\n    const transitions = selectTransitions(currentEvent, nextSnapshot);\n    if (isErr && !transitions.length) {\n      // TODO: we should likely only allow transitions selected by very explicit descriptors\n      // `*` shouldn't be matched, likely `xstate.error.*` shouldnt be either\n      // similarly `xstate.error.actor.*` and `xstate.error.actor.todo.*` have to be considered too\n      nextSnapshot = cloneMachineSnapshot(snapshot, {\n        status: 'error',\n        error: currentEvent.error\n      });\n      addMicrostate(nextSnapshot, currentEvent, []);\n      return {\n        snapshot: nextSnapshot,\n        microstates\n      };\n    }\n    nextSnapshot = microstep(transitions, snapshot, actorScope, nextEvent, false,\n    // isInitial\n    internalQueue);\n    addMicrostate(nextSnapshot, currentEvent, transitions);\n  }\n  let shouldSelectEventlessTransitions = true;\n  while (nextSnapshot.status === 'active') {\n    let enabledTransitions = shouldSelectEventlessTransitions ? selectEventlessTransitions(nextSnapshot, nextEvent) : [];\n\n    // eventless transitions should always be selected after selecting *regular* transitions\n    // by assigning `undefined` to `previousState` we ensure that `shouldSelectEventlessTransitions` gets always computed to true in such a case\n    const previousState = enabledTransitions.length ? nextSnapshot : undefined;\n    if (!enabledTransitions.length) {\n      if (!internalQueue.length) {\n        break;\n      }\n      nextEvent = internalQueue.shift();\n      enabledTransitions = selectTransitions(nextEvent, nextSnapshot);\n    }\n    nextSnapshot = microstep(enabledTransitions, nextSnapshot, actorScope, nextEvent, false, internalQueue);\n    shouldSelectEventlessTransitions = nextSnapshot !== previousState;\n    addMicrostate(nextSnapshot, nextEvent, enabledTransitions);\n  }\n  if (nextSnapshot.status !== 'active') {\n    stopChildren(nextSnapshot, nextEvent, actorScope);\n  }\n  return {\n    snapshot: nextSnapshot,\n    microstates\n  };\n}\nfunction stopChildren(nextState, event, actorScope) {\n  return resolveActionsAndContext(nextState, event, actorScope, Object.values(nextState.children).map(child => stopChild(child)), []);\n}\nfunction selectTransitions(event, nextState) {\n  return nextState.machine.getTransitionData(nextState, event);\n}\nfunction selectEventlessTransitions(nextState, event) {\n  const enabledTransitionSet = new Set();\n  const atomicStates = nextState._nodes.filter(isAtomicStateNode);\n  for (const stateNode of atomicStates) {\n    loop: for (const s of [stateNode].concat(getProperAncestors(stateNode, undefined))) {\n      if (!s.always) {\n        continue;\n      }\n      for (const transition of s.always) {\n        if (transition.guard === undefined || evaluateGuard(transition.guard, nextState.context, event, nextState)) {\n          enabledTransitionSet.add(transition);\n          break loop;\n        }\n      }\n    }\n  }\n  return removeConflictingTransitions(Array.from(enabledTransitionSet), new Set(nextState._nodes), nextState.historyValue);\n}\n\n/**\n * Resolves a partial state value with its full representation in the state\n * node's machine.\n *\n * @param stateValue The partial state value to resolve.\n */\nfunction resolveStateValue(rootNode, stateValue) {\n  const allStateNodes = getAllStateNodes(getStateNodes(rootNode, stateValue));\n  return getStateValue(rootNode, [...allStateNodes]);\n}\n\nfunction isMachineSnapshot(value) {\n  return !!value && typeof value === 'object' && 'machine' in value && 'value' in value;\n}\nconst machineSnapshotMatches = function matches(testValue) {\n  return matchesState(testValue, this.value);\n};\nconst machineSnapshotHasTag = function hasTag(tag) {\n  return this.tags.has(tag);\n};\nconst machineSnapshotCan = function can(event) {\n  if (!this.machine) {\n    console.warn(`state.can(...) used outside of a machine-created State object; this will always return false.`);\n  }\n  const transitionData = this.machine.getTransitionData(this, event);\n  return !!transitionData?.length &&\n  // Check that at least one transition is not forbidden\n  transitionData.some(t => t.target !== undefined || t.actions.length);\n};\nconst machineSnapshotToJSON = function toJSON() {\n  const {\n    _nodes: nodes,\n    tags,\n    machine,\n    getMeta,\n    toJSON,\n    can,\n    hasTag,\n    matches,\n    ...jsonValues\n  } = this;\n  return {\n    ...jsonValues,\n    tags: Array.from(tags)\n  };\n};\nconst machineSnapshotGetMeta = function getMeta() {\n  return this._nodes.reduce((acc, stateNode) => {\n    if (stateNode.meta !== undefined) {\n      acc[stateNode.id] = stateNode.meta;\n    }\n    return acc;\n  }, {});\n};\nfunction createMachineSnapshot(config, machine) {\n  return {\n    status: config.status,\n    output: config.output,\n    error: config.error,\n    machine,\n    context: config.context,\n    _nodes: config._nodes,\n    value: getStateValue(machine.root, config._nodes),\n    tags: new Set(config._nodes.flatMap(sn => sn.tags)),\n    children: config.children,\n    historyValue: config.historyValue || {},\n    matches: machineSnapshotMatches,\n    hasTag: machineSnapshotHasTag,\n    can: machineSnapshotCan,\n    getMeta: machineSnapshotGetMeta,\n    toJSON: machineSnapshotToJSON\n  };\n}\nfunction cloneMachineSnapshot(snapshot, config = {}) {\n  return createMachineSnapshot({\n    ...snapshot,\n    ...config\n  }, snapshot.machine);\n}\nfunction getPersistedSnapshot(snapshot, options) {\n  const {\n    _nodes: nodes,\n    tags,\n    machine,\n    children,\n    context,\n    can,\n    hasTag,\n    matches,\n    getMeta,\n    toJSON,\n    ...jsonValues\n  } = snapshot;\n  const childrenJson = {};\n  for (const id in children) {\n    const child = children[id];\n    if (typeof child.src !== 'string' && (!options || !('__unsafeAllowInlineActors' in options))) {\n      throw new Error('An inline child actor cannot be persisted.');\n    }\n    childrenJson[id] = {\n      snapshot: child.getPersistedSnapshot(options),\n      src: child.src,\n      systemId: child._systemId,\n      syncSnapshot: child._syncSnapshot\n    };\n  }\n  const persisted = {\n    ...jsonValues,\n    context: persistContext(context),\n    children: childrenJson\n  };\n  return persisted;\n}\nfunction persistContext(contextPart) {\n  let copy;\n  for (const key in contextPart) {\n    const value = contextPart[key];\n    if (value && typeof value === 'object') {\n      if ('sessionId' in value && 'send' in value && 'ref' in value) {\n        copy ??= Array.isArray(contextPart) ? contextPart.slice() : {\n          ...contextPart\n        };\n        copy[key] = {\n          xstate$$type: $$ACTOR_TYPE,\n          id: value.id\n        };\n      } else {\n        const result = persistContext(value);\n        if (result !== value) {\n          copy ??= Array.isArray(contextPart) ? contextPart.slice() : {\n            ...contextPart\n          };\n          copy[key] = result;\n        }\n      }\n    }\n  }\n  return copy ?? contextPart;\n}\n\nfunction resolveRaise(_, snapshot, args, actionParams, {\n  event: eventOrExpr,\n  id,\n  delay\n}, {\n  internalQueue\n}) {\n  const delaysMap = snapshot.machine.implementations.delays;\n  if (typeof eventOrExpr === 'string') {\n    throw new Error(`Only event objects may be used with raise; use raise({ type: \"${eventOrExpr}\" }) instead`);\n  }\n  const resolvedEvent = typeof eventOrExpr === 'function' ? eventOrExpr(args, actionParams) : eventOrExpr;\n  let resolvedDelay;\n  if (typeof delay === 'string') {\n    const configDelay = delaysMap && delaysMap[delay];\n    resolvedDelay = typeof configDelay === 'function' ? configDelay(args, actionParams) : configDelay;\n  } else {\n    resolvedDelay = typeof delay === 'function' ? delay(args, actionParams) : delay;\n  }\n  if (typeof resolvedDelay !== 'number') {\n    internalQueue.push(resolvedEvent);\n  }\n  return [snapshot, {\n    event: resolvedEvent,\n    id,\n    delay: resolvedDelay\n  }];\n}\nfunction executeRaise(actorScope, params) {\n  const {\n    event,\n    delay,\n    id\n  } = params;\n  if (typeof delay === 'number') {\n    actorScope.defer(() => {\n      const self = actorScope.self;\n      actorScope.system.scheduler.schedule(self, self, event, delay, id);\n    });\n    return;\n  }\n}\n/**\n * Raises an event. This places the event in the internal event queue, so that\n * the event is immediately consumed by the machine in the current step.\n *\n * @param eventType The event to raise.\n */\nfunction raise(eventOrExpr, options) {\n  if (executingCustomAction) {\n    console.warn('Custom actions should not call `raise()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.');\n  }\n  function raise(args, params) {\n    {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n  raise.type = 'xstate.raise';\n  raise.event = eventOrExpr;\n  raise.id = options?.id;\n  raise.delay = options?.delay;\n  raise.resolve = resolveRaise;\n  raise.execute = executeRaise;\n  return raise;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy94c3RhdGUvZGlzdC9yYWlzZS01ZWE3MWYwNC5kZXZlbG9wbWVudC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNEU7O0FBRTVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFNBQVMsR0FBRyxHQUFHO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEdBQUc7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsU0FBUztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsR0FBRztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyQkFBMkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esc09BQXNPLDJHQUEyRyxJQUFJLElBQUksdUNBQXVDLFlBQVk7QUFDNVk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNLEdBQUcsWUFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxtQkFBbUIsR0FBRyxHQUFHO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsU0FBUztBQUMxRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxVQUFVLEtBQUssU0FBUztBQUM3RTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsOENBQThDLGtCQUFrQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsV0FBVywrQkFBK0IsU0FB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QTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsK0NBQStDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLFNBQVM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUY7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGdFQUFnRSxZQUFZLFNBQVMsWUFBWSxHQUFHO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWtqQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMveHN0YXRlL2Rpc3QvcmFpc2UtNWVhNzFmMDQuZGV2ZWxvcG1lbnQuZXNtLmpzP2ExM2EiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGV2VG9vbHNBZGFwdGVyIH0gZnJvbSAnLi4vZGV2L2Rpc3QveHN0YXRlLWRldi5kZXZlbG9wbWVudC5lc20uanMnO1xuXG5jbGFzcyBNYWlsYm94IHtcbiAgY29uc3RydWN0b3IoX3Byb2Nlc3MpIHtcbiAgICB0aGlzLl9wcm9jZXNzID0gX3Byb2Nlc3M7XG4gICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5fY3VycmVudCA9IG51bGw7XG4gICAgdGhpcy5fbGFzdCA9IG51bGw7XG4gIH1cbiAgc3RhcnQoKSB7XG4gICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLmZsdXNoKCk7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgLy8gd2UgY2FuJ3Qgc2V0IF9jdXJyZW50IHRvIG51bGwgYmVjYXVzZSB3ZSBtaWdodCBiZSBjdXJyZW50bHkgcHJvY2Vzc2luZ1xuICAgIC8vIGFuZCBlbnF1ZXVlIGZvbGxvd2luZyBjbGVhciBzaG91bGRudCBzdGFydCBwcm9jZXNzaW5nIHRoZSBlbnF1ZXVlZCBpdGVtIGltbWVkaWF0ZWx5XG4gICAgaWYgKHRoaXMuX2N1cnJlbnQpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnQubmV4dCA9IG51bGw7XG4gICAgICB0aGlzLl9sYXN0ID0gdGhpcy5fY3VycmVudDtcbiAgICB9XG4gIH1cbiAgZW5xdWV1ZShldmVudCkge1xuICAgIGNvbnN0IGVucXVldWVkID0ge1xuICAgICAgdmFsdWU6IGV2ZW50LFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG4gICAgaWYgKHRoaXMuX2N1cnJlbnQpIHtcbiAgICAgIHRoaXMuX2xhc3QubmV4dCA9IGVucXVldWVkO1xuICAgICAgdGhpcy5fbGFzdCA9IGVucXVldWVkO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9jdXJyZW50ID0gZW5xdWV1ZWQ7XG4gICAgdGhpcy5fbGFzdCA9IGVucXVldWVkO1xuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9XG4gIH1cbiAgZmx1c2goKSB7XG4gICAgd2hpbGUgKHRoaXMuX2N1cnJlbnQpIHtcbiAgICAgIC8vIGF0bSB0aGUgZ2l2ZW4gX3Byb2Nlc3MgaXMgcmVzcG9uc2libGUgZm9yIGltcGxlbWVudGluZyBwcm9wZXIgdHJ5L2NhdGNoIGhhbmRsaW5nXG4gICAgICAvLyB3ZSBhc3N1bWUgaGVyZSB0aGF0IHRoaXMgd29uJ3QgdGhyb3cgaW4gYSB3YXkgdGhhdCBjYW4gYWZmZWN0IHRoaXMgbWFpbGJveFxuICAgICAgY29uc3QgY29uc3VtZWQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgdGhpcy5fcHJvY2Vzcyhjb25zdW1lZC52YWx1ZSk7XG4gICAgICB0aGlzLl9jdXJyZW50ID0gY29uc3VtZWQubmV4dDtcbiAgICB9XG4gICAgdGhpcy5fbGFzdCA9IG51bGw7XG4gIH1cbn1cblxuY29uc3QgU1RBVEVfREVMSU1JVEVSID0gJy4nO1xuY29uc3QgVEFSR0VUTEVTU19LRVkgPSAnJztcbmNvbnN0IE5VTExfRVZFTlQgPSAnJztcbmNvbnN0IFNUQVRFX0lERU5USUZJRVIgPSAnIyc7XG5jb25zdCBXSUxEQ0FSRCA9ICcqJztcbmNvbnN0IFhTVEFURV9JTklUID0gJ3hzdGF0ZS5pbml0JztcbmNvbnN0IFhTVEFURV9FUlJPUiA9ICd4c3RhdGUuZXJyb3InO1xuY29uc3QgWFNUQVRFX1NUT1AgPSAneHN0YXRlLnN0b3AnO1xuXG4vKipcbiAqIFJldHVybnMgYW4gZXZlbnQgdGhhdCByZXByZXNlbnRzIGFuIGltcGxpY2l0IGV2ZW50IHRoYXQgaXMgc2VudCBhZnRlciB0aGVcbiAqIHNwZWNpZmllZCBgZGVsYXlgLlxuICpcbiAqIEBwYXJhbSBkZWxheVJlZiBUaGUgZGVsYXkgaW4gbWlsbGlzZWNvbmRzXG4gKiBAcGFyYW0gaWQgVGhlIHN0YXRlIG5vZGUgSUQgd2hlcmUgdGhpcyBldmVudCBpcyBoYW5kbGVkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFmdGVyRXZlbnQoZGVsYXlSZWYsIGlkKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogYHhzdGF0ZS5hZnRlci4ke2RlbGF5UmVmfS4ke2lkfWBcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGV2ZW50IHRoYXQgcmVwcmVzZW50cyB0aGF0IGEgZmluYWwgc3RhdGUgbm9kZSBoYXMgYmVlbiByZWFjaGVkIGluXG4gKiB0aGUgcGFyZW50IHN0YXRlIG5vZGUuXG4gKlxuICogQHBhcmFtIGlkIFRoZSBmaW5hbCBzdGF0ZSBub2RlJ3MgcGFyZW50IHN0YXRlIG5vZGUgYGlkYFxuICogQHBhcmFtIG91dHB1dCBUaGUgZGF0YSB0byBwYXNzIGludG8gdGhlIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURvbmVTdGF0ZUV2ZW50KGlkLCBvdXRwdXQpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBgeHN0YXRlLmRvbmUuc3RhdGUuJHtpZH1gLFxuICAgIG91dHB1dFxuICB9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gZXZlbnQgdGhhdCByZXByZXNlbnRzIHRoYXQgYW4gaW52b2tlZCBzZXJ2aWNlIGhhcyB0ZXJtaW5hdGVkLlxuICpcbiAqIEFuIGludm9rZWQgc2VydmljZSBpcyB0ZXJtaW5hdGVkIHdoZW4gaXQgaGFzIHJlYWNoZWQgYSB0b3AtbGV2ZWwgZmluYWwgc3RhdGVcbiAqIG5vZGUsIGJ1dCBub3Qgd2hlbiBpdCBpcyBjYW5jZWxlZC5cbiAqXG4gKiBAcGFyYW0gaW52b2tlSWQgVGhlIGludm9rZWQgc2VydmljZSBJRFxuICogQHBhcmFtIG91dHB1dCBUaGUgZGF0YSB0byBwYXNzIGludG8gdGhlIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURvbmVBY3RvckV2ZW50KGludm9rZUlkLCBvdXRwdXQpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBgeHN0YXRlLmRvbmUuYWN0b3IuJHtpbnZva2VJZH1gLFxuICAgIG91dHB1dCxcbiAgICBhY3RvcklkOiBpbnZva2VJZFxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlRXJyb3JBY3RvckV2ZW50KGlkLCBlcnJvcikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IGB4c3RhdGUuZXJyb3IuYWN0b3IuJHtpZH1gLFxuICAgIGVycm9yLFxuICAgIGFjdG9ySWQ6IGlkXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVJbml0RXZlbnQoaW5wdXQpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBYU1RBVEVfSU5JVCxcbiAgICBpbnB1dFxuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gbWFrZXMgc3VyZSB0aGF0IHVuaGFuZGxlZCBlcnJvcnMgYXJlIHRocm93biBpbiBhIHNlcGFyYXRlXG4gKiBtYWNyb3Rhc2suIEl0IGFsbG93cyB0aG9zZSBlcnJvcnMgdG8gYmUgZGV0ZWN0ZWQgYnkgZ2xvYmFsIGVycm9yIGhhbmRsZXJzIGFuZFxuICogcmVwb3J0ZWQgdG8gYnVnIHRyYWNraW5nIHNlcnZpY2VzIHdpdGhvdXQgaW50ZXJydXB0aW5nIG91ciBvd24gc3RhY2sgb2ZcbiAqIGV4ZWN1dGlvbi5cbiAqXG4gKiBAcGFyYW0gZXJyIEVycm9yIHRvIGJlIHRocm93blxuICovXG5mdW5jdGlvbiByZXBvcnRVbmhhbmRsZWRFcnJvcihlcnIpIHtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgdGhyb3cgZXJyO1xuICB9KTtcbn1cblxuY29uc3Qgc3ltYm9sT2JzZXJ2YWJsZSA9ICgoKSA9PiB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5vYnNlcnZhYmxlIHx8ICdAQG9ic2VydmFibGUnKSgpO1xuXG5mdW5jdGlvbiBtYXRjaGVzU3RhdGUocGFyZW50U3RhdGVJZCwgY2hpbGRTdGF0ZUlkKSB7XG4gIGNvbnN0IHBhcmVudFN0YXRlVmFsdWUgPSB0b1N0YXRlVmFsdWUocGFyZW50U3RhdGVJZCk7XG4gIGNvbnN0IGNoaWxkU3RhdGVWYWx1ZSA9IHRvU3RhdGVWYWx1ZShjaGlsZFN0YXRlSWQpO1xuICBpZiAodHlwZW9mIGNoaWxkU3RhdGVWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHBhcmVudFN0YXRlVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gY2hpbGRTdGF0ZVZhbHVlID09PSBwYXJlbnRTdGF0ZVZhbHVlO1xuICAgIH1cblxuICAgIC8vIFBhcmVudCBtb3JlIHNwZWNpZmljIHRoYW4gY2hpbGRcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBwYXJlbnRTdGF0ZVZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXJlbnRTdGF0ZVZhbHVlIGluIGNoaWxkU3RhdGVWYWx1ZTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmtleXMocGFyZW50U3RhdGVWYWx1ZSkuZXZlcnkoa2V5ID0+IHtcbiAgICBpZiAoIShrZXkgaW4gY2hpbGRTdGF0ZVZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hlc1N0YXRlKHBhcmVudFN0YXRlVmFsdWVba2V5XSwgY2hpbGRTdGF0ZVZhbHVlW2tleV0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHRvU3RhdGVQYXRoKHN0YXRlSWQpIHtcbiAgaWYgKGlzQXJyYXkoc3RhdGVJZCkpIHtcbiAgICByZXR1cm4gc3RhdGVJZDtcbiAgfVxuICBsZXQgcmVzdWx0ID0gW107XG4gIGxldCBzZWdtZW50ID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGVJZC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoYXIgPSBzdGF0ZUlkLmNoYXJDb2RlQXQoaSk7XG4gICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAvLyBcXFxuICAgICAgY2FzZSA5MjpcbiAgICAgICAgLy8gY29uc3VtZSB0aGUgbmV4dCBjaGFyYWN0ZXJcbiAgICAgICAgc2VnbWVudCArPSBzdGF0ZUlkW2kgKyAxXTtcbiAgICAgICAgLy8gYW5kIHNraXAgb3ZlciBpdFxuICAgICAgICBpKys7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgLy8gLlxuICAgICAgY2FzZSA0NjpcbiAgICAgICAgcmVzdWx0LnB1c2goc2VnbWVudCk7XG4gICAgICAgIHNlZ21lbnQgPSAnJztcbiAgICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHNlZ21lbnQgKz0gc3RhdGVJZFtpXTtcbiAgfVxuICByZXN1bHQucHVzaChzZWdtZW50KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHRvU3RhdGVWYWx1ZShzdGF0ZVZhbHVlKSB7XG4gIGlmIChpc01hY2hpbmVTbmFwc2hvdChzdGF0ZVZhbHVlKSkge1xuICAgIHJldHVybiBzdGF0ZVZhbHVlLnZhbHVlO1xuICB9XG4gIGlmICh0eXBlb2Ygc3RhdGVWYWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gc3RhdGVWYWx1ZTtcbiAgfVxuICBjb25zdCBzdGF0ZVBhdGggPSB0b1N0YXRlUGF0aChzdGF0ZVZhbHVlKTtcbiAgcmV0dXJuIHBhdGhUb1N0YXRlVmFsdWUoc3RhdGVQYXRoKTtcbn1cbmZ1bmN0aW9uIHBhdGhUb1N0YXRlVmFsdWUoc3RhdGVQYXRoKSB7XG4gIGlmIChzdGF0ZVBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHN0YXRlUGF0aFswXTtcbiAgfVxuICBjb25zdCB2YWx1ZSA9IHt9O1xuICBsZXQgbWFya2VyID0gdmFsdWU7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGVQYXRoLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGlmIChpID09PSBzdGF0ZVBhdGgubGVuZ3RoIC0gMikge1xuICAgICAgbWFya2VyW3N0YXRlUGF0aFtpXV0gPSBzdGF0ZVBhdGhbaSArIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwcmV2aW91cyA9IG1hcmtlcjtcbiAgICAgIG1hcmtlciA9IHt9O1xuICAgICAgcHJldmlvdXNbc3RhdGVQYXRoW2ldXSA9IG1hcmtlcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gbWFwVmFsdWVzKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBjb25zdCBjb2xsZWN0aW9uS2V5cyA9IE9iamVjdC5rZXlzKGNvbGxlY3Rpb24pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbGxlY3Rpb25LZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0gY29sbGVjdGlvbktleXNbaV07XG4gICAgcmVzdWx0W2tleV0gPSBpdGVyYXRlZShjb2xsZWN0aW9uW2tleV0sIGtleSwgY29sbGVjdGlvbiwgaSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHRvQXJyYXlTdHJpY3QodmFsdWUpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBbdmFsdWVdO1xufVxuZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gdG9BcnJheVN0cmljdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiByZXNvbHZlT3V0cHV0KG1hcHBlciwgY29udGV4dCwgZXZlbnQsIHNlbGYpIHtcbiAgaWYgKHR5cGVvZiBtYXBwZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWFwcGVyKHtcbiAgICAgIGNvbnRleHQsXG4gICAgICBldmVudCxcbiAgICAgIHNlbGZcbiAgICB9KTtcbiAgfVxuICBpZiAoISFtYXBwZXIgJiYgdHlwZW9mIG1hcHBlciA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LnZhbHVlcyhtYXBwZXIpLnNvbWUodmFsID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgY29uc29sZS53YXJuKGBEeW5hbWljYWxseSBtYXBwaW5nIHZhbHVlcyB0byBpbmRpdmlkdWFsIHByb3BlcnRpZXMgaXMgZGVwcmVjYXRlZC4gVXNlIGEgc2luZ2xlIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbWFwcGVkIG9iamVjdCBpbnN0ZWFkLlxcbkZvdW5kIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgd2hvc2UgdmFsdWVzIGFyZSBwb3NzaWJseSBtYXBwaW5nIGZ1bmN0aW9uczogJHtPYmplY3QuZW50cmllcyhtYXBwZXIpLmZpbHRlcigoW2tleSwgdmFsdWVdKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBgXFxuIC0gJHtrZXl9OiAke3ZhbHVlLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxuXFxzKi9nLCAnJyl9YCkuam9pbignJyl9YCk7XG4gIH1cbiAgcmV0dXJuIG1hcHBlcjtcbn1cbmZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNFcnJvckFjdG9yRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LnR5cGUuc3RhcnRzV2l0aCgneHN0YXRlLmVycm9yLmFjdG9yJyk7XG59XG5mdW5jdGlvbiB0b1RyYW5zaXRpb25Db25maWdBcnJheShjb25maWdMaWtlKSB7XG4gIHJldHVybiB0b0FycmF5U3RyaWN0KGNvbmZpZ0xpa2UpLm1hcCh0cmFuc2l0aW9uTGlrZSA9PiB7XG4gICAgaWYgKHR5cGVvZiB0cmFuc2l0aW9uTGlrZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHRyYW5zaXRpb25MaWtlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiB0cmFuc2l0aW9uTGlrZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zaXRpb25MaWtlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVRhcmdldCh0YXJnZXQpIHtcbiAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gVEFSR0VUTEVTU19LRVkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiB0b0FycmF5KHRhcmdldCk7XG59XG5mdW5jdGlvbiB0b09ic2VydmVyKG5leHRIYW5kbGVyLCBlcnJvckhhbmRsZXIsIGNvbXBsZXRpb25IYW5kbGVyKSB7XG4gIGNvbnN0IGlzT2JzZXJ2ZXIgPSB0eXBlb2YgbmV4dEhhbmRsZXIgPT09ICdvYmplY3QnO1xuICBjb25zdCBzZWxmID0gaXNPYnNlcnZlciA/IG5leHRIYW5kbGVyIDogdW5kZWZpbmVkO1xuICByZXR1cm4ge1xuICAgIG5leHQ6IChpc09ic2VydmVyID8gbmV4dEhhbmRsZXIubmV4dCA6IG5leHRIYW5kbGVyKT8uYmluZChzZWxmKSxcbiAgICBlcnJvcjogKGlzT2JzZXJ2ZXIgPyBuZXh0SGFuZGxlci5lcnJvciA6IGVycm9ySGFuZGxlcik/LmJpbmQoc2VsZiksXG4gICAgY29tcGxldGU6IChpc09ic2VydmVyID8gbmV4dEhhbmRsZXIuY29tcGxldGUgOiBjb21wbGV0aW9uSGFuZGxlcik/LmJpbmQoc2VsZilcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUludm9rZUlkKHN0YXRlTm9kZUlkLCBpbmRleCkge1xuICByZXR1cm4gYCR7aW5kZXh9LiR7c3RhdGVOb2RlSWR9YDtcbn1cbmZ1bmN0aW9uIHJlc29sdmVSZWZlcmVuY2VkQWN0b3IobWFjaGluZSwgc3JjKSB7XG4gIGNvbnN0IG1hdGNoID0gc3JjLm1hdGNoKC9eeHN0YXRlXFwuaW52b2tlXFwuKFxcZCspXFwuKC4qKS8pO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIG1hY2hpbmUuaW1wbGVtZW50YXRpb25zLmFjdG9yc1tzcmNdO1xuICB9XG4gIGNvbnN0IFssIGluZGV4U3RyLCBub2RlSWRdID0gbWF0Y2g7XG4gIGNvbnN0IG5vZGUgPSBtYWNoaW5lLmdldFN0YXRlTm9kZUJ5SWQobm9kZUlkKTtcbiAgY29uc3QgaW52b2tlQ29uZmlnID0gbm9kZS5jb25maWcuaW52b2tlO1xuICByZXR1cm4gKEFycmF5LmlzQXJyYXkoaW52b2tlQ29uZmlnKSA/IGludm9rZUNvbmZpZ1tpbmRleFN0cl0gOiBpbnZva2VDb25maWcpLnNyYztcbn1cbmZ1bmN0aW9uIGdldEFsbE93bkV2ZW50RGVzY3JpcHRvcnMoc25hcHNob3QpIHtcbiAgcmV0dXJuIFsuLi5uZXcgU2V0KFsuLi5zbmFwc2hvdC5fbm9kZXMuZmxhdE1hcChzbiA9PiBzbi5vd25FdmVudHMpXSldO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTY2hlZHVsZWRFdmVudElkKGFjdG9yUmVmLCBpZCkge1xuICByZXR1cm4gYCR7YWN0b3JSZWYuc2Vzc2lvbklkfS4ke2lkfWA7XG59XG5sZXQgaWRDb3VudGVyID0gMDtcbmZ1bmN0aW9uIGNyZWF0ZVN5c3RlbShyb290QWN0b3IsIG9wdGlvbnMpIHtcbiAgY29uc3QgY2hpbGRyZW4gPSBuZXcgTWFwKCk7XG4gIGNvbnN0IGtleWVkQWN0b3JzID0gbmV3IE1hcCgpO1xuICBjb25zdCByZXZlcnNlS2V5ZWRBY3RvcnMgPSBuZXcgV2Vha01hcCgpO1xuICBjb25zdCBpbnNwZWN0aW9uT2JzZXJ2ZXJzID0gbmV3IFNldCgpO1xuICBjb25zdCB0aW1lck1hcCA9IHt9O1xuICBjb25zdCB7XG4gICAgY2xvY2ssXG4gICAgbG9nZ2VyXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBzY2hlZHVsZXIgPSB7XG4gICAgc2NoZWR1bGU6IChzb3VyY2UsIHRhcmdldCwgZXZlbnQsIGRlbGF5LCBpZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpKSA9PiB7XG4gICAgICBjb25zdCBzY2hlZHVsZWRFdmVudCA9IHtcbiAgICAgICAgc291cmNlLFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgIGV2ZW50LFxuICAgICAgICBkZWxheSxcbiAgICAgICAgaWQsXG4gICAgICAgIHN0YXJ0ZWRBdDogRGF0ZS5ub3coKVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNjaGVkdWxlZEV2ZW50SWQgPSBjcmVhdGVTY2hlZHVsZWRFdmVudElkKHNvdXJjZSwgaWQpO1xuICAgICAgc3lzdGVtLl9zbmFwc2hvdC5fc2NoZWR1bGVkRXZlbnRzW3NjaGVkdWxlZEV2ZW50SWRdID0gc2NoZWR1bGVkRXZlbnQ7XG4gICAgICBjb25zdCB0aW1lb3V0ID0gY2xvY2suc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGRlbGV0ZSB0aW1lck1hcFtzY2hlZHVsZWRFdmVudElkXTtcbiAgICAgICAgZGVsZXRlIHN5c3RlbS5fc25hcHNob3QuX3NjaGVkdWxlZEV2ZW50c1tzY2hlZHVsZWRFdmVudElkXTtcbiAgICAgICAgc3lzdGVtLl9yZWxheShzb3VyY2UsIHRhcmdldCwgZXZlbnQpO1xuICAgICAgfSwgZGVsYXkpO1xuICAgICAgdGltZXJNYXBbc2NoZWR1bGVkRXZlbnRJZF0gPSB0aW1lb3V0O1xuICAgIH0sXG4gICAgY2FuY2VsOiAoc291cmNlLCBpZCkgPT4ge1xuICAgICAgY29uc3Qgc2NoZWR1bGVkRXZlbnRJZCA9IGNyZWF0ZVNjaGVkdWxlZEV2ZW50SWQoc291cmNlLCBpZCk7XG4gICAgICBjb25zdCB0aW1lb3V0ID0gdGltZXJNYXBbc2NoZWR1bGVkRXZlbnRJZF07XG4gICAgICBkZWxldGUgdGltZXJNYXBbc2NoZWR1bGVkRXZlbnRJZF07XG4gICAgICBkZWxldGUgc3lzdGVtLl9zbmFwc2hvdC5fc2NoZWR1bGVkRXZlbnRzW3NjaGVkdWxlZEV2ZW50SWRdO1xuICAgICAgaWYgKHRpbWVvdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjbG9jay5jbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjYW5jZWxBbGw6IGFjdG9yUmVmID0+IHtcbiAgICAgIGZvciAoY29uc3Qgc2NoZWR1bGVkRXZlbnRJZCBpbiBzeXN0ZW0uX3NuYXBzaG90Ll9zY2hlZHVsZWRFdmVudHMpIHtcbiAgICAgICAgY29uc3Qgc2NoZWR1bGVkRXZlbnQgPSBzeXN0ZW0uX3NuYXBzaG90Ll9zY2hlZHVsZWRFdmVudHNbc2NoZWR1bGVkRXZlbnRJZF07XG4gICAgICAgIGlmIChzY2hlZHVsZWRFdmVudC5zb3VyY2UgPT09IGFjdG9yUmVmKSB7XG4gICAgICAgICAgc2NoZWR1bGVyLmNhbmNlbChhY3RvclJlZiwgc2NoZWR1bGVkRXZlbnQuaWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBzZW5kSW5zcGVjdGlvbkV2ZW50ID0gZXZlbnQgPT4ge1xuICAgIGlmICghaW5zcGVjdGlvbk9ic2VydmVycy5zaXplKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlc29sdmVkSW5zcGVjdGlvbkV2ZW50ID0ge1xuICAgICAgLi4uZXZlbnQsXG4gICAgICByb290SWQ6IHJvb3RBY3Rvci5zZXNzaW9uSWRcbiAgICB9O1xuICAgIGluc3BlY3Rpb25PYnNlcnZlcnMuZm9yRWFjaChvYnNlcnZlciA9PiBvYnNlcnZlci5uZXh0Py4ocmVzb2x2ZWRJbnNwZWN0aW9uRXZlbnQpKTtcbiAgfTtcbiAgY29uc3Qgc3lzdGVtID0ge1xuICAgIF9zbmFwc2hvdDoge1xuICAgICAgX3NjaGVkdWxlZEV2ZW50czogKG9wdGlvbnM/LnNuYXBzaG90ICYmIG9wdGlvbnMuc25hcHNob3Quc2NoZWR1bGVyKSA/PyB7fVxuICAgIH0sXG4gICAgX2Jvb2tJZDogKCkgPT4gYHg6JHtpZENvdW50ZXIrK31gLFxuICAgIF9yZWdpc3RlcjogKHNlc3Npb25JZCwgYWN0b3JSZWYpID0+IHtcbiAgICAgIGNoaWxkcmVuLnNldChzZXNzaW9uSWQsIGFjdG9yUmVmKTtcbiAgICAgIHJldHVybiBzZXNzaW9uSWQ7XG4gICAgfSxcbiAgICBfdW5yZWdpc3RlcjogYWN0b3JSZWYgPT4ge1xuICAgICAgY2hpbGRyZW4uZGVsZXRlKGFjdG9yUmVmLnNlc3Npb25JZCk7XG4gICAgICBjb25zdCBzeXN0ZW1JZCA9IHJldmVyc2VLZXllZEFjdG9ycy5nZXQoYWN0b3JSZWYpO1xuICAgICAgaWYgKHN5c3RlbUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAga2V5ZWRBY3RvcnMuZGVsZXRlKHN5c3RlbUlkKTtcbiAgICAgICAgcmV2ZXJzZUtleWVkQWN0b3JzLmRlbGV0ZShhY3RvclJlZik7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXQ6IHN5c3RlbUlkID0+IHtcbiAgICAgIHJldHVybiBrZXllZEFjdG9ycy5nZXQoc3lzdGVtSWQpO1xuICAgIH0sXG4gICAgX3NldDogKHN5c3RlbUlkLCBhY3RvclJlZikgPT4ge1xuICAgICAgY29uc3QgZXhpc3RpbmcgPSBrZXllZEFjdG9ycy5nZXQoc3lzdGVtSWQpO1xuICAgICAgaWYgKGV4aXN0aW5nICYmIGV4aXN0aW5nICE9PSBhY3RvclJlZikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFjdG9yIHdpdGggc3lzdGVtIElEICcke3N5c3RlbUlkfScgYWxyZWFkeSBleGlzdHMuYCk7XG4gICAgICB9XG4gICAgICBrZXllZEFjdG9ycy5zZXQoc3lzdGVtSWQsIGFjdG9yUmVmKTtcbiAgICAgIHJldmVyc2VLZXllZEFjdG9ycy5zZXQoYWN0b3JSZWYsIHN5c3RlbUlkKTtcbiAgICB9LFxuICAgIGluc3BlY3Q6IG9ic2VydmVyT3JGbiA9PiB7XG4gICAgICBjb25zdCBvYnNlcnZlciA9IHRvT2JzZXJ2ZXIob2JzZXJ2ZXJPckZuKTtcbiAgICAgIGluc3BlY3Rpb25PYnNlcnZlcnMuYWRkKG9ic2VydmVyKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICAgIGluc3BlY3Rpb25PYnNlcnZlcnMuZGVsZXRlKG9ic2VydmVyKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIF9zZW5kSW5zcGVjdGlvbkV2ZW50OiBzZW5kSW5zcGVjdGlvbkV2ZW50LFxuICAgIF9yZWxheTogKHNvdXJjZSwgdGFyZ2V0LCBldmVudCkgPT4ge1xuICAgICAgc3lzdGVtLl9zZW5kSW5zcGVjdGlvbkV2ZW50KHtcbiAgICAgICAgdHlwZTogJ0B4c3RhdGUuZXZlbnQnLFxuICAgICAgICBzb3VyY2VSZWY6IHNvdXJjZSxcbiAgICAgICAgYWN0b3JSZWY6IHRhcmdldCxcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pO1xuICAgICAgdGFyZ2V0Ll9zZW5kKGV2ZW50KTtcbiAgICB9LFxuICAgIHNjaGVkdWxlcixcbiAgICBnZXRTbmFwc2hvdDogKCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgX3NjaGVkdWxlZEV2ZW50czoge1xuICAgICAgICAgIC4uLnN5c3RlbS5fc25hcHNob3QuX3NjaGVkdWxlZEV2ZW50c1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgc3RhcnQ6ICgpID0+IHtcbiAgICAgIGNvbnN0IHNjaGVkdWxlZEV2ZW50cyA9IHN5c3RlbS5fc25hcHNob3QuX3NjaGVkdWxlZEV2ZW50cztcbiAgICAgIHN5c3RlbS5fc25hcHNob3QuX3NjaGVkdWxlZEV2ZW50cyA9IHt9O1xuICAgICAgZm9yIChjb25zdCBzY2hlZHVsZWRJZCBpbiBzY2hlZHVsZWRFdmVudHMpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgZGVsYXksXG4gICAgICAgICAgaWRcbiAgICAgICAgfSA9IHNjaGVkdWxlZEV2ZW50c1tzY2hlZHVsZWRJZF07XG4gICAgICAgIHNjaGVkdWxlci5zY2hlZHVsZShzb3VyY2UsIHRhcmdldCwgZXZlbnQsIGRlbGF5LCBpZCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfY2xvY2s6IGNsb2NrLFxuICAgIF9sb2dnZXI6IGxvZ2dlclxuICB9O1xuICByZXR1cm4gc3lzdGVtO1xufVxuXG5jb25zdCAkJEFDVE9SX1RZUEUgPSAxO1xuXG4vLyB0aG9zZSB2YWx1ZXMgYXJlIGN1cnJlbnRseSB1c2VkIGJ5IEB4c3RhdGUvcmVhY3QgZGlyZWN0bHkgc28gaXQncyBpbXBvcnRhbnQgdG8ga2VlcCB0aGUgYXNzaWduZWQgdmFsdWVzIGluIHN5bmNcbmxldCBQcm9jZXNzaW5nU3RhdHVzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChQcm9jZXNzaW5nU3RhdHVzKSB7XG4gIFByb2Nlc3NpbmdTdGF0dXNbUHJvY2Vzc2luZ1N0YXR1c1tcIk5vdFN0YXJ0ZWRcIl0gPSAwXSA9IFwiTm90U3RhcnRlZFwiO1xuICBQcm9jZXNzaW5nU3RhdHVzW1Byb2Nlc3NpbmdTdGF0dXNbXCJSdW5uaW5nXCJdID0gMV0gPSBcIlJ1bm5pbmdcIjtcbiAgUHJvY2Vzc2luZ1N0YXR1c1tQcm9jZXNzaW5nU3RhdHVzW1wiU3RvcHBlZFwiXSA9IDJdID0gXCJTdG9wcGVkXCI7XG4gIHJldHVybiBQcm9jZXNzaW5nU3RhdHVzO1xufSh7fSk7XG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgY2xvY2s6IHtcbiAgICBzZXRUaW1lb3V0OiAoZm4sIG1zKSA9PiB7XG4gICAgICByZXR1cm4gc2V0VGltZW91dChmbiwgbXMpO1xuICAgIH0sXG4gICAgY2xlYXJUaW1lb3V0OiBpZCA9PiB7XG4gICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KGlkKTtcbiAgICB9XG4gIH0sXG4gIGxvZ2dlcjogY29uc29sZS5sb2cuYmluZChjb25zb2xlKSxcbiAgZGV2VG9vbHM6IGZhbHNlXG59O1xuXG4vKipcbiAqIEFuIEFjdG9yIGlzIGEgcnVubmluZyBwcm9jZXNzIHRoYXQgY2FuIHJlY2VpdmUgZXZlbnRzLCBzZW5kIGV2ZW50cyBhbmQgY2hhbmdlXG4gKiBpdHMgYmVoYXZpb3IgYmFzZWQgb24gdGhlIGV2ZW50cyBpdCByZWNlaXZlcywgd2hpY2ggY2FuIGNhdXNlIGVmZmVjdHMgb3V0c2lkZVxuICogb2YgdGhlIGFjdG9yLiBXaGVuIHlvdSBydW4gYSBzdGF0ZSBtYWNoaW5lLCBpdCBiZWNvbWVzIGFuIGFjdG9yLlxuICovXG5jbGFzcyBBY3RvciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGFjdG9yIGluc3RhbmNlIGZvciB0aGUgZ2l2ZW4gbG9naWMgd2l0aCB0aGUgcHJvdmlkZWQgb3B0aW9ucyxcbiAgICogaWYgYW55LlxuICAgKlxuICAgKiBAcGFyYW0gbG9naWMgVGhlIGxvZ2ljIHRvIGNyZWF0ZSBhbiBhY3RvciBmcm9tXG4gICAqIEBwYXJhbSBvcHRpb25zIEFjdG9yIG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKGxvZ2ljLCBvcHRpb25zKSB7XG4gICAgdGhpcy5sb2dpYyA9IGxvZ2ljO1xuICAgIC8qKiBUaGUgY3VycmVudCBpbnRlcm5hbCBzdGF0ZSBvZiB0aGUgYWN0b3IuICovXG4gICAgdGhpcy5fc25hcHNob3QgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogVGhlIGNsb2NrIHRoYXQgaXMgcmVzcG9uc2libGUgZm9yIHNldHRpbmcgYW5kIGNsZWFyaW5nIHRpbWVvdXRzLCBzdWNoIGFzXG4gICAgICogZGVsYXllZCBldmVudHMgYW5kIHRyYW5zaXRpb25zLlxuICAgICAqL1xuICAgIHRoaXMuY2xvY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5vcHRpb25zID0gdm9pZCAwO1xuICAgIC8qKiBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgYWN0b3IgcmVsYXRpdmUgdG8gaXRzIHBhcmVudC4gKi9cbiAgICB0aGlzLmlkID0gdm9pZCAwO1xuICAgIHRoaXMubWFpbGJveCA9IG5ldyBNYWlsYm94KHRoaXMuX3Byb2Nlc3MuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5vYnNlcnZlcnMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5ldmVudExpc3RlbmVycyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmxvZ2dlciA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcHJvY2Vzc2luZ1N0YXR1cyA9IFByb2Nlc3NpbmdTdGF0dXMuTm90U3RhcnRlZDtcbiAgICAvLyBBY3RvciBSZWZcbiAgICB0aGlzLl9wYXJlbnQgPSB2b2lkIDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3N5bmNTbmFwc2hvdCA9IHZvaWQgMDtcbiAgICB0aGlzLnJlZiA9IHZvaWQgMDtcbiAgICAvLyBUT0RPOiBhZGQgdHlwaW5ncyBmb3Igc3lzdGVtXG4gICAgdGhpcy5fYWN0b3JTY29wZSA9IHZvaWQgMDtcbiAgICB0aGlzLl9zeXN0ZW1JZCA9IHZvaWQgMDtcbiAgICAvKiogVGhlIGdsb2JhbGx5IHVuaXF1ZSBwcm9jZXNzIElEIGZvciB0aGlzIGludm9jYXRpb24uICovXG4gICAgdGhpcy5zZXNzaW9uSWQgPSB2b2lkIDA7XG4gICAgLyoqIFRoZSBzeXN0ZW0gdG8gd2hpY2ggdGhpcyBhY3RvciBiZWxvbmdzLiAqL1xuICAgIHRoaXMuc3lzdGVtID0gdm9pZCAwO1xuICAgIHRoaXMuX2RvbmVFdmVudCA9IHZvaWQgMDtcbiAgICB0aGlzLnNyYyA9IHZvaWQgMDtcbiAgICAvLyBhcnJheSBvZiBmdW5jdGlvbnMgdG8gZGVmZXJcbiAgICB0aGlzLl9kZWZlcnJlZCA9IFtdO1xuICAgIGNvbnN0IHJlc29sdmVkT3B0aW9ucyA9IHtcbiAgICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG4gICAgY29uc3Qge1xuICAgICAgY2xvY2ssXG4gICAgICBsb2dnZXIsXG4gICAgICBwYXJlbnQsXG4gICAgICBzeW5jU25hcHNob3QsXG4gICAgICBpZCxcbiAgICAgIHN5c3RlbUlkLFxuICAgICAgaW5zcGVjdFxuICAgIH0gPSByZXNvbHZlZE9wdGlvbnM7XG4gICAgdGhpcy5zeXN0ZW0gPSBwYXJlbnQgPyBwYXJlbnQuc3lzdGVtIDogY3JlYXRlU3lzdGVtKHRoaXMsIHtcbiAgICAgIGNsb2NrLFxuICAgICAgbG9nZ2VyXG4gICAgfSk7XG4gICAgaWYgKGluc3BlY3QgJiYgIXBhcmVudCkge1xuICAgICAgLy8gQWx3YXlzIGluc3BlY3QgYXQgdGhlIHN5c3RlbS1sZXZlbFxuICAgICAgdGhpcy5zeXN0ZW0uaW5zcGVjdCh0b09ic2VydmVyKGluc3BlY3QpKTtcbiAgICB9XG4gICAgdGhpcy5zZXNzaW9uSWQgPSB0aGlzLnN5c3RlbS5fYm9va0lkKCk7XG4gICAgdGhpcy5pZCA9IGlkID8/IHRoaXMuc2Vzc2lvbklkO1xuICAgIHRoaXMubG9nZ2VyID0gb3B0aW9ucz8ubG9nZ2VyID8/IHRoaXMuc3lzdGVtLl9sb2dnZXI7XG4gICAgdGhpcy5jbG9jayA9IG9wdGlvbnM/LmNsb2NrID8/IHRoaXMuc3lzdGVtLl9jbG9jaztcbiAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5fc3luY1NuYXBzaG90ID0gc3luY1NuYXBzaG90O1xuICAgIHRoaXMub3B0aW9ucyA9IHJlc29sdmVkT3B0aW9ucztcbiAgICB0aGlzLnNyYyA9IHJlc29sdmVkT3B0aW9ucy5zcmMgPz8gbG9naWM7XG4gICAgdGhpcy5yZWYgPSB0aGlzO1xuICAgIHRoaXMuX2FjdG9yU2NvcGUgPSB7XG4gICAgICBzZWxmOiB0aGlzLFxuICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICBzZXNzaW9uSWQ6IHRoaXMuc2Vzc2lvbklkLFxuICAgICAgbG9nZ2VyOiB0aGlzLmxvZ2dlcixcbiAgICAgIGRlZmVyOiBmbiA9PiB7XG4gICAgICAgIHRoaXMuX2RlZmVycmVkLnB1c2goZm4pO1xuICAgICAgfSxcbiAgICAgIHN5c3RlbTogdGhpcy5zeXN0ZW0sXG4gICAgICBzdG9wQ2hpbGQ6IGNoaWxkID0+IHtcbiAgICAgICAgaWYgKGNoaWxkLl9wYXJlbnQgIT09IHRoaXMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBzdG9wIGNoaWxkIGFjdG9yICR7Y2hpbGQuaWR9IG9mICR7dGhpcy5pZH0gYmVjYXVzZSBpdCBpcyBub3QgYSBjaGlsZGApO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkLl9zdG9wKCk7XG4gICAgICB9LFxuICAgICAgZW1pdDogZW1pdHRlZEV2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5ldmVudExpc3RlbmVycy5nZXQoZW1pdHRlZEV2ZW50LnR5cGUpO1xuICAgICAgICBjb25zdCB3aWxkY2FyZExpc3RlbmVyID0gdGhpcy5ldmVudExpc3RlbmVycy5nZXQoJyonKTtcbiAgICAgICAgaWYgKCFsaXN0ZW5lcnMgJiYgIXdpbGRjYXJkTGlzdGVuZXIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxsTGlzdGVuZXJzID0gbmV3IFNldChbLi4uKGxpc3RlbmVycyA/IGxpc3RlbmVycy52YWx1ZXMoKSA6IFtdKSwgLi4uKHdpbGRjYXJkTGlzdGVuZXIgPyB3aWxkY2FyZExpc3RlbmVyLnZhbHVlcygpIDogW10pXSk7XG4gICAgICAgIGZvciAoY29uc3QgaGFuZGxlciBvZiBBcnJheS5mcm9tKGFsbExpc3RlbmVycykpIHtcbiAgICAgICAgICBoYW5kbGVyKGVtaXR0ZWRFdmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gRW5zdXJlIHRoYXQgdGhlIHNlbmQgbWV0aG9kIGlzIGJvdW5kIHRvIHRoaXMgQWN0b3IgaW5zdGFuY2VcbiAgICAvLyBpZiBkZXN0cnVjdHVyZWRcbiAgICB0aGlzLnNlbmQgPSB0aGlzLnNlbmQuYmluZCh0aGlzKTtcbiAgICB0aGlzLnN5c3RlbS5fc2VuZEluc3BlY3Rpb25FdmVudCh7XG4gICAgICB0eXBlOiAnQHhzdGF0ZS5hY3RvcicsXG4gICAgICBhY3RvclJlZjogdGhpc1xuICAgIH0pO1xuICAgIGlmIChzeXN0ZW1JZCkge1xuICAgICAgdGhpcy5fc3lzdGVtSWQgPSBzeXN0ZW1JZDtcbiAgICAgIHRoaXMuc3lzdGVtLl9zZXQoc3lzdGVtSWQsIHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLl9pbml0U3RhdGUob3B0aW9ucz8uc25hcHNob3QgPz8gb3B0aW9ucz8uc3RhdGUpO1xuICAgIGlmIChzeXN0ZW1JZCAmJiB0aGlzLl9zbmFwc2hvdC5zdGF0dXMgIT09ICdhY3RpdmUnKSB7XG4gICAgICB0aGlzLnN5c3RlbS5fdW5yZWdpc3Rlcih0aGlzKTtcbiAgICB9XG4gIH1cbiAgX2luaXRTdGF0ZShwZXJzaXN0ZWRTdGF0ZSkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLl9zbmFwc2hvdCA9IHBlcnNpc3RlZFN0YXRlID8gdGhpcy5sb2dpYy5yZXN0b3JlU25hcHNob3QgPyB0aGlzLmxvZ2ljLnJlc3RvcmVTbmFwc2hvdChwZXJzaXN0ZWRTdGF0ZSwgdGhpcy5fYWN0b3JTY29wZSkgOiBwZXJzaXN0ZWRTdGF0ZSA6IHRoaXMubG9naWMuZ2V0SW5pdGlhbFNuYXBzaG90KHRoaXMuX2FjdG9yU2NvcGUsIHRoaXMub3B0aW9ucz8uaW5wdXQpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gaWYgd2UgZ2V0IGhlcmUgdGhlbiBpdCBtZWFucyB0aGF0IHdlIGFzc2lnbiBhIHZhbHVlIHRvIHRoaXMuX3NuYXBzaG90IHRoYXQgaXMgbm90IG9mIHRoZSBjb3JyZWN0IHR5cGVcbiAgICAgIC8vIHdlIGNhbid0IGdldCB0aGUgdHJ1ZSBgVFNuYXBzaG90ICYgeyBzdGF0dXM6ICdlcnJvcic7IH1gLCBpdCdzIGltcG9zc2libGVcbiAgICAgIC8vIHNvIHJpZ2h0IG5vdyB0aGlzIGlzIGEgbGllIG9mIHNvcnRzXG4gICAgICB0aGlzLl9zbmFwc2hvdCA9IHtcbiAgICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgICBvdXRwdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgZXJyb3I6IGVyclxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlKHNuYXBzaG90LCBldmVudCkge1xuICAgIC8vIFVwZGF0ZSBzdGF0ZVxuICAgIHRoaXMuX3NuYXBzaG90ID0gc25hcHNob3Q7XG5cbiAgICAvLyBFeGVjdXRlIGRlZmVycmVkIGVmZmVjdHNcbiAgICBsZXQgZGVmZXJyZWRGbjtcbiAgICB3aGlsZSAoZGVmZXJyZWRGbiA9IHRoaXMuX2RlZmVycmVkLnNoaWZ0KCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRlZmVycmVkRm4oKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyB0aGlzIGVycm9yIGNhbiBvbmx5IGJlIGNhdWdodCB3aGVuIGV4ZWN1dGluZyAqaW5pdGlhbCogYWN0aW9uc1xuICAgICAgICAvLyBpdCdzIHRoZSBvbmx5IHRpbWUgd2hlbiB3ZSBjYWxsIGFjdGlvbnMgcHJvdmlkZWQgYnkgdGhlIHVzZXIgdGhyb3VnaCB0aG9zZSBkZWZlcnJlZHNcbiAgICAgICAgLy8gd2hlbiB0aGUgYWN0b3IgaXMgYWxyZWFkeSBydW5uaW5nIHdlIGFsd2F5cyBleGVjdXRlIHRoZW0gc3luY2hyb25vdXNseSB3aGlsZSB0cmFuc2l0aW9uaW5nXG4gICAgICAgIC8vIG5vIFwiYnVpbHRpbiBkZWZlcnJlZFwiIHNob3VsZCBhY3R1YWxseSB0aHJvdyBhbiBlcnJvciBzaW5jZSB0aGV5IGFyZSBlaXRoZXIgc2FmZVxuICAgICAgICAvLyBvciB0aGUgY29udHJvbCBmbG93IGlzIHBhc3NlZCB0aHJvdWdoIHRoZSBtYWlsYm94IGFuZCBlcnJvcnMgc2hvdWxkIGJlIGNhdWdodCBieSB0aGUgYF9wcm9jZXNzYCB1c2VkIGJ5IHRoZSBtYWlsYm94XG4gICAgICAgIHRoaXMuX2RlZmVycmVkLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuX3NuYXBzaG90ID0ge1xuICAgICAgICAgIC4uLnNuYXBzaG90LFxuICAgICAgICAgIHN0YXR1czogJ2Vycm9yJyxcbiAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAodGhpcy5fc25hcHNob3Quc3RhdHVzKSB7XG4gICAgICBjYXNlICdhY3RpdmUnOlxuICAgICAgICBmb3IgKGNvbnN0IG9ic2VydmVyIG9mIHRoaXMub2JzZXJ2ZXJzKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQ/LihzbmFwc2hvdCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXBvcnRVbmhhbmRsZWRFcnJvcihlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2RvbmUnOlxuICAgICAgICAvLyBuZXh0IG9ic2VydmVycyBhcmUgbWVhbnQgdG8gYmUgbm90aWZpZWQgYWJvdXQgZG9uZSBzbmFwc2hvdHNcbiAgICAgICAgLy8gdGhpcyBjYW4gYmUgc2VlbiBhcyBzb21ldGhpbmcgdGhhdCBpcyBkaWZmZXJlbnQgZnJvbSBob3cgb2JzZXJ2YWJsZSB3b3JrXG4gICAgICAgIC8vIGJ1dCB3aXRoIG9ic2VydmFibGVzIGBjb21wbGV0ZWAgY2FsbGJhY2sgaXMgY2FsbGVkIHdpdGhvdXQgYW55IGFyZ3VtZW50c1xuICAgICAgICAvLyBpdCdzIG1vcmUgZXJnb25vbWljIGZvciBYU3RhdGUgdG8gdHJlYXQgYSBkb25lIHNuYXBzaG90IGFzIGEgXCJuZXh0XCIgdmFsdWVcbiAgICAgICAgLy8gYW5kIHRoZSBjb21wbGV0aW9uIGV2ZW50IGFzIHNvbWV0aGluZyB0aGF0IGlzIHNlcGFyYXRlLFxuICAgICAgICAvLyBzb21ldGhpbmcgdGhhdCBtZXJlbHkgZm9sbG93cyBlbWl0dGluZyB0aGF0IGRvbmUgc25hcHNob3RcbiAgICAgICAgZm9yIChjb25zdCBvYnNlcnZlciBvZiB0aGlzLm9ic2VydmVycykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0Py4oc25hcHNob3QpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmVwb3J0VW5oYW5kbGVkRXJyb3IoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RvcFByb2NlZHVyZSgpO1xuICAgICAgICB0aGlzLl9jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLl9kb25lRXZlbnQgPSBjcmVhdGVEb25lQWN0b3JFdmVudCh0aGlzLmlkLCB0aGlzLl9zbmFwc2hvdC5vdXRwdXQpO1xuICAgICAgICBpZiAodGhpcy5fcGFyZW50KSB7XG4gICAgICAgICAgdGhpcy5zeXN0ZW0uX3JlbGF5KHRoaXMsIHRoaXMuX3BhcmVudCwgdGhpcy5fZG9uZUV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgdGhpcy5fZXJyb3IodGhpcy5fc25hcHNob3QuZXJyb3IpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5zeXN0ZW0uX3NlbmRJbnNwZWN0aW9uRXZlbnQoe1xuICAgICAgdHlwZTogJ0B4c3RhdGUuc25hcHNob3QnLFxuICAgICAgYWN0b3JSZWY6IHRoaXMsXG4gICAgICBldmVudCxcbiAgICAgIHNuYXBzaG90XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3Vic2NyaWJlIGFuIG9ic2VydmVyIHRvIGFuIGFjdG9y4oCZcyBzbmFwc2hvdCB2YWx1ZXMuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIFRoZSBvYnNlcnZlciB3aWxsIHJlY2VpdmUgdGhlIGFjdG9y4oCZcyBzbmFwc2hvdCB2YWx1ZSB3aGVuIGl0IGlzIGVtaXR0ZWQuXG4gICAqIFRoZSBvYnNlcnZlciBjYW4gYmU6XG4gICAqXG4gICAqIC0gQSBwbGFpbiBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIHRoZSBsYXRlc3Qgc25hcHNob3QsIG9yXG4gICAqIC0gQW4gb2JzZXJ2ZXIgb2JqZWN0IHdob3NlIGAubmV4dChzbmFwc2hvdClgIG1ldGhvZCByZWNlaXZlcyB0aGUgbGF0ZXN0XG4gICAqICAgc25hcHNob3RcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogYGBgdHNcbiAgICogLy8gT2JzZXJ2ZXIgYXMgYSBwbGFpbiBmdW5jdGlvblxuICAgKiBjb25zdCBzdWJzY3JpcHRpb24gPSBhY3Rvci5zdWJzY3JpYmUoKHNuYXBzaG90KSA9PiB7XG4gICAqICAgY29uc29sZS5sb2coc25hcHNob3QpO1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBgYHRzXG4gICAqIC8vIE9ic2VydmVyIGFzIGFuIG9iamVjdFxuICAgKiBjb25zdCBzdWJzY3JpcHRpb24gPSBhY3Rvci5zdWJzY3JpYmUoe1xuICAgKiAgIG5leHQoc25hcHNob3QpIHtcbiAgICogICAgIGNvbnNvbGUubG9nKHNuYXBzaG90KTtcbiAgICogICB9LFxuICAgKiAgIGVycm9yKGVycikge1xuICAgKiAgICAgLy8gLi4uXG4gICAqICAgfSxcbiAgICogICBjb21wbGV0ZSgpIHtcbiAgICogICAgIC8vIC4uLlxuICAgKiAgIH1cbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBUaGUgcmV0dXJuIHZhbHVlIG9mIGBhY3Rvci5zdWJzY3JpYmUob2JzZXJ2ZXIpYCBpcyBhIHN1YnNjcmlwdGlvbiBvYmplY3RcbiAgICogdGhhdCBoYXMgYW4gYC51bnN1YnNjcmliZSgpYCBtZXRob2QuIFlvdSBjYW4gY2FsbFxuICAgKiBgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKClgIHRvIHVuc3Vic2NyaWJlIHRoZSBvYnNlcnZlcjpcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogYGBgdHNcbiAgICogY29uc3Qgc3Vic2NyaXB0aW9uID0gYWN0b3Iuc3Vic2NyaWJlKChzbmFwc2hvdCkgPT4ge1xuICAgKiAgIC8vIC4uLlxuICAgKiB9KTtcbiAgICpcbiAgICogLy8gVW5zdWJzY3JpYmUgdGhlIG9ic2VydmVyXG4gICAqIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgKiBgYGBcbiAgICpcbiAgICogV2hlbiB0aGUgYWN0b3IgaXMgc3RvcHBlZCwgYWxsIG9mIGl0cyBvYnNlcnZlcnMgd2lsbCBhdXRvbWF0aWNhbGx5IGJlXG4gICAqIHVuc3Vic2NyaWJlZC5cbiAgICpcbiAgICogQHBhcmFtIG9ic2VydmVyIC0gRWl0aGVyIGEgcGxhaW4gZnVuY3Rpb24gdGhhdCByZWNlaXZlcyB0aGUgbGF0ZXN0XG4gICAqICAgc25hcHNob3QsIG9yIGFuIG9ic2VydmVyIG9iamVjdCB3aG9zZSBgLm5leHQoc25hcHNob3QpYCBtZXRob2QgcmVjZWl2ZXNcbiAgICogICB0aGUgbGF0ZXN0IHNuYXBzaG90XG4gICAqL1xuXG4gIHN1YnNjcmliZShuZXh0TGlzdGVuZXJPck9ic2VydmVyLCBlcnJvckxpc3RlbmVyLCBjb21wbGV0ZUxpc3RlbmVyKSB7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSB0b09ic2VydmVyKG5leHRMaXN0ZW5lck9yT2JzZXJ2ZXIsIGVycm9yTGlzdGVuZXIsIGNvbXBsZXRlTGlzdGVuZXIpO1xuICAgIGlmICh0aGlzLl9wcm9jZXNzaW5nU3RhdHVzICE9PSBQcm9jZXNzaW5nU3RhdHVzLlN0b3BwZWQpIHtcbiAgICAgIHRoaXMub2JzZXJ2ZXJzLmFkZChvYnNlcnZlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAodGhpcy5fc25hcHNob3Quc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgJ2RvbmUnOlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZT8uKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXBvcnRVbmhhbmRsZWRFcnJvcihlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGVyciA9IHRoaXMuX3NuYXBzaG90LmVycm9yO1xuICAgICAgICAgICAgaWYgKCFvYnNlcnZlci5lcnJvcikge1xuICAgICAgICAgICAgICByZXBvcnRVbmhhbmRsZWRFcnJvcihlcnIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXBvcnRVbmhhbmRsZWRFcnJvcihlcnIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB1bnN1YnNjcmliZTogKCkgPT4ge1xuICAgICAgICB0aGlzLm9ic2VydmVycy5kZWxldGUob2JzZXJ2ZXIpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgb24odHlwZSwgaGFuZGxlcikge1xuICAgIGxldCBsaXN0ZW5lcnMgPSB0aGlzLmV2ZW50TGlzdGVuZXJzLmdldCh0eXBlKTtcbiAgICBpZiAoIWxpc3RlbmVycykge1xuICAgICAgbGlzdGVuZXJzID0gbmV3IFNldCgpO1xuICAgICAgdGhpcy5ldmVudExpc3RlbmVycy5zZXQodHlwZSwgbGlzdGVuZXJzKTtcbiAgICB9XG4gICAgY29uc3Qgd3JhcHBlZEhhbmRsZXIgPSBoYW5kbGVyLmJpbmQodW5kZWZpbmVkKTtcbiAgICBsaXN0ZW5lcnMuYWRkKHdyYXBwZWRIYW5kbGVyKTtcbiAgICByZXR1cm4ge1xuICAgICAgdW5zdWJzY3JpYmU6ICgpID0+IHtcbiAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZSh3cmFwcGVkSGFuZGxlcik7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKiBTdGFydHMgdGhlIEFjdG9yIGZyb20gdGhlIGluaXRpYWwgc3RhdGUgKi9cbiAgc3RhcnQoKSB7XG4gICAgaWYgKHRoaXMuX3Byb2Nlc3NpbmdTdGF0dXMgPT09IFByb2Nlc3NpbmdTdGF0dXMuUnVubmluZykge1xuICAgICAgLy8gRG8gbm90IHJlc3RhcnQgdGhlIHNlcnZpY2UgaWYgaXQgaXMgYWxyZWFkeSBzdGFydGVkXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKHRoaXMuX3N5bmNTbmFwc2hvdCkge1xuICAgICAgdGhpcy5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiBzbmFwc2hvdCA9PiB7XG4gICAgICAgICAgaWYgKHNuYXBzaG90LnN0YXR1cyA9PT0gJ2FjdGl2ZScpIHtcbiAgICAgICAgICAgIHRoaXMuc3lzdGVtLl9yZWxheSh0aGlzLCB0aGlzLl9wYXJlbnQsIHtcbiAgICAgICAgICAgICAgdHlwZTogYHhzdGF0ZS5zbmFwc2hvdC4ke3RoaXMuaWR9YCxcbiAgICAgICAgICAgICAgc25hcHNob3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6ICgpID0+IHt9XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5zeXN0ZW0uX3JlZ2lzdGVyKHRoaXMuc2Vzc2lvbklkLCB0aGlzKTtcbiAgICBpZiAodGhpcy5fc3lzdGVtSWQpIHtcbiAgICAgIHRoaXMuc3lzdGVtLl9zZXQodGhpcy5fc3lzdGVtSWQsIHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLl9wcm9jZXNzaW5nU3RhdHVzID0gUHJvY2Vzc2luZ1N0YXR1cy5SdW5uaW5nO1xuXG4gICAgLy8gVE9ETzogdGhpcyBpc24ndCBjb3JyZWN0IHdoZW4gcmVoeWRyYXRpbmdcbiAgICBjb25zdCBpbml0RXZlbnQgPSBjcmVhdGVJbml0RXZlbnQodGhpcy5vcHRpb25zLmlucHV0KTtcbiAgICB0aGlzLnN5c3RlbS5fc2VuZEluc3BlY3Rpb25FdmVudCh7XG4gICAgICB0eXBlOiAnQHhzdGF0ZS5ldmVudCcsXG4gICAgICBzb3VyY2VSZWY6IHRoaXMuX3BhcmVudCxcbiAgICAgIGFjdG9yUmVmOiB0aGlzLFxuICAgICAgZXZlbnQ6IGluaXRFdmVudFxuICAgIH0pO1xuICAgIGNvbnN0IHN0YXR1cyA9IHRoaXMuX3NuYXBzaG90LnN0YXR1cztcbiAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgICAgY2FzZSAnZG9uZSc6XG4gICAgICAgIC8vIGEgc3RhdGUgbWFjaGluZSBjYW4gYmUgXCJkb25lXCIgdXBvbiBpbml0aWFsaXphdGlvbiAoaXQgY291bGQgcmVhY2ggYSBmaW5hbCBzdGF0ZSB1c2luZyBpbml0aWFsIG1pY3Jvc3RlcHMpXG4gICAgICAgIC8vIHdlIHN0aWxsIG5lZWQgdG8gY29tcGxldGUgb2JzZXJ2ZXJzLCBmbHVzaCBkZWZlcnJlZHMgZXRjXG4gICAgICAgIHRoaXMudXBkYXRlKHRoaXMuX3NuYXBzaG90LCBpbml0RXZlbnQpO1xuICAgICAgICAvLyBUT0RPOiByZXRoaW5rIGNsZWFudXAgb2Ygb2JzZXJ2ZXJzLCBtYWlsYm94LCBldGNcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgIHRoaXMuX2Vycm9yKHRoaXMuX3NuYXBzaG90LmVycm9yKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICghdGhpcy5fcGFyZW50KSB7XG4gICAgICB0aGlzLnN5c3RlbS5zdGFydCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5sb2dpYy5zdGFydCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5sb2dpYy5zdGFydCh0aGlzLl9zbmFwc2hvdCwgdGhpcy5fYWN0b3JTY29wZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5fc25hcHNob3QgPSB7XG4gICAgICAgICAgLi4udGhpcy5fc25hcHNob3QsXG4gICAgICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fZXJyb3IoZXJyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogdGhpcyBub3RpZmllcyBhbGwgc3Vic2NyaWJlcnMgYnV0IHVzdWFsbHkgdGhpcyBpcyByZWR1bmRhbnRcbiAgICAvLyB0aGVyZSBpcyBubyByZWFsIGNoYW5nZSBoYXBwZW5pbmcgaGVyZVxuICAgIC8vIHdlIG5lZWQgdG8gcmV0aGluayBpZiB0aGlzIG5lZWRzIHRvIGJlIHJlZmFjdG9yZWRcbiAgICB0aGlzLnVwZGF0ZSh0aGlzLl9zbmFwc2hvdCwgaW5pdEV2ZW50KTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmRldlRvb2xzKSB7XG4gICAgICB0aGlzLmF0dGFjaERldlRvb2xzKCk7XG4gICAgfVxuICAgIHRoaXMubWFpbGJveC5zdGFydCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIF9wcm9jZXNzKGV2ZW50KSB7XG4gICAgbGV0IG5leHRTdGF0ZTtcbiAgICBsZXQgY2F1Z2h0RXJyb3I7XG4gICAgdHJ5IHtcbiAgICAgIG5leHRTdGF0ZSA9IHRoaXMubG9naWMudHJhbnNpdGlvbih0aGlzLl9zbmFwc2hvdCwgZXZlbnQsIHRoaXMuX2FjdG9yU2NvcGUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gd2Ugd3JhcCBpdCBpbiBhIGJveCBzbyB3ZSBjYW4gcmV0aHJvdyBpdCBsYXRlciBldmVuIGlmIGZhbHN5IHZhbHVlIGdldHMgY2F1Z2h0IGhlcmVcbiAgICAgIGNhdWdodEVycm9yID0ge1xuICAgICAgICBlcnJcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChjYXVnaHRFcnJvcikge1xuICAgICAgY29uc3Qge1xuICAgICAgICBlcnJcbiAgICAgIH0gPSBjYXVnaHRFcnJvcjtcbiAgICAgIHRoaXMuX3NuYXBzaG90ID0ge1xuICAgICAgICAuLi50aGlzLl9zbmFwc2hvdCxcbiAgICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgICBlcnJvcjogZXJyXG4gICAgICB9O1xuICAgICAgdGhpcy5fZXJyb3IoZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy51cGRhdGUobmV4dFN0YXRlLCBldmVudCk7XG4gICAgaWYgKGV2ZW50LnR5cGUgPT09IFhTVEFURV9TVE9QKSB7XG4gICAgICB0aGlzLl9zdG9wUHJvY2VkdXJlKCk7XG4gICAgICB0aGlzLl9jb21wbGV0ZSgpO1xuICAgIH1cbiAgfVxuICBfc3RvcCgpIHtcbiAgICBpZiAodGhpcy5fcHJvY2Vzc2luZ1N0YXR1cyA9PT0gUHJvY2Vzc2luZ1N0YXR1cy5TdG9wcGVkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy5tYWlsYm94LmNsZWFyKCk7XG4gICAgaWYgKHRoaXMuX3Byb2Nlc3NpbmdTdGF0dXMgPT09IFByb2Nlc3NpbmdTdGF0dXMuTm90U3RhcnRlZCkge1xuICAgICAgdGhpcy5fcHJvY2Vzc2luZ1N0YXR1cyA9IFByb2Nlc3NpbmdTdGF0dXMuU3RvcHBlZDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0aGlzLm1haWxib3guZW5xdWV1ZSh7XG4gICAgICB0eXBlOiBYU1RBVEVfU1RPUFxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqIFN0b3BzIHRoZSBBY3RvciBhbmQgdW5zdWJzY3JpYmUgYWxsIGxpc3RlbmVycy4gKi9cbiAgc3RvcCgpIHtcbiAgICBpZiAodGhpcy5fcGFyZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Egbm9uLXJvb3QgYWN0b3IgY2Fubm90IGJlIHN0b3BwZWQgZGlyZWN0bHkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zdG9wKCk7XG4gIH1cbiAgX2NvbXBsZXRlKCkge1xuICAgIGZvciAoY29uc3Qgb2JzZXJ2ZXIgb2YgdGhpcy5vYnNlcnZlcnMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG9ic2VydmVyLmNvbXBsZXRlPy4oKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXBvcnRVbmhhbmRsZWRFcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm9ic2VydmVycy5jbGVhcigpO1xuICB9XG4gIF9yZXBvcnRFcnJvcihlcnIpIHtcbiAgICBpZiAoIXRoaXMub2JzZXJ2ZXJzLnNpemUpIHtcbiAgICAgIGlmICghdGhpcy5fcGFyZW50KSB7XG4gICAgICAgIHJlcG9ydFVuaGFuZGxlZEVycm9yKGVycik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCByZXBvcnRFcnJvciA9IGZhbHNlO1xuICAgIGZvciAoY29uc3Qgb2JzZXJ2ZXIgb2YgdGhpcy5vYnNlcnZlcnMpIHtcbiAgICAgIGNvbnN0IGVycm9yTGlzdGVuZXIgPSBvYnNlcnZlci5lcnJvcjtcbiAgICAgIHJlcG9ydEVycm9yIHx8PSAhZXJyb3JMaXN0ZW5lcjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGVycm9yTGlzdGVuZXI/LihlcnIpO1xuICAgICAgfSBjYXRjaCAoZXJyMikge1xuICAgICAgICByZXBvcnRVbmhhbmRsZWRFcnJvcihlcnIyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5vYnNlcnZlcnMuY2xlYXIoKTtcbiAgICBpZiAocmVwb3J0RXJyb3IpIHtcbiAgICAgIHJlcG9ydFVuaGFuZGxlZEVycm9yKGVycik7XG4gICAgfVxuICB9XG4gIF9lcnJvcihlcnIpIHtcbiAgICB0aGlzLl9zdG9wUHJvY2VkdXJlKCk7XG4gICAgdGhpcy5fcmVwb3J0RXJyb3IoZXJyKTtcbiAgICBpZiAodGhpcy5fcGFyZW50KSB7XG4gICAgICB0aGlzLnN5c3RlbS5fcmVsYXkodGhpcywgdGhpcy5fcGFyZW50LCBjcmVhdGVFcnJvckFjdG9yRXZlbnQodGhpcy5pZCwgZXJyKSk7XG4gICAgfVxuICB9XG4gIC8vIFRPRE86IGF0bSBjaGlsZHJlbiBkb24ndCBiZWxvbmcgZW50aXJlbHkgdG8gdGhlIGFjdG9yIHNvXG4gIC8vIGluIGEgd2F5IC0gaXQncyBub3QgZXZlbiBzdXBlciBhd2FyZSBvZiB0aGVtXG4gIC8vIHNvIHdlIGNhbid0IHN0b3AgdGhlbSBmcm9tIGhlcmUgYnV0IHdlIHJlYWxseSBzaG91bGQhXG4gIC8vIHJpZ2h0IG5vdywgdGhleSBhcmUgYmVpbmcgc3RvcHBlZCB3aXRoaW4gdGhlIG1hY2hpbmUncyB0cmFuc2l0aW9uXG4gIC8vIGJ1dCB0aGF0IGNvdWxkIHRocm93IGFuZCBsZWF2ZSB1cyB3aXRoIFwib3JwaGFuZWRcIiBhY3RpdmUgYWN0b3JzXG4gIF9zdG9wUHJvY2VkdXJlKCkge1xuICAgIGlmICh0aGlzLl9wcm9jZXNzaW5nU3RhdHVzICE9PSBQcm9jZXNzaW5nU3RhdHVzLlJ1bm5pbmcpIHtcbiAgICAgIC8vIEFjdG9yIGFscmVhZHkgc3RvcHBlZDsgZG8gbm90aGluZ1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQ2FuY2VsIGFsbCBkZWxheWVkIGV2ZW50c1xuICAgIHRoaXMuc3lzdGVtLnNjaGVkdWxlci5jYW5jZWxBbGwodGhpcyk7XG5cbiAgICAvLyBUT0RPOiBtYWlsYm94LnJlc2V0XG4gICAgdGhpcy5tYWlsYm94LmNsZWFyKCk7XG4gICAgLy8gVE9ETzogYWZ0ZXIgYHN0b3BgIHdlIG11c3QgcHJlcGFyZSBvdXJzZWx2ZXMgZm9yIHJlY2VpdmluZyBldmVudHMgYWdhaW5cbiAgICAvLyBldmVudHMgc2VudCAqYWZ0ZXIqIHN0b3Agc2lnbmFsIG11c3QgYmUgcXVldWVkXG4gICAgLy8gaXQgc2VlbXMgbGlrZSB0aGlzIHNob3VsZCBiZSB0aGUgY29tbW9uIGJlaGF2aW9yIGZvciBhbGwgb2Ygb3VyIGNvbnN1bWVyc1xuICAgIC8vIHNvIHBlcmhhcHMgdGhpcyBzaG91bGQgYmUgdW5pZmllZCBzb21laG93IGZvciBhbGwgb2YgdGhlbVxuICAgIHRoaXMubWFpbGJveCA9IG5ldyBNYWlsYm94KHRoaXMuX3Byb2Nlc3MuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcHJvY2Vzc2luZ1N0YXR1cyA9IFByb2Nlc3NpbmdTdGF0dXMuU3RvcHBlZDtcbiAgICB0aGlzLnN5c3RlbS5fdW5yZWdpc3Rlcih0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3NlbmQoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5fcHJvY2Vzc2luZ1N0YXR1cyA9PT0gUHJvY2Vzc2luZ1N0YXR1cy5TdG9wcGVkKSB7XG4gICAgICAvLyBkbyBub3RoaW5nXG4gICAgICB7XG4gICAgICAgIGNvbnN0IGV2ZW50U3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXZlbnQpO1xuICAgICAgICBjb25zb2xlLndhcm4oYEV2ZW50IFwiJHtldmVudC50eXBlfVwiIHdhcyBzZW50IHRvIHN0b3BwZWQgYWN0b3IgXCIke3RoaXMuaWR9ICgke3RoaXMuc2Vzc2lvbklkfSlcIi4gVGhpcyBhY3RvciBoYXMgYWxyZWFkeSByZWFjaGVkIGl0cyBmaW5hbCBzdGF0ZSwgYW5kIHdpbGwgbm90IHRyYW5zaXRpb24uXFxuRXZlbnQ6ICR7ZXZlbnRTdHJpbmd9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubWFpbGJveC5lbnF1ZXVlKGV2ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhbiBldmVudCB0byB0aGUgcnVubmluZyBBY3RvciB0byB0cmlnZ2VyIGEgdHJhbnNpdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCB0byBzZW5kXG4gICAqL1xuICBzZW5kKGV2ZW50KSB7XG4gICAgaWYgKHR5cGVvZiBldmVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgT25seSBldmVudCBvYmplY3RzIG1heSBiZSBzZW50IHRvIGFjdG9yczsgdXNlIC5zZW5kKHsgdHlwZTogXCIke2V2ZW50fVwiIH0pIGluc3RlYWRgKTtcbiAgICB9XG4gICAgdGhpcy5zeXN0ZW0uX3JlbGF5KHVuZGVmaW5lZCwgdGhpcywgZXZlbnQpO1xuICB9XG4gIGF0dGFjaERldlRvb2xzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRldlRvb2xzXG4gICAgfSA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoZGV2VG9vbHMpIHtcbiAgICAgIGNvbnN0IHJlc29sdmVkRGV2VG9vbHNBZGFwdGVyID0gdHlwZW9mIGRldlRvb2xzID09PSAnZnVuY3Rpb24nID8gZGV2VG9vbHMgOiBkZXZUb29sc0FkYXB0ZXI7XG4gICAgICByZXNvbHZlZERldlRvb2xzQWRhcHRlcih0aGlzKTtcbiAgICB9XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICB4c3RhdGUkJHR5cGU6ICQkQUNUT1JfVFlQRSxcbiAgICAgIGlkOiB0aGlzLmlkXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPYnRhaW4gdGhlIGludGVybmFsIHN0YXRlIG9mIHRoZSBhY3Rvciwgd2hpY2ggY2FuIGJlIHBlcnNpc3RlZC5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogVGhlIGludGVybmFsIHN0YXRlIGNhbiBiZSBwZXJzaXN0ZWQgZnJvbSBhbnkgYWN0b3IsIG5vdCBvbmx5IG1hY2hpbmVzLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhlIHBlcnNpc3RlZCBzdGF0ZSBpcyBub3QgdGhlIHNhbWUgYXMgdGhlIHNuYXBzaG90IGZyb21cbiAgICoge0BsaW5rIEFjdG9yLmdldFNuYXBzaG90fS4gUGVyc2lzdGVkIHN0YXRlIHJlcHJlc2VudHMgdGhlIGludGVybmFsIHN0YXRlIG9mXG4gICAqIHRoZSBhY3Rvciwgd2hpbGUgc25hcHNob3RzIHJlcHJlc2VudCB0aGUgYWN0b3IncyBsYXN0IGVtaXR0ZWQgdmFsdWUuXG4gICAqXG4gICAqIENhbiBiZSByZXN0b3JlZCB3aXRoIHtAbGluayBBY3Rvck9wdGlvbnMuc3RhdGV9XG4gICAqIEBzZWUgaHR0cHM6Ly9zdGF0ZWx5LmFpL2RvY3MvcGVyc2lzdGVuY2VcbiAgICovXG5cbiAgZ2V0UGVyc2lzdGVkU25hcHNob3Qob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmxvZ2ljLmdldFBlcnNpc3RlZFNuYXBzaG90KHRoaXMuX3NuYXBzaG90LCBvcHRpb25zKTtcbiAgfVxuICBbc3ltYm9sT2JzZXJ2YWJsZV0oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVhZCBhbiBhY3RvcuKAmXMgc25hcHNob3Qgc3luY2hyb25vdXNseS5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogVGhlIHNuYXBzaG90IHJlcHJlc2VudCBhbiBhY3RvcidzIGxhc3QgZW1pdHRlZCB2YWx1ZS5cbiAgICpcbiAgICogV2hlbiBhbiBhY3RvciByZWNlaXZlcyBhbiBldmVudCwgaXRzIGludGVybmFsIHN0YXRlIG1heSBjaGFuZ2UuIEFuIGFjdG9yXG4gICAqIG1heSBlbWl0IGEgc25hcHNob3Qgd2hlbiBhIHN0YXRlIHRyYW5zaXRpb24gb2NjdXJzLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgc29tZSBhY3RvcnMsIHN1Y2ggYXMgY2FsbGJhY2sgYWN0b3JzIGdlbmVyYXRlZCB3aXRoXG4gICAqIGBmcm9tQ2FsbGJhY2tgLCB3aWxsIG5vdCBlbWl0IHNuYXBzaG90cy5cbiAgICogQHNlZSB7QGxpbmsgQWN0b3Iuc3Vic2NyaWJlfSB0byBzdWJzY3JpYmUgdG8gYW4gYWN0b3LigJlzIHNuYXBzaG90IHZhbHVlcy5cbiAgICogQHNlZSB7QGxpbmsgQWN0b3IuZ2V0UGVyc2lzdGVkU25hcHNob3R9IHRvIHBlcnNpc3QgdGhlIGludGVybmFsIHN0YXRlIG9mIGFuIGFjdG9yICh3aGljaCBpcyBtb3JlIHRoYW4ganVzdCBhIHNuYXBzaG90KS5cbiAgICovXG4gIGdldFNuYXBzaG90KCkge1xuICAgIGlmICghdGhpcy5fc25hcHNob3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgU25hcHNob3QgY2FuJ3QgYmUgcmVhZCB3aGlsZSB0aGUgYWN0b3IgaW5pdGlhbGl6ZXMgaXRzZWxmYCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zbmFwc2hvdDtcbiAgfVxufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGFjdG9yIGluc3RhbmNlIGZvciB0aGUgZ2l2ZW4gYWN0b3IgbG9naWMgd2l0aCB0aGUgcHJvdmlkZWRcbiAqIG9wdGlvbnMsIGlmIGFueS5cbiAqXG4gKiBAcmVtYXJrc1xuICogV2hlbiB5b3UgY3JlYXRlIGFuIGFjdG9yIGZyb20gYWN0b3IgbG9naWMgdmlhIGBjcmVhdGVBY3Rvcihsb2dpYylgLCB5b3VcbiAqIGltcGxpY2l0bHkgY3JlYXRlIGFuIGFjdG9yIHN5c3RlbSB3aGVyZSB0aGUgY3JlYXRlZCBhY3RvciBpcyB0aGUgcm9vdCBhY3Rvci5cbiAqIEFueSBhY3RvcnMgc3Bhd25lZCBmcm9tIHRoaXMgcm9vdCBhY3RvciBhbmQgaXRzIGRlc2NlbmRhbnRzIGFyZSBwYXJ0IG9mIHRoYXRcbiAqIGFjdG9yIHN5c3RlbS5cbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGNyZWF0ZUFjdG9yIH0gZnJvbSAneHN0YXRlJztcbiAqIGltcG9ydCB7IHNvbWVBY3RvckxvZ2ljIH0gZnJvbSAnLi9zb21lQWN0b3JMb2dpYy50cyc7XG4gKlxuICogLy8gQ3JlYXRpbmcgdGhlIGFjdG9yLCB3aGljaCBpbXBsaWNpdGx5IGNyZWF0ZXMgYW4gYWN0b3Igc3lzdGVtIHdpdGggaXRzZWxmIGFzIHRoZSByb290IGFjdG9yXG4gKiBjb25zdCBhY3RvciA9IGNyZWF0ZUFjdG9yKHNvbWVBY3RvckxvZ2ljKTtcbiAqXG4gKiBhY3Rvci5zdWJzY3JpYmUoKHNuYXBzaG90KSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKHNuYXBzaG90KTtcbiAqIH0pO1xuICpcbiAqIC8vIEFjdG9ycyBtdXN0IGJlIHN0YXJ0ZWQgYnkgY2FsbGluZyBgYWN0b3Iuc3RhcnQoKWAsIHdoaWNoIHdpbGwgYWxzbyBzdGFydCB0aGUgYWN0b3Igc3lzdGVtLlxuICogYWN0b3Iuc3RhcnQoKTtcbiAqXG4gKiAvLyBBY3RvcnMgY2FuIHJlY2VpdmUgZXZlbnRzXG4gKiBhY3Rvci5zZW5kKHsgdHlwZTogJ3NvbWVFdmVudCcgfSk7XG4gKlxuICogLy8gWW91IGNhbiBzdG9wIHJvb3QgYWN0b3JzIGJ5IGNhbGxpbmcgYGFjdG9yLnN0b3AoKWAsIHdoaWNoIHdpbGwgYWxzbyBzdG9wIHRoZSBhY3RvciBzeXN0ZW0gYW5kIGFsbCBhY3RvcnMgaW4gdGhhdCBzeXN0ZW0uXG4gKiBhY3Rvci5zdG9wKCk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gbG9naWMgLSBUaGUgYWN0b3IgbG9naWMgdG8gY3JlYXRlIGFuIGFjdG9yIGZyb20uIEZvciBhIHN0YXRlIG1hY2hpbmVcbiAqICAgYWN0b3IgbG9naWMgY3JlYXRvciwgc2VlIHtAbGluayBjcmVhdGVNYWNoaW5lfS4gT3RoZXIgYWN0b3IgbG9naWMgY3JlYXRvcnNcbiAqICAgaW5jbHVkZSB7QGxpbmsgZnJvbUNhbGxiYWNrfSwge0BsaW5rIGZyb21FdmVudE9ic2VydmFibGV9LFxuICogICB7QGxpbmsgZnJvbU9ic2VydmFibGV9LCB7QGxpbmsgZnJvbVByb21pc2V9LCBhbmQge0BsaW5rIGZyb21UcmFuc2l0aW9ufS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gQWN0b3Igb3B0aW9uc1xuICovXG5mdW5jdGlvbiBjcmVhdGVBY3Rvcihsb2dpYywgLi4uW29wdGlvbnNdKSB7XG4gIHJldHVybiBuZXcgQWN0b3IobG9naWMsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgSW50ZXJwcmV0ZXIgaW5zdGFuY2UgZm9yIHRoZSBnaXZlbiBtYWNoaW5lIHdpdGggdGhlIHByb3ZpZGVkXG4gKiBvcHRpb25zLCBpZiBhbnkuXG4gKlxuICogQGRlcHJlY2F0ZWQgVXNlIGBjcmVhdGVBY3RvcmAgaW5zdGVhZFxuICogQGFsaWFzXG4gKi9cbmNvbnN0IGludGVycHJldCA9IGNyZWF0ZUFjdG9yO1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSBgQWN0b3JgIGluc3RlYWQuXG4gKiBAYWxpYXNcbiAqL1xuXG5mdW5jdGlvbiByZXNvbHZlQ2FuY2VsKF8sIHNuYXBzaG90LCBhY3Rpb25BcmdzLCBhY3Rpb25QYXJhbXMsIHtcbiAgc2VuZElkXG59KSB7XG4gIGNvbnN0IHJlc29sdmVkU2VuZElkID0gdHlwZW9mIHNlbmRJZCA9PT0gJ2Z1bmN0aW9uJyA/IHNlbmRJZChhY3Rpb25BcmdzLCBhY3Rpb25QYXJhbXMpIDogc2VuZElkO1xuICByZXR1cm4gW3NuYXBzaG90LCByZXNvbHZlZFNlbmRJZF07XG59XG5mdW5jdGlvbiBleGVjdXRlQ2FuY2VsKGFjdG9yU2NvcGUsIHJlc29sdmVkU2VuZElkKSB7XG4gIGFjdG9yU2NvcGUuZGVmZXIoKCkgPT4ge1xuICAgIGFjdG9yU2NvcGUuc3lzdGVtLnNjaGVkdWxlci5jYW5jZWwoYWN0b3JTY29wZS5zZWxmLCByZXNvbHZlZFNlbmRJZCk7XG4gIH0pO1xufVxuLyoqXG4gKiBDYW5jZWxzIGEgZGVsYXllZCBgc2VuZFRvKC4uLilgIGFjdGlvbiB0aGF0IGlzIHdhaXRpbmcgdG8gYmUgZXhlY3V0ZWQuIFRoZVxuICogY2FuY2VsZWQgYHNlbmRUbyguLi4pYCBhY3Rpb24gd2lsbCBub3Qgc2VuZCBpdHMgZXZlbnQgb3IgZXhlY3V0ZSwgdW5sZXNzIHRoZVxuICogYGRlbGF5YCBoYXMgYWxyZWFkeSBlbGFwc2VkIGJlZm9yZSBgY2FuY2VsKC4uLilgIGlzIGNhbGxlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBjcmVhdGVNYWNoaW5lLCBzZW5kVG8sIGNhbmNlbCB9IGZyb20gJ3hzdGF0ZSc7XG4gKlxuICogY29uc3QgbWFjaGluZSA9IGNyZWF0ZU1hY2hpbmUoe1xuICogICAvLyAuLi5cbiAqICAgb246IHtcbiAqICAgICBzZW5kRXZlbnQ6IHtcbiAqICAgICAgIGFjdGlvbnM6IHNlbmRUbyhcbiAqICAgICAgICAgJ3NvbWUtYWN0b3InLFxuICogICAgICAgICB7IHR5cGU6ICdzb21lRXZlbnQnIH0sXG4gKiAgICAgICAgIHtcbiAqICAgICAgICAgICBpZDogJ3NvbWUtaWQnLFxuICogICAgICAgICAgIGRlbGF5OiAxMDAwXG4gKiAgICAgICAgIH1cbiAqICAgICAgIClcbiAqICAgICB9LFxuICogICAgIGNhbmNlbEV2ZW50OiB7XG4gKiAgICAgICBhY3Rpb25zOiBjYW5jZWwoJ3NvbWUtaWQnKVxuICogICAgIH1cbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2VuZElkIFRoZSBgaWRgIG9mIHRoZSBgc2VuZFRvKC4uLilgIGFjdGlvbiB0byBjYW5jZWwuXG4gKi9cbmZ1bmN0aW9uIGNhbmNlbChzZW5kSWQpIHtcbiAgZnVuY3Rpb24gY2FuY2VsKGFyZ3MsIHBhcmFtcykge1xuICAgIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhpcyBpc24ndCBzdXBwb3NlZCB0byBiZSBjYWxsZWRgKTtcbiAgICB9XG4gIH1cbiAgY2FuY2VsLnR5cGUgPSAneHN0YXRlLmNhbmNlbCc7XG4gIGNhbmNlbC5zZW5kSWQgPSBzZW5kSWQ7XG4gIGNhbmNlbC5yZXNvbHZlID0gcmVzb2x2ZUNhbmNlbDtcbiAgY2FuY2VsLmV4ZWN1dGUgPSBleGVjdXRlQ2FuY2VsO1xuICByZXR1cm4gY2FuY2VsO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlU3Bhd24oYWN0b3JTY29wZSwgc25hcHNob3QsIGFjdGlvbkFyZ3MsIF9hY3Rpb25QYXJhbXMsIHtcbiAgaWQsXG4gIHN5c3RlbUlkLFxuICBzcmMsXG4gIGlucHV0LFxuICBzeW5jU25hcHNob3Rcbn0pIHtcbiAgY29uc3QgbG9naWMgPSB0eXBlb2Ygc3JjID09PSAnc3RyaW5nJyA/IHJlc29sdmVSZWZlcmVuY2VkQWN0b3Ioc25hcHNob3QubWFjaGluZSwgc3JjKSA6IHNyYztcbiAgY29uc3QgcmVzb2x2ZWRJZCA9IHR5cGVvZiBpZCA9PT0gJ2Z1bmN0aW9uJyA/IGlkKGFjdGlvbkFyZ3MpIDogaWQ7XG4gIGxldCBhY3RvclJlZjtcbiAgaWYgKGxvZ2ljKSB7XG4gICAgYWN0b3JSZWYgPSBjcmVhdGVBY3Rvcihsb2dpYywge1xuICAgICAgaWQ6IHJlc29sdmVkSWQsXG4gICAgICBzcmMsXG4gICAgICBwYXJlbnQ6IGFjdG9yU2NvcGUuc2VsZixcbiAgICAgIHN5bmNTbmFwc2hvdCxcbiAgICAgIHN5c3RlbUlkLFxuICAgICAgaW5wdXQ6IHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJyA/IGlucHV0KHtcbiAgICAgICAgY29udGV4dDogc25hcHNob3QuY29udGV4dCxcbiAgICAgICAgZXZlbnQ6IGFjdGlvbkFyZ3MuZXZlbnQsXG4gICAgICAgIHNlbGY6IGFjdG9yU2NvcGUuc2VsZlxuICAgICAgfSkgOiBpbnB1dFxuICAgIH0pO1xuICB9XG4gIGlmICghYWN0b3JSZWYpIHtcbiAgICBjb25zb2xlLndhcm4oYEFjdG9yIHR5cGUgJyR7c3JjfScgbm90IGZvdW5kIGluIG1hY2hpbmUgJyR7YWN0b3JTY29wZS5pZH0nLmApO1xuICB9XG4gIHJldHVybiBbY2xvbmVNYWNoaW5lU25hcHNob3Qoc25hcHNob3QsIHtcbiAgICBjaGlsZHJlbjoge1xuICAgICAgLi4uc25hcHNob3QuY2hpbGRyZW4sXG4gICAgICBbcmVzb2x2ZWRJZF06IGFjdG9yUmVmXG4gICAgfVxuICB9KSwge1xuICAgIGlkLFxuICAgIGFjdG9yUmVmXG4gIH1dO1xufVxuZnVuY3Rpb24gZXhlY3V0ZVNwYXduKGFjdG9yU2NvcGUsIHtcbiAgaWQsXG4gIGFjdG9yUmVmXG59KSB7XG4gIGlmICghYWN0b3JSZWYpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYWN0b3JTY29wZS5kZWZlcigoKSA9PiB7XG4gICAgaWYgKGFjdG9yUmVmLl9wcm9jZXNzaW5nU3RhdHVzID09PSBQcm9jZXNzaW5nU3RhdHVzLlN0b3BwZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYWN0b3JSZWYuc3RhcnQoKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBzcGF3bkNoaWxkKC4uLltzcmMsIHtcbiAgaWQsXG4gIHN5c3RlbUlkLFxuICBpbnB1dCxcbiAgc3luY1NuYXBzaG90ID0gZmFsc2Vcbn0gPSB7fV0pIHtcbiAgZnVuY3Rpb24gc3Bhd25DaGlsZChhcmdzLCBwYXJhbXMpIHtcbiAgICB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgaXNuJ3Qgc3VwcG9zZWQgdG8gYmUgY2FsbGVkYCk7XG4gICAgfVxuICB9XG4gIHNwYXduQ2hpbGQudHlwZSA9ICdzbmFwc2hvdC5zcGF3bkNoaWxkJztcbiAgc3Bhd25DaGlsZC5pZCA9IGlkO1xuICBzcGF3bkNoaWxkLnN5c3RlbUlkID0gc3lzdGVtSWQ7XG4gIHNwYXduQ2hpbGQuc3JjID0gc3JjO1xuICBzcGF3bkNoaWxkLmlucHV0ID0gaW5wdXQ7XG4gIHNwYXduQ2hpbGQuc3luY1NuYXBzaG90ID0gc3luY1NuYXBzaG90O1xuICBzcGF3bkNoaWxkLnJlc29sdmUgPSByZXNvbHZlU3Bhd247XG4gIHNwYXduQ2hpbGQuZXhlY3V0ZSA9IGV4ZWN1dGVTcGF3bjtcbiAgcmV0dXJuIHNwYXduQ2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVTdG9wKF8sIHNuYXBzaG90LCBhcmdzLCBhY3Rpb25QYXJhbXMsIHtcbiAgYWN0b3JSZWZcbn0pIHtcbiAgY29uc3QgYWN0b3JSZWZPclN0cmluZyA9IHR5cGVvZiBhY3RvclJlZiA9PT0gJ2Z1bmN0aW9uJyA/IGFjdG9yUmVmKGFyZ3MsIGFjdGlvblBhcmFtcykgOiBhY3RvclJlZjtcbiAgY29uc3QgcmVzb2x2ZWRBY3RvclJlZiA9IHR5cGVvZiBhY3RvclJlZk9yU3RyaW5nID09PSAnc3RyaW5nJyA/IHNuYXBzaG90LmNoaWxkcmVuW2FjdG9yUmVmT3JTdHJpbmddIDogYWN0b3JSZWZPclN0cmluZztcbiAgbGV0IGNoaWxkcmVuID0gc25hcHNob3QuY2hpbGRyZW47XG4gIGlmIChyZXNvbHZlZEFjdG9yUmVmKSB7XG4gICAgY2hpbGRyZW4gPSB7XG4gICAgICAuLi5jaGlsZHJlblxuICAgIH07XG4gICAgZGVsZXRlIGNoaWxkcmVuW3Jlc29sdmVkQWN0b3JSZWYuaWRdO1xuICB9XG4gIHJldHVybiBbY2xvbmVNYWNoaW5lU25hcHNob3Qoc25hcHNob3QsIHtcbiAgICBjaGlsZHJlblxuICB9KSwgcmVzb2x2ZWRBY3RvclJlZl07XG59XG5mdW5jdGlvbiBleGVjdXRlU3RvcChhY3RvclNjb3BlLCBhY3RvclJlZikge1xuICBpZiAoIWFjdG9yUmVmKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gd2UgbmVlZCB0byBlYWdlcmx5IHVucmVnaXN0ZXIgaXQgaGVyZSBzbyBhIG5ldyBhY3RvciB3aXRoIHRoZSBzYW1lIHN5c3RlbUlkIGNhbiBiZSByZWdpc3RlcmVkIGltbWVkaWF0ZWx5XG4gIC8vIHNpbmNlIHdlIGRlZmVyIGFjdHVhbCBzdG9wcGluZyBvZiB0aGUgYWN0b3IgYnV0IHdlIGRvbid0IGRlZmVyIGFjdG9yIGNyZWF0aW9ucyAoYW5kIHdlIGNhbid0IGRvIHRoYXQpXG4gIC8vIHRoaXMgY291bGQgdGhyb3cgb24gYHN5c3RlbUlkYCBjb2xsaXNpb24sIGZvciBleGFtcGxlLCB3aGVuIGRlYWxpbmcgd2l0aCByZWVudGVyaW5nIHRyYW5zaXRpb25zXG4gIGFjdG9yU2NvcGUuc3lzdGVtLl91bnJlZ2lzdGVyKGFjdG9yUmVmKTtcblxuICAvLyB0aGlzIGFsbG93cyB1cyB0byBwcmV2ZW50IGFuIGFjdG9yIGZyb20gYmVpbmcgc3RhcnRlZCBpZiBpdCBnZXRzIHN0b3BwZWQgd2l0aGluIHRoZSBzYW1lIG1hY3Jvc3RlcFxuICAvLyB0aGlzIGNhbiBoYXBwZW4sIGZvciBleGFtcGxlLCB3aGVuIHRoZSBpbnZva2luZyBzdGF0ZSBpcyBiZWluZyBleGl0ZWQgaW1tZWRpYXRlbHkgYnkgYW4gYWx3YXlzIHRyYW5zaXRpb25cbiAgaWYgKGFjdG9yUmVmLl9wcm9jZXNzaW5nU3RhdHVzICE9PSBQcm9jZXNzaW5nU3RhdHVzLlJ1bm5pbmcpIHtcbiAgICBhY3RvclNjb3BlLnN0b3BDaGlsZChhY3RvclJlZik7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIHN0b3BwaW5nIGEgY2hpbGQgZW5xdWV1ZXMgYSBzdG9wIGV2ZW50IGluIHRoZSBjaGlsZCBhY3RvcidzIG1haWxib3hcbiAgLy8gd2UgbmVlZCBmb3IgYWxsIG9mIHRoZSBhbHJlYWR5IGVucXVldWVkIGV2ZW50cyB0byBiZSBwcm9jZXNzZWQgYmVmb3JlIHdlIHN0b3AgdGhlIGNoaWxkXG4gIC8vIHRoZSBwYXJlbnQgaXRzZWxmIG1pZ2h0IHdhbnQgdG8gc2VuZCBzb21lIGV2ZW50cyB0byBhIGNoaWxkIChmb3IgZXhhbXBsZSBmcm9tIGV4aXQgYWN0aW9ucyBvbiB0aGUgaW52b2tpbmcgc3RhdGUpXG4gIC8vIGFuZCB3ZSBkb24ndCB3YW50IHRvIGlnbm9yZSB0aG9zZSBldmVudHNcbiAgYWN0b3JTY29wZS5kZWZlcigoKSA9PiB7XG4gICAgYWN0b3JTY29wZS5zdG9wQ2hpbGQoYWN0b3JSZWYpO1xuICB9KTtcbn1cbi8qKlxuICogU3RvcHMgYSBjaGlsZCBhY3Rvci5cbiAqXG4gKiBAcGFyYW0gYWN0b3JSZWYgVGhlIGFjdG9yIHRvIHN0b3AuXG4gKi9cbmZ1bmN0aW9uIHN0b3BDaGlsZChhY3RvclJlZikge1xuICBmdW5jdGlvbiBzdG9wKGFyZ3MsIHBhcmFtcykge1xuICAgIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhpcyBpc24ndCBzdXBwb3NlZCB0byBiZSBjYWxsZWRgKTtcbiAgICB9XG4gIH1cbiAgc3RvcC50eXBlID0gJ3hzdGF0ZS5zdG9wQ2hpbGQnO1xuICBzdG9wLmFjdG9yUmVmID0gYWN0b3JSZWY7XG4gIHN0b3AucmVzb2x2ZSA9IHJlc29sdmVTdG9wO1xuICBzdG9wLmV4ZWN1dGUgPSBleGVjdXRlU3RvcDtcbiAgcmV0dXJuIHN0b3A7XG59XG5cbi8qKlxuICogU3RvcHMgYSBjaGlsZCBhY3Rvci5cbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgYHN0b3BDaGlsZCguLi4pYCBpbnN0ZWFkXG4gKiBAYWxpYXNcbiAqL1xuY29uc3Qgc3RvcCA9IHN0b3BDaGlsZDtcblxuZnVuY3Rpb24gY2hlY2tTdGF0ZUluKHNuYXBzaG90LCBfLCB7XG4gIHN0YXRlVmFsdWVcbn0pIHtcbiAgaWYgKHR5cGVvZiBzdGF0ZVZhbHVlID09PSAnc3RyaW5nJyAmJiBpc1N0YXRlSWQoc3RhdGVWYWx1ZSkpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBzbmFwc2hvdC5tYWNoaW5lLmdldFN0YXRlTm9kZUJ5SWQoc3RhdGVWYWx1ZSk7XG4gICAgcmV0dXJuIHNuYXBzaG90Ll9ub2Rlcy5zb21lKHNuID0+IHNuID09PSB0YXJnZXQpO1xuICB9XG4gIHJldHVybiBzbmFwc2hvdC5tYXRjaGVzKHN0YXRlVmFsdWUpO1xufVxuZnVuY3Rpb24gc3RhdGVJbihzdGF0ZVZhbHVlKSB7XG4gIGZ1bmN0aW9uIHN0YXRlSW4oYXJncywgcGFyYW1zKSB7XG4gICAge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIGlzbid0IHN1cHBvc2VkIHRvIGJlIGNhbGxlZGApO1xuICAgIH1cbiAgfVxuICBzdGF0ZUluLmNoZWNrID0gY2hlY2tTdGF0ZUluO1xuICBzdGF0ZUluLnN0YXRlVmFsdWUgPSBzdGF0ZVZhbHVlO1xuICByZXR1cm4gc3RhdGVJbjtcbn1cbmZ1bmN0aW9uIGNoZWNrTm90KHNuYXBzaG90LCB7XG4gIGNvbnRleHQsXG4gIGV2ZW50XG59LCB7XG4gIGd1YXJkc1xufSkge1xuICByZXR1cm4gIWV2YWx1YXRlR3VhcmQoZ3VhcmRzWzBdLCBjb250ZXh0LCBldmVudCwgc25hcHNob3QpO1xufVxuXG4vKipcbiAqIEhpZ2hlci1vcmRlciBndWFyZCB0aGF0IGV2YWx1YXRlcyB0byBgdHJ1ZWAgaWYgdGhlIGBndWFyZGAgcGFzc2VkIHRvIGl0XG4gKiBldmFsdWF0ZXMgdG8gYGZhbHNlYC5cbiAqXG4gKiBAY2F0ZWdvcnkgR3VhcmRzXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBzZXR1cCwgbm90IH0gZnJvbSAneHN0YXRlJztcbiAqXG4gKiBjb25zdCBtYWNoaW5lID0gc2V0dXAoe1xuICogICBndWFyZHM6IHtcbiAqICAgICBzb21lTmFtZWRHdWFyZDogKCkgPT4gZmFsc2VcbiAqICAgfVxuICogfSkuY3JlYXRlTWFjaGluZSh7XG4gKiAgIG9uOiB7XG4gKiAgICAgc29tZUV2ZW50OiB7XG4gKiAgICAgICBndWFyZDogbm90KCdzb21lTmFtZWRHdWFyZCcpLFxuICogICAgICAgYWN0aW9uczogKCkgPT4ge1xuICogICAgICAgICAvLyB3aWxsIGJlIGV4ZWN1dGVkIGlmIGd1YXJkIGluIGBub3QoLi4uKWBcbiAqICAgICAgICAgLy8gZXZhbHVhdGVzIHRvIGBmYWxzZWBcbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHJldHVybnMgQSBndWFyZFxuICovXG5mdW5jdGlvbiBub3QoZ3VhcmQpIHtcbiAgZnVuY3Rpb24gbm90KGFyZ3MsIHBhcmFtcykge1xuICAgIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhpcyBpc24ndCBzdXBwb3NlZCB0byBiZSBjYWxsZWRgKTtcbiAgICB9XG4gIH1cbiAgbm90LmNoZWNrID0gY2hlY2tOb3Q7XG4gIG5vdC5ndWFyZHMgPSBbZ3VhcmRdO1xuICByZXR1cm4gbm90O1xufVxuZnVuY3Rpb24gY2hlY2tBbmQoc25hcHNob3QsIHtcbiAgY29udGV4dCxcbiAgZXZlbnRcbn0sIHtcbiAgZ3VhcmRzXG59KSB7XG4gIHJldHVybiBndWFyZHMuZXZlcnkoZ3VhcmQgPT4gZXZhbHVhdGVHdWFyZChndWFyZCwgY29udGV4dCwgZXZlbnQsIHNuYXBzaG90KSk7XG59XG5cbi8qKlxuICogSGlnaGVyLW9yZGVyIGd1YXJkIHRoYXQgZXZhbHVhdGVzIHRvIGB0cnVlYCBpZiBhbGwgYGd1YXJkc2AgcGFzc2VkIHRvIGl0XG4gKiBldmFsdWF0ZSB0byBgdHJ1ZWAuXG4gKlxuICogQGNhdGVnb3J5IEd1YXJkc1xuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgc2V0dXAsIGFuZCB9IGZyb20gJ3hzdGF0ZSc7XG4gKlxuICogY29uc3QgbWFjaGluZSA9IHNldHVwKHtcbiAqICAgZ3VhcmRzOiB7XG4gKiAgICAgc29tZU5hbWVkR3VhcmQ6ICgpID0+IHRydWVcbiAqICAgfVxuICogfSkuY3JlYXRlTWFjaGluZSh7XG4gKiAgIG9uOiB7XG4gKiAgICAgc29tZUV2ZW50OiB7XG4gKiAgICAgICBndWFyZDogYW5kKFsoeyBjb250ZXh0IH0pID0+IGNvbnRleHQudmFsdWUgPiAwLCAnc29tZU5hbWVkR3VhcmQnXSksXG4gKiAgICAgICBhY3Rpb25zOiAoKSA9PiB7XG4gKiAgICAgICAgIC8vIHdpbGwgYmUgZXhlY3V0ZWQgaWYgYWxsIGd1YXJkcyBpbiBgYW5kKC4uLilgXG4gKiAgICAgICAgIC8vIGV2YWx1YXRlIHRvIHRydWVcbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHJldHVybnMgQSBndWFyZCBhY3Rpb24gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGFuZChndWFyZHMpIHtcbiAgZnVuY3Rpb24gYW5kKGFyZ3MsIHBhcmFtcykge1xuICAgIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhpcyBpc24ndCBzdXBwb3NlZCB0byBiZSBjYWxsZWRgKTtcbiAgICB9XG4gIH1cbiAgYW5kLmNoZWNrID0gY2hlY2tBbmQ7XG4gIGFuZC5ndWFyZHMgPSBndWFyZHM7XG4gIHJldHVybiBhbmQ7XG59XG5mdW5jdGlvbiBjaGVja09yKHNuYXBzaG90LCB7XG4gIGNvbnRleHQsXG4gIGV2ZW50XG59LCB7XG4gIGd1YXJkc1xufSkge1xuICByZXR1cm4gZ3VhcmRzLnNvbWUoZ3VhcmQgPT4gZXZhbHVhdGVHdWFyZChndWFyZCwgY29udGV4dCwgZXZlbnQsIHNuYXBzaG90KSk7XG59XG5cbi8qKlxuICogSGlnaGVyLW9yZGVyIGd1YXJkIHRoYXQgZXZhbHVhdGVzIHRvIGB0cnVlYCBpZiBhbnkgb2YgdGhlIGBndWFyZHNgIHBhc3NlZCB0b1xuICogaXQgZXZhbHVhdGUgdG8gYHRydWVgLlxuICpcbiAqIEBjYXRlZ29yeSBHdWFyZHNcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IHNldHVwLCBvciB9IGZyb20gJ3hzdGF0ZSc7XG4gKlxuICogY29uc3QgbWFjaGluZSA9IHNldHVwKHtcbiAqICAgZ3VhcmRzOiB7XG4gKiAgICAgc29tZU5hbWVkR3VhcmQ6ICgpID0+IHRydWVcbiAqICAgfVxuICogfSkuY3JlYXRlTWFjaGluZSh7XG4gKiAgIG9uOiB7XG4gKiAgICAgc29tZUV2ZW50OiB7XG4gKiAgICAgICBndWFyZDogb3IoWyh7IGNvbnRleHQgfSkgPT4gY29udGV4dC52YWx1ZSA+IDAsICdzb21lTmFtZWRHdWFyZCddKSxcbiAqICAgICAgIGFjdGlvbnM6ICgpID0+IHtcbiAqICAgICAgICAgLy8gd2lsbCBiZSBleGVjdXRlZCBpZiBhbnkgb2YgdGhlIGd1YXJkcyBpbiBgb3IoLi4uKWBcbiAqICAgICAgICAgLy8gZXZhbHVhdGUgdG8gdHJ1ZVxuICogICAgICAgfVxuICogICAgIH1cbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAcmV0dXJucyBBIGd1YXJkIGFjdGlvbiBvYmplY3RcbiAqL1xuZnVuY3Rpb24gb3IoZ3VhcmRzKSB7XG4gIGZ1bmN0aW9uIG9yKGFyZ3MsIHBhcmFtcykge1xuICAgIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhpcyBpc24ndCBzdXBwb3NlZCB0byBiZSBjYWxsZWRgKTtcbiAgICB9XG4gIH1cbiAgb3IuY2hlY2sgPSBjaGVja09yO1xuICBvci5ndWFyZHMgPSBndWFyZHM7XG4gIHJldHVybiBvcjtcbn1cblxuLy8gVE9ETzogdGhyb3cgb24gY3ljbGVzIChkZXB0aCBjaGVjayBzaG91bGQgYmUgZW5vdWdoKVxuZnVuY3Rpb24gZXZhbHVhdGVHdWFyZChndWFyZCwgY29udGV4dCwgZXZlbnQsIHNuYXBzaG90KSB7XG4gIGNvbnN0IHtcbiAgICBtYWNoaW5lXG4gIH0gPSBzbmFwc2hvdDtcbiAgY29uc3QgaXNJbmxpbmUgPSB0eXBlb2YgZ3VhcmQgPT09ICdmdW5jdGlvbic7XG4gIGNvbnN0IHJlc29sdmVkID0gaXNJbmxpbmUgPyBndWFyZCA6IG1hY2hpbmUuaW1wbGVtZW50YXRpb25zLmd1YXJkc1t0eXBlb2YgZ3VhcmQgPT09ICdzdHJpbmcnID8gZ3VhcmQgOiBndWFyZC50eXBlXTtcbiAgaWYgKCFpc0lubGluZSAmJiAhcmVzb2x2ZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEd1YXJkICcke3R5cGVvZiBndWFyZCA9PT0gJ3N0cmluZycgPyBndWFyZCA6IGd1YXJkLnR5cGV9JyBpcyBub3QgaW1wbGVtZW50ZWQuJy5gKTtcbiAgfVxuICBpZiAodHlwZW9mIHJlc29sdmVkICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGV2YWx1YXRlR3VhcmQocmVzb2x2ZWQsIGNvbnRleHQsIGV2ZW50LCBzbmFwc2hvdCk7XG4gIH1cbiAgY29uc3QgZ3VhcmRBcmdzID0ge1xuICAgIGNvbnRleHQsXG4gICAgZXZlbnRcbiAgfTtcbiAgY29uc3QgZ3VhcmRQYXJhbXMgPSBpc0lubGluZSB8fCB0eXBlb2YgZ3VhcmQgPT09ICdzdHJpbmcnID8gdW5kZWZpbmVkIDogJ3BhcmFtcycgaW4gZ3VhcmQgPyB0eXBlb2YgZ3VhcmQucGFyYW1zID09PSAnZnVuY3Rpb24nID8gZ3VhcmQucGFyYW1zKHtcbiAgICBjb250ZXh0LFxuICAgIGV2ZW50XG4gIH0pIDogZ3VhcmQucGFyYW1zIDogdW5kZWZpbmVkO1xuICBpZiAoISgnY2hlY2snIGluIHJlc29sdmVkKSkge1xuICAgIC8vIHRoZSBleGlzdGluZyB0eXBlIG9mIGAuZ3VhcmRzYCBhc3N1bWVzIG5vbi1udWxsYWJsZSBgVEV4cHJlc3Npb25HdWFyZGBcbiAgICAvLyBpbmxpbmUgZ3VhcmRzIGV4cGVjdCBgVEV4cHJlc3Npb25HdWFyZGAgdG8gYmUgc2V0IHRvIGB1bmRlZmluZWRgXG4gICAgLy8gaXQncyBmaW5lIHRvIGNhc3QgdGhpcyBoZXJlLCBvdXIgbG9naWMgbWFrZXMgc3VyZSB0aGF0IHdlIGNhbGwgdGhvc2UgMiBcInZhcmlhbnRzXCIgY29ycmVjdGx5XG4gICAgcmV0dXJuIHJlc29sdmVkKGd1YXJkQXJncywgZ3VhcmRQYXJhbXMpO1xuICB9XG4gIGNvbnN0IGJ1aWx0aW5HdWFyZCA9IHJlc29sdmVkO1xuICByZXR1cm4gYnVpbHRpbkd1YXJkLmNoZWNrKHNuYXBzaG90LCBndWFyZEFyZ3MsIHJlc29sdmVkIC8vIHRoaXMgaG9sZHMgYWxsIHBhcmFtc1xuICApO1xufVxuXG5jb25zdCBpc0F0b21pY1N0YXRlTm9kZSA9IHN0YXRlTm9kZSA9PiBzdGF0ZU5vZGUudHlwZSA9PT0gJ2F0b21pYycgfHwgc3RhdGVOb2RlLnR5cGUgPT09ICdmaW5hbCc7XG5mdW5jdGlvbiBnZXRDaGlsZHJlbihzdGF0ZU5vZGUpIHtcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMoc3RhdGVOb2RlLnN0YXRlcykuZmlsdGVyKHNuID0+IHNuLnR5cGUgIT09ICdoaXN0b3J5Jyk7XG59XG5mdW5jdGlvbiBnZXRQcm9wZXJBbmNlc3RvcnMoc3RhdGVOb2RlLCB0b1N0YXRlTm9kZSkge1xuICBjb25zdCBhbmNlc3RvcnMgPSBbXTtcbiAgaWYgKHRvU3RhdGVOb2RlID09PSBzdGF0ZU5vZGUpIHtcbiAgICByZXR1cm4gYW5jZXN0b3JzO1xuICB9XG5cbiAgLy8gYWRkIGFsbCBhbmNlc3RvcnNcbiAgbGV0IG0gPSBzdGF0ZU5vZGUucGFyZW50O1xuICB3aGlsZSAobSAmJiBtICE9PSB0b1N0YXRlTm9kZSkge1xuICAgIGFuY2VzdG9ycy5wdXNoKG0pO1xuICAgIG0gPSBtLnBhcmVudDtcbiAgfVxuICByZXR1cm4gYW5jZXN0b3JzO1xufVxuZnVuY3Rpb24gZ2V0QWxsU3RhdGVOb2RlcyhzdGF0ZU5vZGVzKSB7XG4gIGNvbnN0IG5vZGVTZXQgPSBuZXcgU2V0KHN0YXRlTm9kZXMpO1xuICBjb25zdCBhZGpMaXN0ID0gZ2V0QWRqTGlzdChub2RlU2V0KTtcblxuICAvLyBhZGQgZGVzY2VuZGFudHNcbiAgZm9yIChjb25zdCBzIG9mIG5vZGVTZXQpIHtcbiAgICAvLyBpZiBwcmV2aW91c2x5IGFjdGl2ZSwgYWRkIGV4aXN0aW5nIGNoaWxkIG5vZGVzXG4gICAgaWYgKHMudHlwZSA9PT0gJ2NvbXBvdW5kJyAmJiAoIWFkakxpc3QuZ2V0KHMpIHx8ICFhZGpMaXN0LmdldChzKS5sZW5ndGgpKSB7XG4gICAgICBnZXRJbml0aWFsU3RhdGVOb2Rlc1dpdGhUaGVpckFuY2VzdG9ycyhzKS5mb3JFYWNoKHNuID0+IG5vZGVTZXQuYWRkKHNuKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzLnR5cGUgPT09ICdwYXJhbGxlbCcpIHtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBnZXRDaGlsZHJlbihzKSkge1xuICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSAnaGlzdG9yeScpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIW5vZGVTZXQuaGFzKGNoaWxkKSkge1xuICAgICAgICAgICAgY29uc3QgaW5pdGlhbFN0YXRlcyA9IGdldEluaXRpYWxTdGF0ZU5vZGVzV2l0aFRoZWlyQW5jZXN0b3JzKGNoaWxkKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaW5pdGlhbFN0YXRlTm9kZSBvZiBpbml0aWFsU3RhdGVzKSB7XG4gICAgICAgICAgICAgIG5vZGVTZXQuYWRkKGluaXRpYWxTdGF0ZU5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGFkZCBhbGwgYW5jZXN0b3JzXG4gIGZvciAoY29uc3QgcyBvZiBub2RlU2V0KSB7XG4gICAgbGV0IG0gPSBzLnBhcmVudDtcbiAgICB3aGlsZSAobSkge1xuICAgICAgbm9kZVNldC5hZGQobSk7XG4gICAgICBtID0gbS5wYXJlbnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBub2RlU2V0O1xufVxuZnVuY3Rpb24gZ2V0VmFsdWVGcm9tQWRqKGJhc2VOb2RlLCBhZGpMaXN0KSB7XG4gIGNvbnN0IGNoaWxkU3RhdGVOb2RlcyA9IGFkakxpc3QuZ2V0KGJhc2VOb2RlKTtcbiAgaWYgKCFjaGlsZFN0YXRlTm9kZXMpIHtcbiAgICByZXR1cm4ge307IC8vIHRvZG86IGZpeD9cbiAgfVxuICBpZiAoYmFzZU5vZGUudHlwZSA9PT0gJ2NvbXBvdW5kJykge1xuICAgIGNvbnN0IGNoaWxkU3RhdGVOb2RlID0gY2hpbGRTdGF0ZU5vZGVzWzBdO1xuICAgIGlmIChjaGlsZFN0YXRlTm9kZSkge1xuICAgICAgaWYgKGlzQXRvbWljU3RhdGVOb2RlKGNoaWxkU3RhdGVOb2RlKSkge1xuICAgICAgICByZXR1cm4gY2hpbGRTdGF0ZU5vZGUua2V5O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9XG4gIGNvbnN0IHN0YXRlVmFsdWUgPSB7fTtcbiAgZm9yIChjb25zdCBjaGlsZFN0YXRlTm9kZSBvZiBjaGlsZFN0YXRlTm9kZXMpIHtcbiAgICBzdGF0ZVZhbHVlW2NoaWxkU3RhdGVOb2RlLmtleV0gPSBnZXRWYWx1ZUZyb21BZGooY2hpbGRTdGF0ZU5vZGUsIGFkakxpc3QpO1xuICB9XG4gIHJldHVybiBzdGF0ZVZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0QWRqTGlzdChzdGF0ZU5vZGVzKSB7XG4gIGNvbnN0IGFkakxpc3QgPSBuZXcgTWFwKCk7XG4gIGZvciAoY29uc3QgcyBvZiBzdGF0ZU5vZGVzKSB7XG4gICAgaWYgKCFhZGpMaXN0LmhhcyhzKSkge1xuICAgICAgYWRqTGlzdC5zZXQocywgW10pO1xuICAgIH1cbiAgICBpZiAocy5wYXJlbnQpIHtcbiAgICAgIGlmICghYWRqTGlzdC5oYXMocy5wYXJlbnQpKSB7XG4gICAgICAgIGFkakxpc3Quc2V0KHMucGFyZW50LCBbXSk7XG4gICAgICB9XG4gICAgICBhZGpMaXN0LmdldChzLnBhcmVudCkucHVzaChzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFkakxpc3Q7XG59XG5mdW5jdGlvbiBnZXRTdGF0ZVZhbHVlKHJvb3ROb2RlLCBzdGF0ZU5vZGVzKSB7XG4gIGNvbnN0IGNvbmZpZyA9IGdldEFsbFN0YXRlTm9kZXMoc3RhdGVOb2Rlcyk7XG4gIHJldHVybiBnZXRWYWx1ZUZyb21BZGoocm9vdE5vZGUsIGdldEFkakxpc3QoY29uZmlnKSk7XG59XG5mdW5jdGlvbiBpc0luRmluYWxTdGF0ZShzdGF0ZU5vZGVTZXQsIHN0YXRlTm9kZSkge1xuICBpZiAoc3RhdGVOb2RlLnR5cGUgPT09ICdjb21wb3VuZCcpIHtcbiAgICByZXR1cm4gZ2V0Q2hpbGRyZW4oc3RhdGVOb2RlKS5zb21lKHMgPT4gcy50eXBlID09PSAnZmluYWwnICYmIHN0YXRlTm9kZVNldC5oYXMocykpO1xuICB9XG4gIGlmIChzdGF0ZU5vZGUudHlwZSA9PT0gJ3BhcmFsbGVsJykge1xuICAgIHJldHVybiBnZXRDaGlsZHJlbihzdGF0ZU5vZGUpLmV2ZXJ5KHNuID0+IGlzSW5GaW5hbFN0YXRlKHN0YXRlTm9kZVNldCwgc24pKTtcbiAgfVxuICByZXR1cm4gc3RhdGVOb2RlLnR5cGUgPT09ICdmaW5hbCc7XG59XG5jb25zdCBpc1N0YXRlSWQgPSBzdHIgPT4gc3RyWzBdID09PSBTVEFURV9JREVOVElGSUVSO1xuZnVuY3Rpb24gZ2V0Q2FuZGlkYXRlcyhzdGF0ZU5vZGUsIHJlY2VpdmVkRXZlbnRUeXBlKSB7XG4gIGNvbnN0IGNhbmRpZGF0ZXMgPSBzdGF0ZU5vZGUudHJhbnNpdGlvbnMuZ2V0KHJlY2VpdmVkRXZlbnRUeXBlKSB8fCBbLi4uc3RhdGVOb2RlLnRyYW5zaXRpb25zLmtleXMoKV0uZmlsdGVyKGV2ZW50RGVzY3JpcHRvciA9PiB7XG4gICAgLy8gY2hlY2sgaWYgdHJhbnNpdGlvbiBpcyBhIHdpbGRjYXJkIHRyYW5zaXRpb24sXG4gICAgLy8gd2hpY2ggbWF0Y2hlcyBhbnkgbm9uLXRyYW5zaWVudCBldmVudHNcbiAgICBpZiAoZXZlbnREZXNjcmlwdG9yID09PSBXSUxEQ0FSRCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghZXZlbnREZXNjcmlwdG9yLmVuZHNXaXRoKCcuKicpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICgvLipcXCouKy8udGVzdChldmVudERlc2NyaXB0b3IpKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFdpbGRjYXJkcyBjYW4gb25seSBiZSB0aGUgbGFzdCB0b2tlbiBvZiBhbiBldmVudCBkZXNjcmlwdG9yIChlLmcuLCBcImV2ZW50LipcIikgb3IgdGhlIGVudGlyZSBldmVudCBkZXNjcmlwdG9yIChcIipcIikuIENoZWNrIHRoZSBcIiR7ZXZlbnREZXNjcmlwdG9yfVwiIGV2ZW50LmApO1xuICAgIH1cbiAgICBjb25zdCBwYXJ0aWFsRXZlbnRUb2tlbnMgPSBldmVudERlc2NyaXB0b3Iuc3BsaXQoJy4nKTtcbiAgICBjb25zdCBldmVudFRva2VucyA9IHJlY2VpdmVkRXZlbnRUeXBlLnNwbGl0KCcuJyk7XG4gICAgZm9yIChsZXQgdG9rZW5JbmRleCA9IDA7IHRva2VuSW5kZXggPCBwYXJ0aWFsRXZlbnRUb2tlbnMubGVuZ3RoOyB0b2tlbkluZGV4KyspIHtcbiAgICAgIGNvbnN0IHBhcnRpYWxFdmVudFRva2VuID0gcGFydGlhbEV2ZW50VG9rZW5zW3Rva2VuSW5kZXhdO1xuICAgICAgY29uc3QgZXZlbnRUb2tlbiA9IGV2ZW50VG9rZW5zW3Rva2VuSW5kZXhdO1xuICAgICAgaWYgKHBhcnRpYWxFdmVudFRva2VuID09PSAnKicpIHtcbiAgICAgICAgY29uc3QgaXNMYXN0VG9rZW4gPSB0b2tlbkluZGV4ID09PSBwYXJ0aWFsRXZlbnRUb2tlbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKCFpc0xhc3RUb2tlbikge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgSW5maXggd2lsZGNhcmRzIGluIHRyYW5zaXRpb24gZXZlbnRzIGFyZSBub3QgYWxsb3dlZC4gQ2hlY2sgdGhlIFwiJHtldmVudERlc2NyaXB0b3J9XCIgdHJhbnNpdGlvbi5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNMYXN0VG9rZW47XG4gICAgICB9XG4gICAgICBpZiAocGFydGlhbEV2ZW50VG9rZW4gIT09IGV2ZW50VG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSkuc29ydCgoYSwgYikgPT4gYi5sZW5ndGggLSBhLmxlbmd0aCkuZmxhdE1hcChrZXkgPT4gc3RhdGVOb2RlLnRyYW5zaXRpb25zLmdldChrZXkpKTtcbiAgcmV0dXJuIGNhbmRpZGF0ZXM7XG59XG5cbi8qKiBBbGwgZGVsYXllZCB0cmFuc2l0aW9ucyBmcm9tIHRoZSBjb25maWcuICovXG5mdW5jdGlvbiBnZXREZWxheWVkVHJhbnNpdGlvbnMoc3RhdGVOb2RlKSB7XG4gIGNvbnN0IGFmdGVyQ29uZmlnID0gc3RhdGVOb2RlLmNvbmZpZy5hZnRlcjtcbiAgaWYgKCFhZnRlckNvbmZpZykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb25zdCBtdXRhdGVFbnRyeUV4aXQgPSAoZGVsYXksIGkpID0+IHtcbiAgICBjb25zdCBhZnRlckV2ZW50ID0gY3JlYXRlQWZ0ZXJFdmVudChkZWxheSwgc3RhdGVOb2RlLmlkKTtcbiAgICBjb25zdCBldmVudFR5cGUgPSBhZnRlckV2ZW50LnR5cGU7XG4gICAgc3RhdGVOb2RlLmVudHJ5LnB1c2gocmFpc2UoYWZ0ZXJFdmVudCwge1xuICAgICAgaWQ6IGV2ZW50VHlwZSxcbiAgICAgIGRlbGF5XG4gICAgfSkpO1xuICAgIHN0YXRlTm9kZS5leGl0LnB1c2goY2FuY2VsKGV2ZW50VHlwZSkpO1xuICAgIHJldHVybiBldmVudFR5cGU7XG4gIH07XG4gIGNvbnN0IGRlbGF5ZWRUcmFuc2l0aW9ucyA9IE9iamVjdC5rZXlzKGFmdGVyQ29uZmlnKS5mbGF0TWFwKChkZWxheSwgaSkgPT4ge1xuICAgIGNvbnN0IGNvbmZpZ1RyYW5zaXRpb24gPSBhZnRlckNvbmZpZ1tkZWxheV07XG4gICAgY29uc3QgcmVzb2x2ZWRUcmFuc2l0aW9uID0gdHlwZW9mIGNvbmZpZ1RyYW5zaXRpb24gPT09ICdzdHJpbmcnID8ge1xuICAgICAgdGFyZ2V0OiBjb25maWdUcmFuc2l0aW9uXG4gICAgfSA6IGNvbmZpZ1RyYW5zaXRpb247XG4gICAgY29uc3QgcmVzb2x2ZWREZWxheSA9IE51bWJlci5pc05hTigrZGVsYXkpID8gZGVsYXkgOiArZGVsYXk7XG4gICAgY29uc3QgZXZlbnRUeXBlID0gbXV0YXRlRW50cnlFeGl0KHJlc29sdmVkRGVsYXkpO1xuICAgIHJldHVybiB0b0FycmF5KHJlc29sdmVkVHJhbnNpdGlvbikubWFwKHRyYW5zaXRpb24gPT4gKHtcbiAgICAgIC4uLnRyYW5zaXRpb24sXG4gICAgICBldmVudDogZXZlbnRUeXBlLFxuICAgICAgZGVsYXk6IHJlc29sdmVkRGVsYXlcbiAgICB9KSk7XG4gIH0pO1xuICByZXR1cm4gZGVsYXllZFRyYW5zaXRpb25zLm1hcChkZWxheWVkVHJhbnNpdGlvbiA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgZGVsYXlcbiAgICB9ID0gZGVsYXllZFRyYW5zaXRpb247XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmZvcm1hdFRyYW5zaXRpb24oc3RhdGVOb2RlLCBkZWxheWVkVHJhbnNpdGlvbi5ldmVudCwgZGVsYXllZFRyYW5zaXRpb24pLFxuICAgICAgZGVsYXlcbiAgICB9O1xuICB9KTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFRyYW5zaXRpb24oc3RhdGVOb2RlLCBkZXNjcmlwdG9yLCB0cmFuc2l0aW9uQ29uZmlnKSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWRUYXJnZXQgPSBub3JtYWxpemVUYXJnZXQodHJhbnNpdGlvbkNvbmZpZy50YXJnZXQpO1xuICBjb25zdCByZWVudGVyID0gdHJhbnNpdGlvbkNvbmZpZy5yZWVudGVyID8/IGZhbHNlO1xuICBjb25zdCB0YXJnZXQgPSByZXNvbHZlVGFyZ2V0KHN0YXRlTm9kZSwgbm9ybWFsaXplZFRhcmdldCk7XG5cbiAgLy8gVE9ETzogc2hvdWxkIHRoaXMgYmUgcGFydCBvZiBhIGxpbnQgcnVsZSBpbnN0ZWFkP1xuICBpZiAodHJhbnNpdGlvbkNvbmZpZy5jb25kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBTdGF0ZSBcIiR7c3RhdGVOb2RlLmlkfVwiIGhhcyBkZWNsYXJlZCBcXGBjb25kXFxgIGZvciBvbmUgb2YgaXRzIHRyYW5zaXRpb25zLiBUaGlzIHByb3BlcnR5IGhhcyBiZWVuIHJlbmFtZWQgdG8gXFxgZ3VhcmRcXGAuIFBsZWFzZSB1cGRhdGUgeW91ciBjb2RlLmApO1xuICB9XG4gIGNvbnN0IHRyYW5zaXRpb24gPSB7XG4gICAgLi4udHJhbnNpdGlvbkNvbmZpZyxcbiAgICBhY3Rpb25zOiB0b0FycmF5KHRyYW5zaXRpb25Db25maWcuYWN0aW9ucyksXG4gICAgZ3VhcmQ6IHRyYW5zaXRpb25Db25maWcuZ3VhcmQsXG4gICAgdGFyZ2V0LFxuICAgIHNvdXJjZTogc3RhdGVOb2RlLFxuICAgIHJlZW50ZXIsXG4gICAgZXZlbnRUeXBlOiBkZXNjcmlwdG9yLFxuICAgIHRvSlNPTjogKCkgPT4gKHtcbiAgICAgIC4uLnRyYW5zaXRpb24sXG4gICAgICBzb3VyY2U6IGAjJHtzdGF0ZU5vZGUuaWR9YCxcbiAgICAgIHRhcmdldDogdGFyZ2V0ID8gdGFyZ2V0Lm1hcCh0ID0+IGAjJHt0LmlkfWApIDogdW5kZWZpbmVkXG4gICAgfSlcbiAgfTtcbiAgcmV0dXJuIHRyYW5zaXRpb247XG59XG5mdW5jdGlvbiBmb3JtYXRUcmFuc2l0aW9ucyhzdGF0ZU5vZGUpIHtcbiAgY29uc3QgdHJhbnNpdGlvbnMgPSBuZXcgTWFwKCk7XG4gIGlmIChzdGF0ZU5vZGUuY29uZmlnLm9uKSB7XG4gICAgZm9yIChjb25zdCBkZXNjcmlwdG9yIG9mIE9iamVjdC5rZXlzKHN0YXRlTm9kZS5jb25maWcub24pKSB7XG4gICAgICBpZiAoZGVzY3JpcHRvciA9PT0gTlVMTF9FVkVOVCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ051bGwgZXZlbnRzIChcIlwiKSBjYW5ub3QgYmUgc3BlY2lmaWVkIGFzIGEgdHJhbnNpdGlvbiBrZXkuIFVzZSBgYWx3YXlzOiB7IC4uLiB9YCBpbnN0ZWFkLicpO1xuICAgICAgfVxuICAgICAgY29uc3QgdHJhbnNpdGlvbnNDb25maWcgPSBzdGF0ZU5vZGUuY29uZmlnLm9uW2Rlc2NyaXB0b3JdO1xuICAgICAgdHJhbnNpdGlvbnMuc2V0KGRlc2NyaXB0b3IsIHRvVHJhbnNpdGlvbkNvbmZpZ0FycmF5KHRyYW5zaXRpb25zQ29uZmlnKS5tYXAodCA9PiBmb3JtYXRUcmFuc2l0aW9uKHN0YXRlTm9kZSwgZGVzY3JpcHRvciwgdCkpKTtcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXRlTm9kZS5jb25maWcub25Eb25lKSB7XG4gICAgY29uc3QgZGVzY3JpcHRvciA9IGB4c3RhdGUuZG9uZS5zdGF0ZS4ke3N0YXRlTm9kZS5pZH1gO1xuICAgIHRyYW5zaXRpb25zLnNldChkZXNjcmlwdG9yLCB0b1RyYW5zaXRpb25Db25maWdBcnJheShzdGF0ZU5vZGUuY29uZmlnLm9uRG9uZSkubWFwKHQgPT4gZm9ybWF0VHJhbnNpdGlvbihzdGF0ZU5vZGUsIGRlc2NyaXB0b3IsIHQpKSk7XG4gIH1cbiAgZm9yIChjb25zdCBpbnZva2VEZWYgb2Ygc3RhdGVOb2RlLmludm9rZSkge1xuICAgIGlmIChpbnZva2VEZWYub25Eb25lKSB7XG4gICAgICBjb25zdCBkZXNjcmlwdG9yID0gYHhzdGF0ZS5kb25lLmFjdG9yLiR7aW52b2tlRGVmLmlkfWA7XG4gICAgICB0cmFuc2l0aW9ucy5zZXQoZGVzY3JpcHRvciwgdG9UcmFuc2l0aW9uQ29uZmlnQXJyYXkoaW52b2tlRGVmLm9uRG9uZSkubWFwKHQgPT4gZm9ybWF0VHJhbnNpdGlvbihzdGF0ZU5vZGUsIGRlc2NyaXB0b3IsIHQpKSk7XG4gICAgfVxuICAgIGlmIChpbnZva2VEZWYub25FcnJvcikge1xuICAgICAgY29uc3QgZGVzY3JpcHRvciA9IGB4c3RhdGUuZXJyb3IuYWN0b3IuJHtpbnZva2VEZWYuaWR9YDtcbiAgICAgIHRyYW5zaXRpb25zLnNldChkZXNjcmlwdG9yLCB0b1RyYW5zaXRpb25Db25maWdBcnJheShpbnZva2VEZWYub25FcnJvcikubWFwKHQgPT4gZm9ybWF0VHJhbnNpdGlvbihzdGF0ZU5vZGUsIGRlc2NyaXB0b3IsIHQpKSk7XG4gICAgfVxuICAgIGlmIChpbnZva2VEZWYub25TbmFwc2hvdCkge1xuICAgICAgY29uc3QgZGVzY3JpcHRvciA9IGB4c3RhdGUuc25hcHNob3QuJHtpbnZva2VEZWYuaWR9YDtcbiAgICAgIHRyYW5zaXRpb25zLnNldChkZXNjcmlwdG9yLCB0b1RyYW5zaXRpb25Db25maWdBcnJheShpbnZva2VEZWYub25TbmFwc2hvdCkubWFwKHQgPT4gZm9ybWF0VHJhbnNpdGlvbihzdGF0ZU5vZGUsIGRlc2NyaXB0b3IsIHQpKSk7XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgZGVsYXllZFRyYW5zaXRpb24gb2Ygc3RhdGVOb2RlLmFmdGVyKSB7XG4gICAgbGV0IGV4aXN0aW5nID0gdHJhbnNpdGlvbnMuZ2V0KGRlbGF5ZWRUcmFuc2l0aW9uLmV2ZW50VHlwZSk7XG4gICAgaWYgKCFleGlzdGluZykge1xuICAgICAgZXhpc3RpbmcgPSBbXTtcbiAgICAgIHRyYW5zaXRpb25zLnNldChkZWxheWVkVHJhbnNpdGlvbi5ldmVudFR5cGUsIGV4aXN0aW5nKTtcbiAgICB9XG4gICAgZXhpc3RpbmcucHVzaChkZWxheWVkVHJhbnNpdGlvbik7XG4gIH1cbiAgcmV0dXJuIHRyYW5zaXRpb25zO1xufVxuZnVuY3Rpb24gZm9ybWF0SW5pdGlhbFRyYW5zaXRpb24oc3RhdGVOb2RlLCBfdGFyZ2V0KSB7XG4gIGNvbnN0IHJlc29sdmVkVGFyZ2V0ID0gdHlwZW9mIF90YXJnZXQgPT09ICdzdHJpbmcnID8gc3RhdGVOb2RlLnN0YXRlc1tfdGFyZ2V0XSA6IF90YXJnZXQgPyBzdGF0ZU5vZGUuc3RhdGVzW190YXJnZXQudGFyZ2V0XSA6IHVuZGVmaW5lZDtcbiAgaWYgKCFyZXNvbHZlZFRhcmdldCAmJiBfdGFyZ2V0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbml0aWFsIHN0YXRlIG5vZGUgXCIke190YXJnZXR9XCIgbm90IGZvdW5kIG9uIHBhcmVudCBzdGF0ZSBub2RlICMke3N0YXRlTm9kZS5pZH1gKTtcbiAgfVxuICBjb25zdCB0cmFuc2l0aW9uID0ge1xuICAgIHNvdXJjZTogc3RhdGVOb2RlLFxuICAgIGFjdGlvbnM6ICFfdGFyZ2V0IHx8IHR5cGVvZiBfdGFyZ2V0ID09PSAnc3RyaW5nJyA/IFtdIDogdG9BcnJheShfdGFyZ2V0LmFjdGlvbnMpLFxuICAgIGV2ZW50VHlwZTogbnVsbCxcbiAgICByZWVudGVyOiBmYWxzZSxcbiAgICB0YXJnZXQ6IHJlc29sdmVkVGFyZ2V0ID8gW3Jlc29sdmVkVGFyZ2V0XSA6IFtdLFxuICAgIHRvSlNPTjogKCkgPT4gKHtcbiAgICAgIC4uLnRyYW5zaXRpb24sXG4gICAgICBzb3VyY2U6IGAjJHtzdGF0ZU5vZGUuaWR9YCxcbiAgICAgIHRhcmdldDogcmVzb2x2ZWRUYXJnZXQgPyBbYCMke3Jlc29sdmVkVGFyZ2V0LmlkfWBdIDogW11cbiAgICB9KVxuICB9O1xuICByZXR1cm4gdHJhbnNpdGlvbjtcbn1cbmZ1bmN0aW9uIHJlc29sdmVUYXJnZXQoc3RhdGVOb2RlLCB0YXJnZXRzKSB7XG4gIGlmICh0YXJnZXRzID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBhbiB1bmRlZmluZWQgdGFyZ2V0IHNpZ25hbHMgdGhhdCB0aGUgc3RhdGUgbm9kZSBzaG91bGQgbm90IHRyYW5zaXRpb24gZnJvbSB0aGF0IHN0YXRlIHdoZW4gcmVjZWl2aW5nIHRoYXQgZXZlbnRcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiB0YXJnZXRzLm1hcCh0YXJnZXQgPT4ge1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgaWYgKGlzU3RhdGVJZCh0YXJnZXQpKSB7XG4gICAgICByZXR1cm4gc3RhdGVOb2RlLm1hY2hpbmUuZ2V0U3RhdGVOb2RlQnlJZCh0YXJnZXQpO1xuICAgIH1cbiAgICBjb25zdCBpc0ludGVybmFsVGFyZ2V0ID0gdGFyZ2V0WzBdID09PSBTVEFURV9ERUxJTUlURVI7XG4gICAgLy8gSWYgaW50ZXJuYWwgdGFyZ2V0IGlzIGRlZmluZWQgb24gbWFjaGluZSxcbiAgICAvLyBkbyBub3QgaW5jbHVkZSBtYWNoaW5lIGtleSBvbiB0YXJnZXRcbiAgICBpZiAoaXNJbnRlcm5hbFRhcmdldCAmJiAhc3RhdGVOb2RlLnBhcmVudCkge1xuICAgICAgcmV0dXJuIGdldFN0YXRlTm9kZUJ5UGF0aChzdGF0ZU5vZGUsIHRhcmdldC5zbGljZSgxKSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc29sdmVkVGFyZ2V0ID0gaXNJbnRlcm5hbFRhcmdldCA/IHN0YXRlTm9kZS5rZXkgKyB0YXJnZXQgOiB0YXJnZXQ7XG4gICAgaWYgKHN0YXRlTm9kZS5wYXJlbnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHRhcmdldFN0YXRlTm9kZSA9IGdldFN0YXRlTm9kZUJ5UGF0aChzdGF0ZU5vZGUucGFyZW50LCByZXNvbHZlZFRhcmdldCk7XG4gICAgICAgIHJldHVybiB0YXJnZXRTdGF0ZU5vZGU7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRyYW5zaXRpb24gZGVmaW5pdGlvbiBmb3Igc3RhdGUgbm9kZSAnJHtzdGF0ZU5vZGUuaWR9JzpcXG4ke2Vyci5tZXNzYWdlfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdGFyZ2V0OiBcIiR7dGFyZ2V0fVwiIGlzIG5vdCBhIHZhbGlkIHRhcmdldCBmcm9tIHRoZSByb290IG5vZGUuIERpZCB5b3UgbWVhbiBcIi4ke3RhcmdldH1cIj9gKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUhpc3RvcnlEZWZhdWx0VHJhbnNpdGlvbihzdGF0ZU5vZGUpIHtcbiAgY29uc3Qgbm9ybWFsaXplZFRhcmdldCA9IG5vcm1hbGl6ZVRhcmdldChzdGF0ZU5vZGUuY29uZmlnLnRhcmdldCk7XG4gIGlmICghbm9ybWFsaXplZFRhcmdldCkge1xuICAgIHJldHVybiBzdGF0ZU5vZGUucGFyZW50LmluaXRpYWw7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0YXJnZXQ6IG5vcm1hbGl6ZWRUYXJnZXQubWFwKHQgPT4gdHlwZW9mIHQgPT09ICdzdHJpbmcnID8gZ2V0U3RhdGVOb2RlQnlQYXRoKHN0YXRlTm9kZS5wYXJlbnQsIHQpIDogdClcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzSGlzdG9yeU5vZGUoc3RhdGVOb2RlKSB7XG4gIHJldHVybiBzdGF0ZU5vZGUudHlwZSA9PT0gJ2hpc3RvcnknO1xufVxuZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlTm9kZXNXaXRoVGhlaXJBbmNlc3RvcnMoc3RhdGVOb2RlKSB7XG4gIGNvbnN0IHN0YXRlcyA9IGdldEluaXRpYWxTdGF0ZU5vZGVzKHN0YXRlTm9kZSk7XG4gIGZvciAoY29uc3QgaW5pdGlhbFN0YXRlIG9mIHN0YXRlcykge1xuICAgIGZvciAoY29uc3QgYW5jZXN0b3Igb2YgZ2V0UHJvcGVyQW5jZXN0b3JzKGluaXRpYWxTdGF0ZSwgc3RhdGVOb2RlKSkge1xuICAgICAgc3RhdGVzLmFkZChhbmNlc3Rvcik7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdGF0ZXM7XG59XG5mdW5jdGlvbiBnZXRJbml0aWFsU3RhdGVOb2RlcyhzdGF0ZU5vZGUpIHtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldCgpO1xuICBmdW5jdGlvbiBpdGVyKGRlc2NTdGF0ZU5vZGUpIHtcbiAgICBpZiAoc2V0LmhhcyhkZXNjU3RhdGVOb2RlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZXQuYWRkKGRlc2NTdGF0ZU5vZGUpO1xuICAgIGlmIChkZXNjU3RhdGVOb2RlLnR5cGUgPT09ICdjb21wb3VuZCcpIHtcbiAgICAgIGl0ZXIoZGVzY1N0YXRlTm9kZS5pbml0aWFsLnRhcmdldFswXSk7XG4gICAgfSBlbHNlIGlmIChkZXNjU3RhdGVOb2RlLnR5cGUgPT09ICdwYXJhbGxlbCcpIHtcbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgZ2V0Q2hpbGRyZW4oZGVzY1N0YXRlTm9kZSkpIHtcbiAgICAgICAgaXRlcihjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGl0ZXIoc3RhdGVOb2RlKTtcbiAgcmV0dXJuIHNldDtcbn1cbi8qKiBSZXR1cm5zIHRoZSBjaGlsZCBzdGF0ZSBub2RlIGZyb20gaXRzIHJlbGF0aXZlIGBzdGF0ZUtleWAsIG9yIHRocm93cy4gKi9cbmZ1bmN0aW9uIGdldFN0YXRlTm9kZShzdGF0ZU5vZGUsIHN0YXRlS2V5KSB7XG4gIGlmIChpc1N0YXRlSWQoc3RhdGVLZXkpKSB7XG4gICAgcmV0dXJuIHN0YXRlTm9kZS5tYWNoaW5lLmdldFN0YXRlTm9kZUJ5SWQoc3RhdGVLZXkpO1xuICB9XG4gIGlmICghc3RhdGVOb2RlLnN0YXRlcykge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHJldHJpZXZlIGNoaWxkIHN0YXRlICcke3N0YXRlS2V5fScgZnJvbSAnJHtzdGF0ZU5vZGUuaWR9Jzsgbm8gY2hpbGQgc3RhdGVzIGV4aXN0LmApO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IHN0YXRlTm9kZS5zdGF0ZXNbc3RhdGVLZXldO1xuICBpZiAoIXJlc3VsdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2hpbGQgc3RhdGUgJyR7c3RhdGVLZXl9JyBkb2VzIG5vdCBleGlzdCBvbiAnJHtzdGF0ZU5vZGUuaWR9J2ApO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcmVsYXRpdmUgc3RhdGUgbm9kZSBmcm9tIHRoZSBnaXZlbiBgc3RhdGVQYXRoYCwgb3IgdGhyb3dzLlxuICpcbiAqIEBwYXJhbSBzdGF0ZVBhdGggVGhlIHN0cmluZyBvciBzdHJpbmcgYXJyYXkgcmVsYXRpdmUgcGF0aCB0byB0aGUgc3RhdGUgbm9kZS5cbiAqL1xuZnVuY3Rpb24gZ2V0U3RhdGVOb2RlQnlQYXRoKHN0YXRlTm9kZSwgc3RhdGVQYXRoKSB7XG4gIGlmICh0eXBlb2Ygc3RhdGVQYXRoID09PSAnc3RyaW5nJyAmJiBpc1N0YXRlSWQoc3RhdGVQYXRoKSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gc3RhdGVOb2RlLm1hY2hpbmUuZ2V0U3RhdGVOb2RlQnlJZChzdGF0ZVBhdGgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIHRyeSBpbmRpdmlkdWFsIHBhdGhzXG4gICAgICAvLyB0aHJvdyBlO1xuICAgIH1cbiAgfVxuICBjb25zdCBhcnJheVN0YXRlUGF0aCA9IHRvU3RhdGVQYXRoKHN0YXRlUGF0aCkuc2xpY2UoKTtcbiAgbGV0IGN1cnJlbnRTdGF0ZU5vZGUgPSBzdGF0ZU5vZGU7XG4gIHdoaWxlIChhcnJheVN0YXRlUGF0aC5sZW5ndGgpIHtcbiAgICBjb25zdCBrZXkgPSBhcnJheVN0YXRlUGF0aC5zaGlmdCgpO1xuICAgIGlmICgha2V5Lmxlbmd0aCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGN1cnJlbnRTdGF0ZU5vZGUgPSBnZXRTdGF0ZU5vZGUoY3VycmVudFN0YXRlTm9kZSwga2V5KTtcbiAgfVxuICByZXR1cm4gY3VycmVudFN0YXRlTm9kZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzdGF0ZSBub2RlcyByZXByZXNlbnRlZCBieSB0aGUgY3VycmVudCBzdGF0ZSB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gc3RhdGVWYWx1ZSBUaGUgc3RhdGUgdmFsdWUgb3IgU3RhdGUgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gZ2V0U3RhdGVOb2RlcyhzdGF0ZU5vZGUsIHN0YXRlVmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBzdGF0ZVZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IGNoaWxkU3RhdGVOb2RlID0gc3RhdGVOb2RlLnN0YXRlc1tzdGF0ZVZhbHVlXTtcbiAgICBpZiAoIWNoaWxkU3RhdGVOb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0YXRlICcke3N0YXRlVmFsdWV9JyBkb2VzIG5vdCBleGlzdCBvbiAnJHtzdGF0ZU5vZGUuaWR9J2ApO1xuICAgIH1cbiAgICByZXR1cm4gW3N0YXRlTm9kZSwgY2hpbGRTdGF0ZU5vZGVdO1xuICB9XG4gIGNvbnN0IGNoaWxkU3RhdGVLZXlzID0gT2JqZWN0LmtleXMoc3RhdGVWYWx1ZSk7XG4gIGNvbnN0IGNoaWxkU3RhdGVOb2RlcyA9IGNoaWxkU3RhdGVLZXlzLm1hcChzdWJTdGF0ZUtleSA9PiBnZXRTdGF0ZU5vZGUoc3RhdGVOb2RlLCBzdWJTdGF0ZUtleSkpLmZpbHRlcihCb29sZWFuKTtcbiAgcmV0dXJuIFtzdGF0ZU5vZGUubWFjaGluZS5yb290LCBzdGF0ZU5vZGVdLmNvbmNhdChjaGlsZFN0YXRlTm9kZXMsIGNoaWxkU3RhdGVLZXlzLnJlZHVjZSgoYWxsU3ViU3RhdGVOb2Rlcywgc3ViU3RhdGVLZXkpID0+IHtcbiAgICBjb25zdCBzdWJTdGF0ZU5vZGUgPSBnZXRTdGF0ZU5vZGUoc3RhdGVOb2RlLCBzdWJTdGF0ZUtleSk7XG4gICAgaWYgKCFzdWJTdGF0ZU5vZGUpIHtcbiAgICAgIHJldHVybiBhbGxTdWJTdGF0ZU5vZGVzO1xuICAgIH1cbiAgICBjb25zdCBzdWJTdGF0ZU5vZGVzID0gZ2V0U3RhdGVOb2RlcyhzdWJTdGF0ZU5vZGUsIHN0YXRlVmFsdWVbc3ViU3RhdGVLZXldKTtcbiAgICByZXR1cm4gYWxsU3ViU3RhdGVOb2Rlcy5jb25jYXQoc3ViU3RhdGVOb2Rlcyk7XG4gIH0sIFtdKSk7XG59XG5mdW5jdGlvbiB0cmFuc2l0aW9uQXRvbWljTm9kZShzdGF0ZU5vZGUsIHN0YXRlVmFsdWUsIHNuYXBzaG90LCBldmVudCkge1xuICBjb25zdCBjaGlsZFN0YXRlTm9kZSA9IGdldFN0YXRlTm9kZShzdGF0ZU5vZGUsIHN0YXRlVmFsdWUpO1xuICBjb25zdCBuZXh0ID0gY2hpbGRTdGF0ZU5vZGUubmV4dChzbmFwc2hvdCwgZXZlbnQpO1xuICBpZiAoIW5leHQgfHwgIW5leHQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHN0YXRlTm9kZS5uZXh0KHNuYXBzaG90LCBldmVudCk7XG4gIH1cbiAgcmV0dXJuIG5leHQ7XG59XG5mdW5jdGlvbiB0cmFuc2l0aW9uQ29tcG91bmROb2RlKHN0YXRlTm9kZSwgc3RhdGVWYWx1ZSwgc25hcHNob3QsIGV2ZW50KSB7XG4gIGNvbnN0IHN1YlN0YXRlS2V5cyA9IE9iamVjdC5rZXlzKHN0YXRlVmFsdWUpO1xuICBjb25zdCBjaGlsZFN0YXRlTm9kZSA9IGdldFN0YXRlTm9kZShzdGF0ZU5vZGUsIHN1YlN0YXRlS2V5c1swXSk7XG4gIGNvbnN0IG5leHQgPSB0cmFuc2l0aW9uTm9kZShjaGlsZFN0YXRlTm9kZSwgc3RhdGVWYWx1ZVtzdWJTdGF0ZUtleXNbMF1dLCBzbmFwc2hvdCwgZXZlbnQpO1xuICBpZiAoIW5leHQgfHwgIW5leHQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHN0YXRlTm9kZS5uZXh0KHNuYXBzaG90LCBldmVudCk7XG4gIH1cbiAgcmV0dXJuIG5leHQ7XG59XG5mdW5jdGlvbiB0cmFuc2l0aW9uUGFyYWxsZWxOb2RlKHN0YXRlTm9kZSwgc3RhdGVWYWx1ZSwgc25hcHNob3QsIGV2ZW50KSB7XG4gIGNvbnN0IGFsbElubmVyVHJhbnNpdGlvbnMgPSBbXTtcbiAgZm9yIChjb25zdCBzdWJTdGF0ZUtleSBvZiBPYmplY3Qua2V5cyhzdGF0ZVZhbHVlKSkge1xuICAgIGNvbnN0IHN1YlN0YXRlVmFsdWUgPSBzdGF0ZVZhbHVlW3N1YlN0YXRlS2V5XTtcbiAgICBpZiAoIXN1YlN0YXRlVmFsdWUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBzdWJTdGF0ZU5vZGUgPSBnZXRTdGF0ZU5vZGUoc3RhdGVOb2RlLCBzdWJTdGF0ZUtleSk7XG4gICAgY29uc3QgaW5uZXJUcmFuc2l0aW9ucyA9IHRyYW5zaXRpb25Ob2RlKHN1YlN0YXRlTm9kZSwgc3ViU3RhdGVWYWx1ZSwgc25hcHNob3QsIGV2ZW50KTtcbiAgICBpZiAoaW5uZXJUcmFuc2l0aW9ucykge1xuICAgICAgYWxsSW5uZXJUcmFuc2l0aW9ucy5wdXNoKC4uLmlubmVyVHJhbnNpdGlvbnMpO1xuICAgIH1cbiAgfVxuICBpZiAoIWFsbElubmVyVHJhbnNpdGlvbnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHN0YXRlTm9kZS5uZXh0KHNuYXBzaG90LCBldmVudCk7XG4gIH1cbiAgcmV0dXJuIGFsbElubmVyVHJhbnNpdGlvbnM7XG59XG5mdW5jdGlvbiB0cmFuc2l0aW9uTm9kZShzdGF0ZU5vZGUsIHN0YXRlVmFsdWUsIHNuYXBzaG90LCBldmVudCkge1xuICAvLyBsZWFmIG5vZGVcbiAgaWYgKHR5cGVvZiBzdGF0ZVZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0cmFuc2l0aW9uQXRvbWljTm9kZShzdGF0ZU5vZGUsIHN0YXRlVmFsdWUsIHNuYXBzaG90LCBldmVudCk7XG4gIH1cblxuICAvLyBjb21wb3VuZCBub2RlXG4gIGlmIChPYmplY3Qua2V5cyhzdGF0ZVZhbHVlKS5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvbkNvbXBvdW5kTm9kZShzdGF0ZU5vZGUsIHN0YXRlVmFsdWUsIHNuYXBzaG90LCBldmVudCk7XG4gIH1cblxuICAvLyBwYXJhbGxlbCBub2RlXG4gIHJldHVybiB0cmFuc2l0aW9uUGFyYWxsZWxOb2RlKHN0YXRlTm9kZSwgc3RhdGVWYWx1ZSwgc25hcHNob3QsIGV2ZW50KTtcbn1cbmZ1bmN0aW9uIGdldEhpc3RvcnlOb2RlcyhzdGF0ZU5vZGUpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHN0YXRlTm9kZS5zdGF0ZXMpLm1hcChrZXkgPT4gc3RhdGVOb2RlLnN0YXRlc1trZXldKS5maWx0ZXIoc24gPT4gc24udHlwZSA9PT0gJ2hpc3RvcnknKTtcbn1cbmZ1bmN0aW9uIGlzRGVzY2VuZGFudChjaGlsZFN0YXRlTm9kZSwgcGFyZW50U3RhdGVOb2RlKSB7XG4gIGxldCBtYXJrZXIgPSBjaGlsZFN0YXRlTm9kZTtcbiAgd2hpbGUgKG1hcmtlci5wYXJlbnQgJiYgbWFya2VyLnBhcmVudCAhPT0gcGFyZW50U3RhdGVOb2RlKSB7XG4gICAgbWFya2VyID0gbWFya2VyLnBhcmVudDtcbiAgfVxuICByZXR1cm4gbWFya2VyLnBhcmVudCA9PT0gcGFyZW50U3RhdGVOb2RlO1xufVxuZnVuY3Rpb24gaGFzSW50ZXJzZWN0aW9uKHMxLCBzMikge1xuICBjb25zdCBzZXQxID0gbmV3IFNldChzMSk7XG4gIGNvbnN0IHNldDIgPSBuZXcgU2V0KHMyKTtcbiAgZm9yIChjb25zdCBpdGVtIG9mIHNldDEpIHtcbiAgICBpZiAoc2V0Mi5oYXMoaXRlbSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGl0ZW0gb2Ygc2V0Mikge1xuICAgIGlmIChzZXQxLmhhcyhpdGVtKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUNvbmZsaWN0aW5nVHJhbnNpdGlvbnMoZW5hYmxlZFRyYW5zaXRpb25zLCBzdGF0ZU5vZGVTZXQsIGhpc3RvcnlWYWx1ZSkge1xuICBjb25zdCBmaWx0ZXJlZFRyYW5zaXRpb25zID0gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IHQxIG9mIGVuYWJsZWRUcmFuc2l0aW9ucykge1xuICAgIGxldCB0MVByZWVtcHRlZCA9IGZhbHNlO1xuICAgIGNvbnN0IHRyYW5zaXRpb25zVG9SZW1vdmUgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCB0MiBvZiBmaWx0ZXJlZFRyYW5zaXRpb25zKSB7XG4gICAgICBpZiAoaGFzSW50ZXJzZWN0aW9uKGNvbXB1dGVFeGl0U2V0KFt0MV0sIHN0YXRlTm9kZVNldCwgaGlzdG9yeVZhbHVlKSwgY29tcHV0ZUV4aXRTZXQoW3QyXSwgc3RhdGVOb2RlU2V0LCBoaXN0b3J5VmFsdWUpKSkge1xuICAgICAgICBpZiAoaXNEZXNjZW5kYW50KHQxLnNvdXJjZSwgdDIuc291cmNlKSkge1xuICAgICAgICAgIHRyYW5zaXRpb25zVG9SZW1vdmUuYWRkKHQyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0MVByZWVtcHRlZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0MVByZWVtcHRlZCkge1xuICAgICAgZm9yIChjb25zdCB0MyBvZiB0cmFuc2l0aW9uc1RvUmVtb3ZlKSB7XG4gICAgICAgIGZpbHRlcmVkVHJhbnNpdGlvbnMuZGVsZXRlKHQzKTtcbiAgICAgIH1cbiAgICAgIGZpbHRlcmVkVHJhbnNpdGlvbnMuYWRkKHQxKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20oZmlsdGVyZWRUcmFuc2l0aW9ucyk7XG59XG5mdW5jdGlvbiBmaW5kTGVhc3RDb21tb25BbmNlc3RvcihzdGF0ZU5vZGVzKSB7XG4gIGNvbnN0IFtoZWFkLCAuLi50YWlsXSA9IHN0YXRlTm9kZXM7XG4gIGZvciAoY29uc3QgYW5jZXN0b3Igb2YgZ2V0UHJvcGVyQW5jZXN0b3JzKGhlYWQsIHVuZGVmaW5lZCkpIHtcbiAgICBpZiAodGFpbC5ldmVyeShzbiA9PiBpc0Rlc2NlbmRhbnQoc24sIGFuY2VzdG9yKSkpIHtcbiAgICAgIHJldHVybiBhbmNlc3RvcjtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEVmZmVjdGl2ZVRhcmdldFN0YXRlcyh0cmFuc2l0aW9uLCBoaXN0b3J5VmFsdWUpIHtcbiAgaWYgKCF0cmFuc2l0aW9uLnRhcmdldCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb25zdCB0YXJnZXRzID0gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IHRhcmdldE5vZGUgb2YgdHJhbnNpdGlvbi50YXJnZXQpIHtcbiAgICBpZiAoaXNIaXN0b3J5Tm9kZSh0YXJnZXROb2RlKSkge1xuICAgICAgaWYgKGhpc3RvcnlWYWx1ZVt0YXJnZXROb2RlLmlkXSkge1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgaGlzdG9yeVZhbHVlW3RhcmdldE5vZGUuaWRdKSB7XG4gICAgICAgICAgdGFyZ2V0cy5hZGQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBnZXRFZmZlY3RpdmVUYXJnZXRTdGF0ZXMocmVzb2x2ZUhpc3RvcnlEZWZhdWx0VHJhbnNpdGlvbih0YXJnZXROb2RlKSwgaGlzdG9yeVZhbHVlKSkge1xuICAgICAgICAgIHRhcmdldHMuYWRkKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldHMuYWRkKHRhcmdldE5vZGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gWy4uLnRhcmdldHNdO1xufVxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkRvbWFpbih0cmFuc2l0aW9uLCBoaXN0b3J5VmFsdWUpIHtcbiAgY29uc3QgdGFyZ2V0U3RhdGVzID0gZ2V0RWZmZWN0aXZlVGFyZ2V0U3RhdGVzKHRyYW5zaXRpb24sIGhpc3RvcnlWYWx1ZSk7XG4gIGlmICghdGFyZ2V0U3RhdGVzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghdHJhbnNpdGlvbi5yZWVudGVyICYmIHRhcmdldFN0YXRlcy5ldmVyeSh0YXJnZXQgPT4gdGFyZ2V0ID09PSB0cmFuc2l0aW9uLnNvdXJjZSB8fCBpc0Rlc2NlbmRhbnQodGFyZ2V0LCB0cmFuc2l0aW9uLnNvdXJjZSkpKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb24uc291cmNlO1xuICB9XG4gIGNvbnN0IGxjYSA9IGZpbmRMZWFzdENvbW1vbkFuY2VzdG9yKHRhcmdldFN0YXRlcy5jb25jYXQodHJhbnNpdGlvbi5zb3VyY2UpKTtcbiAgaWYgKGxjYSkge1xuICAgIHJldHVybiBsY2E7XG4gIH1cblxuICAvLyBhdCB0aGlzIHBvaW50IHdlIGtub3cgdGhhdCBpdCdzIGEgcm9vdCB0cmFuc2l0aW9uIHNpbmNlIExDQSBjb3VsZG4ndCBiZSBmb3VuZFxuICBpZiAodHJhbnNpdGlvbi5yZWVudGVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiB0cmFuc2l0aW9uLnNvdXJjZS5tYWNoaW5lLnJvb3Q7XG59XG5mdW5jdGlvbiBjb21wdXRlRXhpdFNldCh0cmFuc2l0aW9ucywgc3RhdGVOb2RlU2V0LCBoaXN0b3J5VmFsdWUpIHtcbiAgY29uc3Qgc3RhdGVzVG9FeGl0ID0gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IHQgb2YgdHJhbnNpdGlvbnMpIHtcbiAgICBpZiAodC50YXJnZXQ/Lmxlbmd0aCkge1xuICAgICAgY29uc3QgZG9tYWluID0gZ2V0VHJhbnNpdGlvbkRvbWFpbih0LCBoaXN0b3J5VmFsdWUpO1xuICAgICAgaWYgKHQucmVlbnRlciAmJiB0LnNvdXJjZSA9PT0gZG9tYWluKSB7XG4gICAgICAgIHN0YXRlc1RvRXhpdC5hZGQoZG9tYWluKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qgc3RhdGVOb2RlIG9mIHN0YXRlTm9kZVNldCkge1xuICAgICAgICBpZiAoaXNEZXNjZW5kYW50KHN0YXRlTm9kZSwgZG9tYWluKSkge1xuICAgICAgICAgIHN0YXRlc1RvRXhpdC5hZGQoc3RhdGVOb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gWy4uLnN0YXRlc1RvRXhpdF07XG59XG5mdW5jdGlvbiBhcmVTdGF0ZU5vZGVDb2xsZWN0aW9uc0VxdWFsKHByZXZTdGF0ZU5vZGVzLCBuZXh0U3RhdGVOb2RlU2V0KSB7XG4gIGlmIChwcmV2U3RhdGVOb2Rlcy5sZW5ndGggIT09IG5leHRTdGF0ZU5vZGVTZXQuc2l6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGNvbnN0IG5vZGUgb2YgcHJldlN0YXRlTm9kZXMpIHtcbiAgICBpZiAoIW5leHRTdGF0ZU5vZGVTZXQuaGFzKG5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKiogaHR0cHM6Ly93d3cudzMub3JnL1RSL3NjeG1sLyNtaWNyb3N0ZXBQcm9jZWR1cmUgKi9cbmZ1bmN0aW9uIG1pY3Jvc3RlcCh0cmFuc2l0aW9ucywgY3VycmVudFNuYXBzaG90LCBhY3RvclNjb3BlLCBldmVudCwgaXNJbml0aWFsLCBpbnRlcm5hbFF1ZXVlKSB7XG4gIGlmICghdHJhbnNpdGlvbnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRTbmFwc2hvdDtcbiAgfVxuICBjb25zdCBtdXRTdGF0ZU5vZGVTZXQgPSBuZXcgU2V0KGN1cnJlbnRTbmFwc2hvdC5fbm9kZXMpO1xuICBsZXQgaGlzdG9yeVZhbHVlID0gY3VycmVudFNuYXBzaG90Lmhpc3RvcnlWYWx1ZTtcbiAgY29uc3QgZmlsdGVyZWRUcmFuc2l0aW9ucyA9IHJlbW92ZUNvbmZsaWN0aW5nVHJhbnNpdGlvbnModHJhbnNpdGlvbnMsIG11dFN0YXRlTm9kZVNldCwgaGlzdG9yeVZhbHVlKTtcbiAgbGV0IG5leHRTdGF0ZSA9IGN1cnJlbnRTbmFwc2hvdDtcblxuICAvLyBFeGl0IHN0YXRlc1xuICBpZiAoIWlzSW5pdGlhbCkge1xuICAgIFtuZXh0U3RhdGUsIGhpc3RvcnlWYWx1ZV0gPSBleGl0U3RhdGVzKG5leHRTdGF0ZSwgZXZlbnQsIGFjdG9yU2NvcGUsIGZpbHRlcmVkVHJhbnNpdGlvbnMsIG11dFN0YXRlTm9kZVNldCwgaGlzdG9yeVZhbHVlLCBpbnRlcm5hbFF1ZXVlKTtcbiAgfVxuXG4gIC8vIEV4ZWN1dGUgdHJhbnNpdGlvbiBjb250ZW50XG4gIG5leHRTdGF0ZSA9IHJlc29sdmVBY3Rpb25zQW5kQ29udGV4dChuZXh0U3RhdGUsIGV2ZW50LCBhY3RvclNjb3BlLCBmaWx0ZXJlZFRyYW5zaXRpb25zLmZsYXRNYXAodCA9PiB0LmFjdGlvbnMpLCBpbnRlcm5hbFF1ZXVlKTtcblxuICAvLyBFbnRlciBzdGF0ZXNcbiAgbmV4dFN0YXRlID0gZW50ZXJTdGF0ZXMobmV4dFN0YXRlLCBldmVudCwgYWN0b3JTY29wZSwgZmlsdGVyZWRUcmFuc2l0aW9ucywgbXV0U3RhdGVOb2RlU2V0LCBpbnRlcm5hbFF1ZXVlLCBoaXN0b3J5VmFsdWUsIGlzSW5pdGlhbCk7XG4gIGNvbnN0IG5leHRTdGF0ZU5vZGVzID0gWy4uLm11dFN0YXRlTm9kZVNldF07XG4gIGlmIChuZXh0U3RhdGUuc3RhdHVzID09PSAnZG9uZScpIHtcbiAgICBuZXh0U3RhdGUgPSByZXNvbHZlQWN0aW9uc0FuZENvbnRleHQobmV4dFN0YXRlLCBldmVudCwgYWN0b3JTY29wZSwgbmV4dFN0YXRlTm9kZXMuc29ydCgoYSwgYikgPT4gYi5vcmRlciAtIGEub3JkZXIpLmZsYXRNYXAoc3RhdGUgPT4gc3RhdGUuZXhpdCksIGludGVybmFsUXVldWUpO1xuICB9XG4gIHRyeSB7XG4gICAgaWYgKGhpc3RvcnlWYWx1ZSA9PT0gY3VycmVudFNuYXBzaG90Lmhpc3RvcnlWYWx1ZSAmJiBhcmVTdGF0ZU5vZGVDb2xsZWN0aW9uc0VxdWFsKGN1cnJlbnRTbmFwc2hvdC5fbm9kZXMsIG11dFN0YXRlTm9kZVNldCkpIHtcbiAgICAgIHJldHVybiBuZXh0U3RhdGU7XG4gICAgfVxuICAgIHJldHVybiBjbG9uZU1hY2hpbmVTbmFwc2hvdChuZXh0U3RhdGUsIHtcbiAgICAgIF9ub2RlczogbmV4dFN0YXRlTm9kZXMsXG4gICAgICBoaXN0b3J5VmFsdWVcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRPRE86IFJlZmFjdG9yIHRoaXMgb25jZSBwcm9wZXIgZXJyb3IgaGFuZGxpbmcgaXMgaW1wbGVtZW50ZWQuXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdGF0ZWx5YWkvcmZjcy9wdWxsLzRcbiAgICB0aHJvdyBlO1xuICB9XG59XG5mdW5jdGlvbiBnZXRNYWNoaW5lT3V0cHV0KHNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSwgcm9vdE5vZGUsIHJvb3RDb21wbGV0aW9uTm9kZSkge1xuICBpZiAocm9vdE5vZGUub3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZG9uZVN0YXRlRXZlbnQgPSBjcmVhdGVEb25lU3RhdGVFdmVudChyb290Q29tcGxldGlvbk5vZGUuaWQsIHJvb3RDb21wbGV0aW9uTm9kZS5vdXRwdXQgIT09IHVuZGVmaW5lZCAmJiByb290Q29tcGxldGlvbk5vZGUucGFyZW50ID8gcmVzb2x2ZU91dHB1dChyb290Q29tcGxldGlvbk5vZGUub3V0cHV0LCBzbmFwc2hvdC5jb250ZXh0LCBldmVudCwgYWN0b3JTY29wZS5zZWxmKSA6IHVuZGVmaW5lZCk7XG4gIHJldHVybiByZXNvbHZlT3V0cHV0KHJvb3ROb2RlLm91dHB1dCwgc25hcHNob3QuY29udGV4dCwgZG9uZVN0YXRlRXZlbnQsIGFjdG9yU2NvcGUuc2VsZik7XG59XG5mdW5jdGlvbiBlbnRlclN0YXRlcyhjdXJyZW50U25hcHNob3QsIGV2ZW50LCBhY3RvclNjb3BlLCBmaWx0ZXJlZFRyYW5zaXRpb25zLCBtdXRTdGF0ZU5vZGVTZXQsIGludGVybmFsUXVldWUsIGhpc3RvcnlWYWx1ZSwgaXNJbml0aWFsKSB7XG4gIGxldCBuZXh0U25hcHNob3QgPSBjdXJyZW50U25hcHNob3Q7XG4gIGNvbnN0IHN0YXRlc1RvRW50ZXIgPSBuZXcgU2V0KCk7XG4gIC8vIHRob3NlIGFyZSBzdGF0ZXMgdGhhdCB3ZXJlIGRpcmVjdGx5IHRhcmdldGVkIG9yIGluZGlyZWN0bHkgdGFyZ2V0ZWQgYnkgdGhlIGV4cGxpY2l0IHRhcmdldFxuICAvLyBpbiBvdGhlciB3b3JkcywgdGhvc2UgYXJlIHN0YXRlcyBmb3Igd2hpY2ggaW5pdGlhbCBhY3Rpb25zIHNob3VsZCBiZSBleGVjdXRlZFxuICAvLyB3aGVuIHdlIHRhcmdldCBgI2RlZXBfY2hpbGRgIGluaXRpYWwgYWN0aW9ucyBvZiBpdHMgYW5jZXN0b3JzIHNob3VsZG4ndCBiZSBleGVjdXRlZFxuICBjb25zdCBzdGF0ZXNGb3JEZWZhdWx0RW50cnkgPSBuZXcgU2V0KCk7XG4gIGNvbXB1dGVFbnRyeVNldChmaWx0ZXJlZFRyYW5zaXRpb25zLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSwgc3RhdGVzVG9FbnRlcik7XG5cbiAgLy8gSW4gdGhlIGluaXRpYWwgc3RhdGUsIHRoZSByb290IHN0YXRlIG5vZGUgaXMgXCJlbnRlcmVkXCIuXG4gIGlmIChpc0luaXRpYWwpIHtcbiAgICBzdGF0ZXNGb3JEZWZhdWx0RW50cnkuYWRkKGN1cnJlbnRTbmFwc2hvdC5tYWNoaW5lLnJvb3QpO1xuICB9XG4gIGNvbnN0IGNvbXBsZXRlZE5vZGVzID0gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IHN0YXRlTm9kZVRvRW50ZXIgb2YgWy4uLnN0YXRlc1RvRW50ZXJdLnNvcnQoKGEsIGIpID0+IGEub3JkZXIgLSBiLm9yZGVyKSkge1xuICAgIG11dFN0YXRlTm9kZVNldC5hZGQoc3RhdGVOb2RlVG9FbnRlcik7XG4gICAgY29uc3QgYWN0aW9ucyA9IFtdO1xuXG4gICAgLy8gQWRkIGVudHJ5IGFjdGlvbnNcbiAgICBhY3Rpb25zLnB1c2goLi4uc3RhdGVOb2RlVG9FbnRlci5lbnRyeSk7XG4gICAgZm9yIChjb25zdCBpbnZva2VEZWYgb2Ygc3RhdGVOb2RlVG9FbnRlci5pbnZva2UpIHtcbiAgICAgIGFjdGlvbnMucHVzaChzcGF3bkNoaWxkKGludm9rZURlZi5zcmMsIHtcbiAgICAgICAgLi4uaW52b2tlRGVmLFxuICAgICAgICBzeW5jU25hcHNob3Q6ICEhaW52b2tlRGVmLm9uU25hcHNob3RcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlc0ZvckRlZmF1bHRFbnRyeS5oYXMoc3RhdGVOb2RlVG9FbnRlcikpIHtcbiAgICAgIGNvbnN0IGluaXRpYWxBY3Rpb25zID0gc3RhdGVOb2RlVG9FbnRlci5pbml0aWFsLmFjdGlvbnM7XG4gICAgICBhY3Rpb25zLnB1c2goLi4uaW5pdGlhbEFjdGlvbnMpO1xuICAgIH1cbiAgICBuZXh0U25hcHNob3QgPSByZXNvbHZlQWN0aW9uc0FuZENvbnRleHQobmV4dFNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSwgYWN0aW9ucywgaW50ZXJuYWxRdWV1ZSwgc3RhdGVOb2RlVG9FbnRlci5pbnZva2UubWFwKGludm9rZURlZiA9PiBpbnZva2VEZWYuaWQpKTtcbiAgICBpZiAoc3RhdGVOb2RlVG9FbnRlci50eXBlID09PSAnZmluYWwnKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBzdGF0ZU5vZGVUb0VudGVyLnBhcmVudDtcbiAgICAgIGxldCBhbmNlc3Rvck1hcmtlciA9IHBhcmVudD8udHlwZSA9PT0gJ3BhcmFsbGVsJyA/IHBhcmVudCA6IHBhcmVudD8ucGFyZW50O1xuICAgICAgbGV0IHJvb3RDb21wbGV0aW9uTm9kZSA9IGFuY2VzdG9yTWFya2VyIHx8IHN0YXRlTm9kZVRvRW50ZXI7XG4gICAgICBpZiAocGFyZW50Py50eXBlID09PSAnY29tcG91bmQnKSB7XG4gICAgICAgIGludGVybmFsUXVldWUucHVzaChjcmVhdGVEb25lU3RhdGVFdmVudChwYXJlbnQuaWQsIHN0YXRlTm9kZVRvRW50ZXIub3V0cHV0ICE9PSB1bmRlZmluZWQgPyByZXNvbHZlT3V0cHV0KHN0YXRlTm9kZVRvRW50ZXIub3V0cHV0LCBuZXh0U25hcHNob3QuY29udGV4dCwgZXZlbnQsIGFjdG9yU2NvcGUuc2VsZikgOiB1bmRlZmluZWQpKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChhbmNlc3Rvck1hcmtlcj8udHlwZSA9PT0gJ3BhcmFsbGVsJyAmJiAhY29tcGxldGVkTm9kZXMuaGFzKGFuY2VzdG9yTWFya2VyKSAmJiBpc0luRmluYWxTdGF0ZShtdXRTdGF0ZU5vZGVTZXQsIGFuY2VzdG9yTWFya2VyKSkge1xuICAgICAgICBjb21wbGV0ZWROb2Rlcy5hZGQoYW5jZXN0b3JNYXJrZXIpO1xuICAgICAgICBpbnRlcm5hbFF1ZXVlLnB1c2goY3JlYXRlRG9uZVN0YXRlRXZlbnQoYW5jZXN0b3JNYXJrZXIuaWQpKTtcbiAgICAgICAgcm9vdENvbXBsZXRpb25Ob2RlID0gYW5jZXN0b3JNYXJrZXI7XG4gICAgICAgIGFuY2VzdG9yTWFya2VyID0gYW5jZXN0b3JNYXJrZXIucGFyZW50O1xuICAgICAgfVxuICAgICAgaWYgKGFuY2VzdG9yTWFya2VyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbmV4dFNuYXBzaG90ID0gY2xvbmVNYWNoaW5lU25hcHNob3QobmV4dFNuYXBzaG90LCB7XG4gICAgICAgIHN0YXR1czogJ2RvbmUnLFxuICAgICAgICBvdXRwdXQ6IGdldE1hY2hpbmVPdXRwdXQobmV4dFNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSwgbmV4dFNuYXBzaG90Lm1hY2hpbmUucm9vdCwgcm9vdENvbXBsZXRpb25Ob2RlKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXh0U25hcHNob3Q7XG59XG5mdW5jdGlvbiBjb21wdXRlRW50cnlTZXQodHJhbnNpdGlvbnMsIGhpc3RvcnlWYWx1ZSwgc3RhdGVzRm9yRGVmYXVsdEVudHJ5LCBzdGF0ZXNUb0VudGVyKSB7XG4gIGZvciAoY29uc3QgdCBvZiB0cmFuc2l0aW9ucykge1xuICAgIGNvbnN0IGRvbWFpbiA9IGdldFRyYW5zaXRpb25Eb21haW4odCwgaGlzdG9yeVZhbHVlKTtcbiAgICBmb3IgKGNvbnN0IHMgb2YgdC50YXJnZXQgfHwgW10pIHtcbiAgICAgIGlmICghaXNIaXN0b3J5Tm9kZShzKSAmJiAoXG4gICAgICAvLyBpZiB0aGUgdGFyZ2V0IGlzIGRpZmZlcmVudCB0aGFuIHRoZSBzb3VyY2UgdGhlbiBpdCB3aWxsICpkZWZpbml0ZWx5KiBiZSBlbnRlcmVkXG4gICAgICB0LnNvdXJjZSAhPT0gcyB8fFxuICAgICAgLy8gd2Uga25vdyB0aGF0IHRoZSBkb21haW4gY2FuJ3QgbGllIHdpdGhpbiB0aGUgc291cmNlXG4gICAgICAvLyBpZiBpdCdzIGRpZmZlcmVudCB0aGFuIHRoZSBzb3VyY2UgdGhlbiBpdCdzIG91dHNpZGUgb2YgaXQgYW5kIGl0IG1lYW5zIHRoYXQgdGhlIHRhcmdldCBoYXMgdG8gYmUgZW50ZXJlZCBhcyB3ZWxsXG4gICAgICB0LnNvdXJjZSAhPT0gZG9tYWluIHx8XG4gICAgICAvLyByZWVudGVyaW5nIHRyYW5zaXRpb25zIGFsd2F5cyBlbnRlciB0aGUgdGFyZ2V0LCBldmVuIGlmIGl0J3MgdGhlIHNvdXJjZSBpdHNlbGZcbiAgICAgIHQucmVlbnRlcikpIHtcbiAgICAgICAgc3RhdGVzVG9FbnRlci5hZGQocyk7XG4gICAgICAgIHN0YXRlc0ZvckRlZmF1bHRFbnRyeS5hZGQocyk7XG4gICAgICB9XG4gICAgICBhZGREZXNjZW5kYW50U3RhdGVzVG9FbnRlcihzLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSwgc3RhdGVzVG9FbnRlcik7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldFN0YXRlcyA9IGdldEVmZmVjdGl2ZVRhcmdldFN0YXRlcyh0LCBoaXN0b3J5VmFsdWUpO1xuICAgIGZvciAoY29uc3QgcyBvZiB0YXJnZXRTdGF0ZXMpIHtcbiAgICAgIGNvbnN0IGFuY2VzdG9ycyA9IGdldFByb3BlckFuY2VzdG9ycyhzLCBkb21haW4pO1xuICAgICAgaWYgKGRvbWFpbj8udHlwZSA9PT0gJ3BhcmFsbGVsJykge1xuICAgICAgICBhbmNlc3RvcnMucHVzaChkb21haW4pO1xuICAgICAgfVxuICAgICAgYWRkQW5jZXN0b3JTdGF0ZXNUb0VudGVyKHN0YXRlc1RvRW50ZXIsIGhpc3RvcnlWYWx1ZSwgc3RhdGVzRm9yRGVmYXVsdEVudHJ5LCBhbmNlc3RvcnMsICF0LnNvdXJjZS5wYXJlbnQgJiYgdC5yZWVudGVyID8gdW5kZWZpbmVkIDogZG9tYWluKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZERlc2NlbmRhbnRTdGF0ZXNUb0VudGVyKHN0YXRlTm9kZSwgaGlzdG9yeVZhbHVlLCBzdGF0ZXNGb3JEZWZhdWx0RW50cnksIHN0YXRlc1RvRW50ZXIpIHtcbiAgaWYgKGlzSGlzdG9yeU5vZGUoc3RhdGVOb2RlKSkge1xuICAgIGlmIChoaXN0b3J5VmFsdWVbc3RhdGVOb2RlLmlkXSkge1xuICAgICAgY29uc3QgaGlzdG9yeVN0YXRlTm9kZXMgPSBoaXN0b3J5VmFsdWVbc3RhdGVOb2RlLmlkXTtcbiAgICAgIGZvciAoY29uc3QgcyBvZiBoaXN0b3J5U3RhdGVOb2Rlcykge1xuICAgICAgICBzdGF0ZXNUb0VudGVyLmFkZChzKTtcbiAgICAgICAgYWRkRGVzY2VuZGFudFN0YXRlc1RvRW50ZXIocywgaGlzdG9yeVZhbHVlLCBzdGF0ZXNGb3JEZWZhdWx0RW50cnksIHN0YXRlc1RvRW50ZXIpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBzIG9mIGhpc3RvcnlTdGF0ZU5vZGVzKSB7XG4gICAgICAgIGFkZFByb3BlckFuY2VzdG9yU3RhdGVzVG9FbnRlcihzLCBzdGF0ZU5vZGUucGFyZW50LCBzdGF0ZXNUb0VudGVyLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGhpc3RvcnlEZWZhdWx0VHJhbnNpdGlvbiA9IHJlc29sdmVIaXN0b3J5RGVmYXVsdFRyYW5zaXRpb24oc3RhdGVOb2RlKTtcbiAgICAgIGZvciAoY29uc3QgcyBvZiBoaXN0b3J5RGVmYXVsdFRyYW5zaXRpb24udGFyZ2V0KSB7XG4gICAgICAgIHN0YXRlc1RvRW50ZXIuYWRkKHMpO1xuICAgICAgICBpZiAoaGlzdG9yeURlZmF1bHRUcmFuc2l0aW9uID09PSBzdGF0ZU5vZGUucGFyZW50Py5pbml0aWFsKSB7XG4gICAgICAgICAgc3RhdGVzRm9yRGVmYXVsdEVudHJ5LmFkZChzdGF0ZU5vZGUucGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBhZGREZXNjZW5kYW50U3RhdGVzVG9FbnRlcihzLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSwgc3RhdGVzVG9FbnRlcik7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHMgb2YgaGlzdG9yeURlZmF1bHRUcmFuc2l0aW9uLnRhcmdldCkge1xuICAgICAgICBhZGRQcm9wZXJBbmNlc3RvclN0YXRlc1RvRW50ZXIocywgc3RhdGVOb2RlLnBhcmVudCwgc3RhdGVzVG9FbnRlciwgaGlzdG9yeVZhbHVlLCBzdGF0ZXNGb3JEZWZhdWx0RW50cnkpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoc3RhdGVOb2RlLnR5cGUgPT09ICdjb21wb3VuZCcpIHtcbiAgICAgIGNvbnN0IFtpbml0aWFsU3RhdGVdID0gc3RhdGVOb2RlLmluaXRpYWwudGFyZ2V0O1xuICAgICAgaWYgKCFpc0hpc3RvcnlOb2RlKGluaXRpYWxTdGF0ZSkpIHtcbiAgICAgICAgc3RhdGVzVG9FbnRlci5hZGQoaW5pdGlhbFN0YXRlKTtcbiAgICAgICAgc3RhdGVzRm9yRGVmYXVsdEVudHJ5LmFkZChpbml0aWFsU3RhdGUpO1xuICAgICAgfVxuICAgICAgYWRkRGVzY2VuZGFudFN0YXRlc1RvRW50ZXIoaW5pdGlhbFN0YXRlLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSwgc3RhdGVzVG9FbnRlcik7XG4gICAgICBhZGRQcm9wZXJBbmNlc3RvclN0YXRlc1RvRW50ZXIoaW5pdGlhbFN0YXRlLCBzdGF0ZU5vZGUsIHN0YXRlc1RvRW50ZXIsIGhpc3RvcnlWYWx1ZSwgc3RhdGVzRm9yRGVmYXVsdEVudHJ5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0YXRlTm9kZS50eXBlID09PSAncGFyYWxsZWwnKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgZ2V0Q2hpbGRyZW4oc3RhdGVOb2RlKS5maWx0ZXIoc24gPT4gIWlzSGlzdG9yeU5vZGUoc24pKSkge1xuICAgICAgICAgIGlmICghWy4uLnN0YXRlc1RvRW50ZXJdLnNvbWUocyA9PiBpc0Rlc2NlbmRhbnQocywgY2hpbGQpKSkge1xuICAgICAgICAgICAgaWYgKCFpc0hpc3RvcnlOb2RlKGNoaWxkKSkge1xuICAgICAgICAgICAgICBzdGF0ZXNUb0VudGVyLmFkZChjaGlsZCk7XG4gICAgICAgICAgICAgIHN0YXRlc0ZvckRlZmF1bHRFbnRyeS5hZGQoY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkRGVzY2VuZGFudFN0YXRlc1RvRW50ZXIoY2hpbGQsIGhpc3RvcnlWYWx1ZSwgc3RhdGVzRm9yRGVmYXVsdEVudHJ5LCBzdGF0ZXNUb0VudGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZEFuY2VzdG9yU3RhdGVzVG9FbnRlcihzdGF0ZXNUb0VudGVyLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSwgYW5jZXN0b3JzLCByZWVudHJhbmN5RG9tYWluKSB7XG4gIGZvciAoY29uc3QgYW5jIG9mIGFuY2VzdG9ycykge1xuICAgIGlmICghcmVlbnRyYW5jeURvbWFpbiB8fCBpc0Rlc2NlbmRhbnQoYW5jLCByZWVudHJhbmN5RG9tYWluKSkge1xuICAgICAgc3RhdGVzVG9FbnRlci5hZGQoYW5jKTtcbiAgICB9XG4gICAgaWYgKGFuYy50eXBlID09PSAncGFyYWxsZWwnKSB7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGdldENoaWxkcmVuKGFuYykuZmlsdGVyKHNuID0+ICFpc0hpc3RvcnlOb2RlKHNuKSkpIHtcbiAgICAgICAgaWYgKCFbLi4uc3RhdGVzVG9FbnRlcl0uc29tZShzID0+IGlzRGVzY2VuZGFudChzLCBjaGlsZCkpKSB7XG4gICAgICAgICAgc3RhdGVzVG9FbnRlci5hZGQoY2hpbGQpO1xuICAgICAgICAgIGFkZERlc2NlbmRhbnRTdGF0ZXNUb0VudGVyKGNoaWxkLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSwgc3RhdGVzVG9FbnRlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZFByb3BlckFuY2VzdG9yU3RhdGVzVG9FbnRlcihzdGF0ZU5vZGUsIHRvU3RhdGVOb2RlLCBzdGF0ZXNUb0VudGVyLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSkge1xuICBhZGRBbmNlc3RvclN0YXRlc1RvRW50ZXIoc3RhdGVzVG9FbnRlciwgaGlzdG9yeVZhbHVlLCBzdGF0ZXNGb3JEZWZhdWx0RW50cnksIGdldFByb3BlckFuY2VzdG9ycyhzdGF0ZU5vZGUsIHRvU3RhdGVOb2RlKSk7XG59XG5mdW5jdGlvbiBleGl0U3RhdGVzKGN1cnJlbnRTbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUsIHRyYW5zaXRpb25zLCBtdXRTdGF0ZU5vZGVTZXQsIGhpc3RvcnlWYWx1ZSwgaW50ZXJuYWxRdWV1ZSkge1xuICBsZXQgbmV4dFNuYXBzaG90ID0gY3VycmVudFNuYXBzaG90O1xuICBjb25zdCBzdGF0ZXNUb0V4aXQgPSBjb21wdXRlRXhpdFNldCh0cmFuc2l0aW9ucywgbXV0U3RhdGVOb2RlU2V0LCBoaXN0b3J5VmFsdWUpO1xuICBzdGF0ZXNUb0V4aXQuc29ydCgoYSwgYikgPT4gYi5vcmRlciAtIGEub3JkZXIpO1xuICBsZXQgY2hhbmdlZEhpc3Rvcnk7XG5cbiAgLy8gRnJvbSBTQ1hNTCBhbGdvcml0aG06IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9zY3htbC8jZXhpdFN0YXRlc1xuICBmb3IgKGNvbnN0IGV4aXRTdGF0ZU5vZGUgb2Ygc3RhdGVzVG9FeGl0KSB7XG4gICAgZm9yIChjb25zdCBoaXN0b3J5Tm9kZSBvZiBnZXRIaXN0b3J5Tm9kZXMoZXhpdFN0YXRlTm9kZSkpIHtcbiAgICAgIGxldCBwcmVkaWNhdGU7XG4gICAgICBpZiAoaGlzdG9yeU5vZGUuaGlzdG9yeSA9PT0gJ2RlZXAnKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IHNuID0+IGlzQXRvbWljU3RhdGVOb2RlKHNuKSAmJiBpc0Rlc2NlbmRhbnQoc24sIGV4aXRTdGF0ZU5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJlZGljYXRlID0gc24gPT4ge1xuICAgICAgICAgIHJldHVybiBzbi5wYXJlbnQgPT09IGV4aXRTdGF0ZU5vZGU7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjaGFuZ2VkSGlzdG9yeSA/Pz0ge1xuICAgICAgICAuLi5oaXN0b3J5VmFsdWVcbiAgICAgIH07XG4gICAgICBjaGFuZ2VkSGlzdG9yeVtoaXN0b3J5Tm9kZS5pZF0gPSBBcnJheS5mcm9tKG11dFN0YXRlTm9kZVNldCkuZmlsdGVyKHByZWRpY2F0ZSk7XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgcyBvZiBzdGF0ZXNUb0V4aXQpIHtcbiAgICBuZXh0U25hcHNob3QgPSByZXNvbHZlQWN0aW9uc0FuZENvbnRleHQobmV4dFNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSwgWy4uLnMuZXhpdCwgLi4ucy5pbnZva2UubWFwKGRlZiA9PiBzdG9wQ2hpbGQoZGVmLmlkKSldLCBpbnRlcm5hbFF1ZXVlKTtcbiAgICBtdXRTdGF0ZU5vZGVTZXQuZGVsZXRlKHMpO1xuICB9XG4gIHJldHVybiBbbmV4dFNuYXBzaG90LCBjaGFuZ2VkSGlzdG9yeSB8fCBoaXN0b3J5VmFsdWVdO1xufVxubGV0IGV4ZWN1dGluZ0N1c3RvbUFjdGlvbiA9IGZhbHNlO1xuZnVuY3Rpb24gcmVzb2x2ZUFuZEV4ZWN1dGVBY3Rpb25zV2l0aENvbnRleHQoY3VycmVudFNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSwgYWN0aW9ucywgZXh0cmEsIHJldHJpZXMpIHtcbiAgY29uc3Qge1xuICAgIG1hY2hpbmVcbiAgfSA9IGN1cnJlbnRTbmFwc2hvdDtcbiAgbGV0IGludGVybWVkaWF0ZVNuYXBzaG90ID0gY3VycmVudFNuYXBzaG90O1xuICBmb3IgKGNvbnN0IGFjdGlvbiBvZiBhY3Rpb25zKSB7XG4gICAgY29uc3QgaXNJbmxpbmUgPSB0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nO1xuICAgIGNvbnN0IHJlc29sdmVkQWN0aW9uID0gaXNJbmxpbmUgPyBhY3Rpb24gOlxuICAgIC8vIHRoZSBleGlzdGluZyB0eXBlIG9mIGAuYWN0aW9uc2AgYXNzdW1lcyBub24tbnVsbGFibGUgYFRFeHByZXNzaW9uQWN0aW9uYFxuICAgIC8vIGl0J3MgZmluZSB0byBjYXN0IHRoaXMgaGVyZSB0byBnZXQgYSBjb21tb24gdHlwZSBhbmQgbGFjayBvZiBlcnJvcnMgaW4gdGhlIHJlc3Qgb2YgdGhlIGNvZGVcbiAgICAvLyBvdXIgbG9naWMgYmVsb3cgbWFrZXMgc3VyZSB0aGF0IHdlIGNhbGwgdGhvc2UgMiBcInZhcmlhbnRzXCIgY29ycmVjdGx5XG4gICAgbWFjaGluZS5pbXBsZW1lbnRhdGlvbnMuYWN0aW9uc1t0eXBlb2YgYWN0aW9uID09PSAnc3RyaW5nJyA/IGFjdGlvbiA6IGFjdGlvbi50eXBlXTtcbiAgICBpZiAoIXJlc29sdmVkQWN0aW9uKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgYWN0aW9uQXJncyA9IHtcbiAgICAgIGNvbnRleHQ6IGludGVybWVkaWF0ZVNuYXBzaG90LmNvbnRleHQsXG4gICAgICBldmVudCxcbiAgICAgIHNlbGY6IGFjdG9yU2NvcGUuc2VsZixcbiAgICAgIHN5c3RlbTogYWN0b3JTY29wZS5zeXN0ZW1cbiAgICB9O1xuICAgIGNvbnN0IGFjdGlvblBhcmFtcyA9IGlzSW5saW5lIHx8IHR5cGVvZiBhY3Rpb24gPT09ICdzdHJpbmcnID8gdW5kZWZpbmVkIDogJ3BhcmFtcycgaW4gYWN0aW9uID8gdHlwZW9mIGFjdGlvbi5wYXJhbXMgPT09ICdmdW5jdGlvbicgPyBhY3Rpb24ucGFyYW1zKHtcbiAgICAgIGNvbnRleHQ6IGludGVybWVkaWF0ZVNuYXBzaG90LmNvbnRleHQsXG4gICAgICBldmVudFxuICAgIH0pIDogYWN0aW9uLnBhcmFtcyA6IHVuZGVmaW5lZDtcbiAgICBmdW5jdGlvbiBleGVjdXRlQWN0aW9uKCkge1xuICAgICAgYWN0b3JTY29wZS5zeXN0ZW0uX3NlbmRJbnNwZWN0aW9uRXZlbnQoe1xuICAgICAgICB0eXBlOiAnQHhzdGF0ZS5hY3Rpb24nLFxuICAgICAgICBhY3RvclJlZjogYWN0b3JTY29wZS5zZWxmLFxuICAgICAgICBhY3Rpb246IHtcbiAgICAgICAgICB0eXBlOiB0eXBlb2YgYWN0aW9uID09PSAnc3RyaW5nJyA/IGFjdGlvbiA6IHR5cGVvZiBhY3Rpb24gPT09ICdvYmplY3QnID8gYWN0aW9uLnR5cGUgOiBhY3Rpb24ubmFtZSB8fCAnKGFub255bW91cyknLFxuICAgICAgICAgIHBhcmFtczogYWN0aW9uUGFyYW1zXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZXhlY3V0aW5nQ3VzdG9tQWN0aW9uID0gcmVzb2x2ZWRBY3Rpb247XG4gICAgICAgIHJlc29sdmVkQWN0aW9uKGFjdGlvbkFyZ3MsIGFjdGlvblBhcmFtcyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBleGVjdXRpbmdDdXN0b21BY3Rpb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCEoJ3Jlc29sdmUnIGluIHJlc29sdmVkQWN0aW9uKSkge1xuICAgICAgaWYgKGFjdG9yU2NvcGUuc2VsZi5fcHJvY2Vzc2luZ1N0YXR1cyA9PT0gUHJvY2Vzc2luZ1N0YXR1cy5SdW5uaW5nKSB7XG4gICAgICAgIGV4ZWN1dGVBY3Rpb24oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdG9yU2NvcGUuZGVmZXIoKCkgPT4ge1xuICAgICAgICAgIGV4ZWN1dGVBY3Rpb24oKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgYnVpbHRpbkFjdGlvbiA9IHJlc29sdmVkQWN0aW9uO1xuICAgIGNvbnN0IFtuZXh0U3RhdGUsIHBhcmFtcywgYWN0aW9uc10gPSBidWlsdGluQWN0aW9uLnJlc29sdmUoYWN0b3JTY29wZSwgaW50ZXJtZWRpYXRlU25hcHNob3QsIGFjdGlvbkFyZ3MsIGFjdGlvblBhcmFtcywgcmVzb2x2ZWRBY3Rpb24sXG4gICAgLy8gdGhpcyBob2xkcyBhbGwgcGFyYW1zXG4gICAgZXh0cmEpO1xuICAgIGludGVybWVkaWF0ZVNuYXBzaG90ID0gbmV4dFN0YXRlO1xuICAgIGlmICgncmV0cnlSZXNvbHZlJyBpbiBidWlsdGluQWN0aW9uKSB7XG4gICAgICByZXRyaWVzPy5wdXNoKFtidWlsdGluQWN0aW9uLCBwYXJhbXNdKTtcbiAgICB9XG4gICAgaWYgKCdleGVjdXRlJyBpbiBidWlsdGluQWN0aW9uKSB7XG4gICAgICBpZiAoYWN0b3JTY29wZS5zZWxmLl9wcm9jZXNzaW5nU3RhdHVzID09PSBQcm9jZXNzaW5nU3RhdHVzLlJ1bm5pbmcpIHtcbiAgICAgICAgYnVpbHRpbkFjdGlvbi5leGVjdXRlKGFjdG9yU2NvcGUsIHBhcmFtcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3RvclNjb3BlLmRlZmVyKGJ1aWx0aW5BY3Rpb24uZXhlY3V0ZS5iaW5kKG51bGwsIGFjdG9yU2NvcGUsIHBhcmFtcykpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWN0aW9ucykge1xuICAgICAgaW50ZXJtZWRpYXRlU25hcHNob3QgPSByZXNvbHZlQW5kRXhlY3V0ZUFjdGlvbnNXaXRoQ29udGV4dChpbnRlcm1lZGlhdGVTbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUsIGFjdGlvbnMsIGV4dHJhLCByZXRyaWVzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGludGVybWVkaWF0ZVNuYXBzaG90O1xufVxuZnVuY3Rpb24gcmVzb2x2ZUFjdGlvbnNBbmRDb250ZXh0KGN1cnJlbnRTbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUsIGFjdGlvbnMsIGludGVybmFsUXVldWUsIGRlZmVycmVkQWN0b3JJZHMpIHtcbiAgY29uc3QgcmV0cmllcyA9IGRlZmVycmVkQWN0b3JJZHMgPyBbXSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgbmV4dFN0YXRlID0gcmVzb2x2ZUFuZEV4ZWN1dGVBY3Rpb25zV2l0aENvbnRleHQoY3VycmVudFNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSwgYWN0aW9ucywge1xuICAgIGludGVybmFsUXVldWUsXG4gICAgZGVmZXJyZWRBY3Rvcklkc1xuICB9LCByZXRyaWVzKTtcbiAgcmV0cmllcz8uZm9yRWFjaCgoW2J1aWx0aW5BY3Rpb24sIHBhcmFtc10pID0+IHtcbiAgICBidWlsdGluQWN0aW9uLnJldHJ5UmVzb2x2ZShhY3RvclNjb3BlLCBuZXh0U3RhdGUsIHBhcmFtcyk7XG4gIH0pO1xuICByZXR1cm4gbmV4dFN0YXRlO1xufVxuZnVuY3Rpb24gbWFjcm9zdGVwKHNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSwgaW50ZXJuYWxRdWV1ZSA9IFtdKSB7XG4gIGlmIChldmVudC50eXBlID09PSBXSUxEQ0FSRCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQW4gZXZlbnQgY2Fubm90IGhhdmUgdGhlIHdpbGRjYXJkIHR5cGUgKCcke1dJTERDQVJEfScpYCk7XG4gIH1cbiAgbGV0IG5leHRTbmFwc2hvdCA9IHNuYXBzaG90O1xuICBjb25zdCBtaWNyb3N0YXRlcyA9IFtdO1xuICBmdW5jdGlvbiBhZGRNaWNyb3N0YXRlKG1pY3Jvc3RhdGUsIGV2ZW50LCB0cmFuc2l0aW9ucykge1xuICAgIGFjdG9yU2NvcGUuc3lzdGVtLl9zZW5kSW5zcGVjdGlvbkV2ZW50KHtcbiAgICAgIHR5cGU6ICdAeHN0YXRlLm1pY3Jvc3RlcCcsXG4gICAgICBhY3RvclJlZjogYWN0b3JTY29wZS5zZWxmLFxuICAgICAgZXZlbnQsXG4gICAgICBzbmFwc2hvdDogbWljcm9zdGF0ZSxcbiAgICAgIF90cmFuc2l0aW9uczogdHJhbnNpdGlvbnNcbiAgICB9KTtcbiAgICBtaWNyb3N0YXRlcy5wdXNoKG1pY3Jvc3RhdGUpO1xuICB9XG5cbiAgLy8gSGFuZGxlIHN0b3AgZXZlbnRcbiAgaWYgKGV2ZW50LnR5cGUgPT09IFhTVEFURV9TVE9QKSB7XG4gICAgbmV4dFNuYXBzaG90ID0gY2xvbmVNYWNoaW5lU25hcHNob3Qoc3RvcENoaWxkcmVuKG5leHRTbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUpLCB7XG4gICAgICBzdGF0dXM6ICdzdG9wcGVkJ1xuICAgIH0pO1xuICAgIGFkZE1pY3Jvc3RhdGUobmV4dFNuYXBzaG90LCBldmVudCwgW10pO1xuICAgIHJldHVybiB7XG4gICAgICBzbmFwc2hvdDogbmV4dFNuYXBzaG90LFxuICAgICAgbWljcm9zdGF0ZXNcbiAgICB9O1xuICB9XG4gIGxldCBuZXh0RXZlbnQgPSBldmVudDtcblxuICAvLyBBc3N1bWUgdGhlIHN0YXRlIGlzIGF0IHJlc3QgKG5vIHJhaXNlZCBldmVudHMpXG4gIC8vIERldGVybWluZSB0aGUgbmV4dCBzdGF0ZSBiYXNlZCBvbiB0aGUgbmV4dCBtaWNyb3N0ZXBcbiAgaWYgKG5leHRFdmVudC50eXBlICE9PSBYU1RBVEVfSU5JVCkge1xuICAgIGNvbnN0IGN1cnJlbnRFdmVudCA9IG5leHRFdmVudDtcbiAgICBjb25zdCBpc0VyciA9IGlzRXJyb3JBY3RvckV2ZW50KGN1cnJlbnRFdmVudCk7XG4gICAgY29uc3QgdHJhbnNpdGlvbnMgPSBzZWxlY3RUcmFuc2l0aW9ucyhjdXJyZW50RXZlbnQsIG5leHRTbmFwc2hvdCk7XG4gICAgaWYgKGlzRXJyICYmICF0cmFuc2l0aW9ucy5sZW5ndGgpIHtcbiAgICAgIC8vIFRPRE86IHdlIHNob3VsZCBsaWtlbHkgb25seSBhbGxvdyB0cmFuc2l0aW9ucyBzZWxlY3RlZCBieSB2ZXJ5IGV4cGxpY2l0IGRlc2NyaXB0b3JzXG4gICAgICAvLyBgKmAgc2hvdWxkbid0IGJlIG1hdGNoZWQsIGxpa2VseSBgeHN0YXRlLmVycm9yLipgIHNob3VsZG50IGJlIGVpdGhlclxuICAgICAgLy8gc2ltaWxhcmx5IGB4c3RhdGUuZXJyb3IuYWN0b3IuKmAgYW5kIGB4c3RhdGUuZXJyb3IuYWN0b3IudG9kby4qYCBoYXZlIHRvIGJlIGNvbnNpZGVyZWQgdG9vXG4gICAgICBuZXh0U25hcHNob3QgPSBjbG9uZU1hY2hpbmVTbmFwc2hvdChzbmFwc2hvdCwge1xuICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgIGVycm9yOiBjdXJyZW50RXZlbnQuZXJyb3JcbiAgICAgIH0pO1xuICAgICAgYWRkTWljcm9zdGF0ZShuZXh0U25hcHNob3QsIGN1cnJlbnRFdmVudCwgW10pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc25hcHNob3Q6IG5leHRTbmFwc2hvdCxcbiAgICAgICAgbWljcm9zdGF0ZXNcbiAgICAgIH07XG4gICAgfVxuICAgIG5leHRTbmFwc2hvdCA9IG1pY3Jvc3RlcCh0cmFuc2l0aW9ucywgc25hcHNob3QsIGFjdG9yU2NvcGUsIG5leHRFdmVudCwgZmFsc2UsXG4gICAgLy8gaXNJbml0aWFsXG4gICAgaW50ZXJuYWxRdWV1ZSk7XG4gICAgYWRkTWljcm9zdGF0ZShuZXh0U25hcHNob3QsIGN1cnJlbnRFdmVudCwgdHJhbnNpdGlvbnMpO1xuICB9XG4gIGxldCBzaG91bGRTZWxlY3RFdmVudGxlc3NUcmFuc2l0aW9ucyA9IHRydWU7XG4gIHdoaWxlIChuZXh0U25hcHNob3Quc3RhdHVzID09PSAnYWN0aXZlJykge1xuICAgIGxldCBlbmFibGVkVHJhbnNpdGlvbnMgPSBzaG91bGRTZWxlY3RFdmVudGxlc3NUcmFuc2l0aW9ucyA/IHNlbGVjdEV2ZW50bGVzc1RyYW5zaXRpb25zKG5leHRTbmFwc2hvdCwgbmV4dEV2ZW50KSA6IFtdO1xuXG4gICAgLy8gZXZlbnRsZXNzIHRyYW5zaXRpb25zIHNob3VsZCBhbHdheXMgYmUgc2VsZWN0ZWQgYWZ0ZXIgc2VsZWN0aW5nICpyZWd1bGFyKiB0cmFuc2l0aW9uc1xuICAgIC8vIGJ5IGFzc2lnbmluZyBgdW5kZWZpbmVkYCB0byBgcHJldmlvdXNTdGF0ZWAgd2UgZW5zdXJlIHRoYXQgYHNob3VsZFNlbGVjdEV2ZW50bGVzc1RyYW5zaXRpb25zYCBnZXRzIGFsd2F5cyBjb21wdXRlZCB0byB0cnVlIGluIHN1Y2ggYSBjYXNlXG4gICAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IGVuYWJsZWRUcmFuc2l0aW9ucy5sZW5ndGggPyBuZXh0U25hcHNob3QgOiB1bmRlZmluZWQ7XG4gICAgaWYgKCFlbmFibGVkVHJhbnNpdGlvbnMubGVuZ3RoKSB7XG4gICAgICBpZiAoIWludGVybmFsUXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbmV4dEV2ZW50ID0gaW50ZXJuYWxRdWV1ZS5zaGlmdCgpO1xuICAgICAgZW5hYmxlZFRyYW5zaXRpb25zID0gc2VsZWN0VHJhbnNpdGlvbnMobmV4dEV2ZW50LCBuZXh0U25hcHNob3QpO1xuICAgIH1cbiAgICBuZXh0U25hcHNob3QgPSBtaWNyb3N0ZXAoZW5hYmxlZFRyYW5zaXRpb25zLCBuZXh0U25hcHNob3QsIGFjdG9yU2NvcGUsIG5leHRFdmVudCwgZmFsc2UsIGludGVybmFsUXVldWUpO1xuICAgIHNob3VsZFNlbGVjdEV2ZW50bGVzc1RyYW5zaXRpb25zID0gbmV4dFNuYXBzaG90ICE9PSBwcmV2aW91c1N0YXRlO1xuICAgIGFkZE1pY3Jvc3RhdGUobmV4dFNuYXBzaG90LCBuZXh0RXZlbnQsIGVuYWJsZWRUcmFuc2l0aW9ucyk7XG4gIH1cbiAgaWYgKG5leHRTbmFwc2hvdC5zdGF0dXMgIT09ICdhY3RpdmUnKSB7XG4gICAgc3RvcENoaWxkcmVuKG5leHRTbmFwc2hvdCwgbmV4dEV2ZW50LCBhY3RvclNjb3BlKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNuYXBzaG90OiBuZXh0U25hcHNob3QsXG4gICAgbWljcm9zdGF0ZXNcbiAgfTtcbn1cbmZ1bmN0aW9uIHN0b3BDaGlsZHJlbihuZXh0U3RhdGUsIGV2ZW50LCBhY3RvclNjb3BlKSB7XG4gIHJldHVybiByZXNvbHZlQWN0aW9uc0FuZENvbnRleHQobmV4dFN0YXRlLCBldmVudCwgYWN0b3JTY29wZSwgT2JqZWN0LnZhbHVlcyhuZXh0U3RhdGUuY2hpbGRyZW4pLm1hcChjaGlsZCA9PiBzdG9wQ2hpbGQoY2hpbGQpKSwgW10pO1xufVxuZnVuY3Rpb24gc2VsZWN0VHJhbnNpdGlvbnMoZXZlbnQsIG5leHRTdGF0ZSkge1xuICByZXR1cm4gbmV4dFN0YXRlLm1hY2hpbmUuZ2V0VHJhbnNpdGlvbkRhdGEobmV4dFN0YXRlLCBldmVudCk7XG59XG5mdW5jdGlvbiBzZWxlY3RFdmVudGxlc3NUcmFuc2l0aW9ucyhuZXh0U3RhdGUsIGV2ZW50KSB7XG4gIGNvbnN0IGVuYWJsZWRUcmFuc2l0aW9uU2V0ID0gbmV3IFNldCgpO1xuICBjb25zdCBhdG9taWNTdGF0ZXMgPSBuZXh0U3RhdGUuX25vZGVzLmZpbHRlcihpc0F0b21pY1N0YXRlTm9kZSk7XG4gIGZvciAoY29uc3Qgc3RhdGVOb2RlIG9mIGF0b21pY1N0YXRlcykge1xuICAgIGxvb3A6IGZvciAoY29uc3QgcyBvZiBbc3RhdGVOb2RlXS5jb25jYXQoZ2V0UHJvcGVyQW5jZXN0b3JzKHN0YXRlTm9kZSwgdW5kZWZpbmVkKSkpIHtcbiAgICAgIGlmICghcy5hbHdheXMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHRyYW5zaXRpb24gb2Ygcy5hbHdheXMpIHtcbiAgICAgICAgaWYgKHRyYW5zaXRpb24uZ3VhcmQgPT09IHVuZGVmaW5lZCB8fCBldmFsdWF0ZUd1YXJkKHRyYW5zaXRpb24uZ3VhcmQsIG5leHRTdGF0ZS5jb250ZXh0LCBldmVudCwgbmV4dFN0YXRlKSkge1xuICAgICAgICAgIGVuYWJsZWRUcmFuc2l0aW9uU2V0LmFkZCh0cmFuc2l0aW9uKTtcbiAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZW1vdmVDb25mbGljdGluZ1RyYW5zaXRpb25zKEFycmF5LmZyb20oZW5hYmxlZFRyYW5zaXRpb25TZXQpLCBuZXcgU2V0KG5leHRTdGF0ZS5fbm9kZXMpLCBuZXh0U3RhdGUuaGlzdG9yeVZhbHVlKTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlcyBhIHBhcnRpYWwgc3RhdGUgdmFsdWUgd2l0aCBpdHMgZnVsbCByZXByZXNlbnRhdGlvbiBpbiB0aGUgc3RhdGVcbiAqIG5vZGUncyBtYWNoaW5lLlxuICpcbiAqIEBwYXJhbSBzdGF0ZVZhbHVlIFRoZSBwYXJ0aWFsIHN0YXRlIHZhbHVlIHRvIHJlc29sdmUuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVTdGF0ZVZhbHVlKHJvb3ROb2RlLCBzdGF0ZVZhbHVlKSB7XG4gIGNvbnN0IGFsbFN0YXRlTm9kZXMgPSBnZXRBbGxTdGF0ZU5vZGVzKGdldFN0YXRlTm9kZXMocm9vdE5vZGUsIHN0YXRlVmFsdWUpKTtcbiAgcmV0dXJuIGdldFN0YXRlVmFsdWUocm9vdE5vZGUsIFsuLi5hbGxTdGF0ZU5vZGVzXSk7XG59XG5cbmZ1bmN0aW9uIGlzTWFjaGluZVNuYXBzaG90KHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgJ21hY2hpbmUnIGluIHZhbHVlICYmICd2YWx1ZScgaW4gdmFsdWU7XG59XG5jb25zdCBtYWNoaW5lU25hcHNob3RNYXRjaGVzID0gZnVuY3Rpb24gbWF0Y2hlcyh0ZXN0VmFsdWUpIHtcbiAgcmV0dXJuIG1hdGNoZXNTdGF0ZSh0ZXN0VmFsdWUsIHRoaXMudmFsdWUpO1xufTtcbmNvbnN0IG1hY2hpbmVTbmFwc2hvdEhhc1RhZyA9IGZ1bmN0aW9uIGhhc1RhZyh0YWcpIHtcbiAgcmV0dXJuIHRoaXMudGFncy5oYXModGFnKTtcbn07XG5jb25zdCBtYWNoaW5lU25hcHNob3RDYW4gPSBmdW5jdGlvbiBjYW4oZXZlbnQpIHtcbiAgaWYgKCF0aGlzLm1hY2hpbmUpIHtcbiAgICBjb25zb2xlLndhcm4oYHN0YXRlLmNhbiguLi4pIHVzZWQgb3V0c2lkZSBvZiBhIG1hY2hpbmUtY3JlYXRlZCBTdGF0ZSBvYmplY3Q7IHRoaXMgd2lsbCBhbHdheXMgcmV0dXJuIGZhbHNlLmApO1xuICB9XG4gIGNvbnN0IHRyYW5zaXRpb25EYXRhID0gdGhpcy5tYWNoaW5lLmdldFRyYW5zaXRpb25EYXRhKHRoaXMsIGV2ZW50KTtcbiAgcmV0dXJuICEhdHJhbnNpdGlvbkRhdGE/Lmxlbmd0aCAmJlxuICAvLyBDaGVjayB0aGF0IGF0IGxlYXN0IG9uZSB0cmFuc2l0aW9uIGlzIG5vdCBmb3JiaWRkZW5cbiAgdHJhbnNpdGlvbkRhdGEuc29tZSh0ID0+IHQudGFyZ2V0ICE9PSB1bmRlZmluZWQgfHwgdC5hY3Rpb25zLmxlbmd0aCk7XG59O1xuY29uc3QgbWFjaGluZVNuYXBzaG90VG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICBjb25zdCB7XG4gICAgX25vZGVzOiBub2RlcyxcbiAgICB0YWdzLFxuICAgIG1hY2hpbmUsXG4gICAgZ2V0TWV0YSxcbiAgICB0b0pTT04sXG4gICAgY2FuLFxuICAgIGhhc1RhZyxcbiAgICBtYXRjaGVzLFxuICAgIC4uLmpzb25WYWx1ZXNcbiAgfSA9IHRoaXM7XG4gIHJldHVybiB7XG4gICAgLi4uanNvblZhbHVlcyxcbiAgICB0YWdzOiBBcnJheS5mcm9tKHRhZ3MpXG4gIH07XG59O1xuY29uc3QgbWFjaGluZVNuYXBzaG90R2V0TWV0YSA9IGZ1bmN0aW9uIGdldE1ldGEoKSB7XG4gIHJldHVybiB0aGlzLl9ub2Rlcy5yZWR1Y2UoKGFjYywgc3RhdGVOb2RlKSA9PiB7XG4gICAgaWYgKHN0YXRlTm9kZS5tZXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGFjY1tzdGF0ZU5vZGUuaWRdID0gc3RhdGVOb2RlLm1ldGE7XG4gICAgfVxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbn07XG5mdW5jdGlvbiBjcmVhdGVNYWNoaW5lU25hcHNob3QoY29uZmlnLCBtYWNoaW5lKSB7XG4gIHJldHVybiB7XG4gICAgc3RhdHVzOiBjb25maWcuc3RhdHVzLFxuICAgIG91dHB1dDogY29uZmlnLm91dHB1dCxcbiAgICBlcnJvcjogY29uZmlnLmVycm9yLFxuICAgIG1hY2hpbmUsXG4gICAgY29udGV4dDogY29uZmlnLmNvbnRleHQsXG4gICAgX25vZGVzOiBjb25maWcuX25vZGVzLFxuICAgIHZhbHVlOiBnZXRTdGF0ZVZhbHVlKG1hY2hpbmUucm9vdCwgY29uZmlnLl9ub2RlcyksXG4gICAgdGFnczogbmV3IFNldChjb25maWcuX25vZGVzLmZsYXRNYXAoc24gPT4gc24udGFncykpLFxuICAgIGNoaWxkcmVuOiBjb25maWcuY2hpbGRyZW4sXG4gICAgaGlzdG9yeVZhbHVlOiBjb25maWcuaGlzdG9yeVZhbHVlIHx8IHt9LFxuICAgIG1hdGNoZXM6IG1hY2hpbmVTbmFwc2hvdE1hdGNoZXMsXG4gICAgaGFzVGFnOiBtYWNoaW5lU25hcHNob3RIYXNUYWcsXG4gICAgY2FuOiBtYWNoaW5lU25hcHNob3RDYW4sXG4gICAgZ2V0TWV0YTogbWFjaGluZVNuYXBzaG90R2V0TWV0YSxcbiAgICB0b0pTT046IG1hY2hpbmVTbmFwc2hvdFRvSlNPTlxuICB9O1xufVxuZnVuY3Rpb24gY2xvbmVNYWNoaW5lU25hcHNob3Qoc25hcHNob3QsIGNvbmZpZyA9IHt9KSB7XG4gIHJldHVybiBjcmVhdGVNYWNoaW5lU25hcHNob3Qoe1xuICAgIC4uLnNuYXBzaG90LFxuICAgIC4uLmNvbmZpZ1xuICB9LCBzbmFwc2hvdC5tYWNoaW5lKTtcbn1cbmZ1bmN0aW9uIGdldFBlcnNpc3RlZFNuYXBzaG90KHNuYXBzaG90LCBvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBfbm9kZXM6IG5vZGVzLFxuICAgIHRhZ3MsXG4gICAgbWFjaGluZSxcbiAgICBjaGlsZHJlbixcbiAgICBjb250ZXh0LFxuICAgIGNhbixcbiAgICBoYXNUYWcsXG4gICAgbWF0Y2hlcyxcbiAgICBnZXRNZXRhLFxuICAgIHRvSlNPTixcbiAgICAuLi5qc29uVmFsdWVzXG4gIH0gPSBzbmFwc2hvdDtcbiAgY29uc3QgY2hpbGRyZW5Kc29uID0ge307XG4gIGZvciAoY29uc3QgaWQgaW4gY2hpbGRyZW4pIHtcbiAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2lkXTtcbiAgICBpZiAodHlwZW9mIGNoaWxkLnNyYyAhPT0gJ3N0cmluZycgJiYgKCFvcHRpb25zIHx8ICEoJ19fdW5zYWZlQWxsb3dJbmxpbmVBY3RvcnMnIGluIG9wdGlvbnMpKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbiBpbmxpbmUgY2hpbGQgYWN0b3IgY2Fubm90IGJlIHBlcnNpc3RlZC4nKTtcbiAgICB9XG4gICAgY2hpbGRyZW5Kc29uW2lkXSA9IHtcbiAgICAgIHNuYXBzaG90OiBjaGlsZC5nZXRQZXJzaXN0ZWRTbmFwc2hvdChvcHRpb25zKSxcbiAgICAgIHNyYzogY2hpbGQuc3JjLFxuICAgICAgc3lzdGVtSWQ6IGNoaWxkLl9zeXN0ZW1JZCxcbiAgICAgIHN5bmNTbmFwc2hvdDogY2hpbGQuX3N5bmNTbmFwc2hvdFxuICAgIH07XG4gIH1cbiAgY29uc3QgcGVyc2lzdGVkID0ge1xuICAgIC4uLmpzb25WYWx1ZXMsXG4gICAgY29udGV4dDogcGVyc2lzdENvbnRleHQoY29udGV4dCksXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuSnNvblxuICB9O1xuICByZXR1cm4gcGVyc2lzdGVkO1xufVxuZnVuY3Rpb24gcGVyc2lzdENvbnRleHQoY29udGV4dFBhcnQpIHtcbiAgbGV0IGNvcHk7XG4gIGZvciAoY29uc3Qga2V5IGluIGNvbnRleHRQYXJ0KSB7XG4gICAgY29uc3QgdmFsdWUgPSBjb250ZXh0UGFydFtrZXldO1xuICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoJ3Nlc3Npb25JZCcgaW4gdmFsdWUgJiYgJ3NlbmQnIGluIHZhbHVlICYmICdyZWYnIGluIHZhbHVlKSB7XG4gICAgICAgIGNvcHkgPz89IEFycmF5LmlzQXJyYXkoY29udGV4dFBhcnQpID8gY29udGV4dFBhcnQuc2xpY2UoKSA6IHtcbiAgICAgICAgICAuLi5jb250ZXh0UGFydFxuICAgICAgICB9O1xuICAgICAgICBjb3B5W2tleV0gPSB7XG4gICAgICAgICAgeHN0YXRlJCR0eXBlOiAkJEFDVE9SX1RZUEUsXG4gICAgICAgICAgaWQ6IHZhbHVlLmlkXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBwZXJzaXN0Q29udGV4dCh2YWx1ZSk7XG4gICAgICAgIGlmIChyZXN1bHQgIT09IHZhbHVlKSB7XG4gICAgICAgICAgY29weSA/Pz0gQXJyYXkuaXNBcnJheShjb250ZXh0UGFydCkgPyBjb250ZXh0UGFydC5zbGljZSgpIDoge1xuICAgICAgICAgICAgLi4uY29udGV4dFBhcnRcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvcHlba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29weSA/PyBjb250ZXh0UGFydDtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVJhaXNlKF8sIHNuYXBzaG90LCBhcmdzLCBhY3Rpb25QYXJhbXMsIHtcbiAgZXZlbnQ6IGV2ZW50T3JFeHByLFxuICBpZCxcbiAgZGVsYXlcbn0sIHtcbiAgaW50ZXJuYWxRdWV1ZVxufSkge1xuICBjb25zdCBkZWxheXNNYXAgPSBzbmFwc2hvdC5tYWNoaW5lLmltcGxlbWVudGF0aW9ucy5kZWxheXM7XG4gIGlmICh0eXBlb2YgZXZlbnRPckV4cHIgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBPbmx5IGV2ZW50IG9iamVjdHMgbWF5IGJlIHVzZWQgd2l0aCByYWlzZTsgdXNlIHJhaXNlKHsgdHlwZTogXCIke2V2ZW50T3JFeHByfVwiIH0pIGluc3RlYWRgKTtcbiAgfVxuICBjb25zdCByZXNvbHZlZEV2ZW50ID0gdHlwZW9mIGV2ZW50T3JFeHByID09PSAnZnVuY3Rpb24nID8gZXZlbnRPckV4cHIoYXJncywgYWN0aW9uUGFyYW1zKSA6IGV2ZW50T3JFeHByO1xuICBsZXQgcmVzb2x2ZWREZWxheTtcbiAgaWYgKHR5cGVvZiBkZWxheSA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBjb25maWdEZWxheSA9IGRlbGF5c01hcCAmJiBkZWxheXNNYXBbZGVsYXldO1xuICAgIHJlc29sdmVkRGVsYXkgPSB0eXBlb2YgY29uZmlnRGVsYXkgPT09ICdmdW5jdGlvbicgPyBjb25maWdEZWxheShhcmdzLCBhY3Rpb25QYXJhbXMpIDogY29uZmlnRGVsYXk7XG4gIH0gZWxzZSB7XG4gICAgcmVzb2x2ZWREZWxheSA9IHR5cGVvZiBkZWxheSA9PT0gJ2Z1bmN0aW9uJyA/IGRlbGF5KGFyZ3MsIGFjdGlvblBhcmFtcykgOiBkZWxheTtcbiAgfVxuICBpZiAodHlwZW9mIHJlc29sdmVkRGVsYXkgIT09ICdudW1iZXInKSB7XG4gICAgaW50ZXJuYWxRdWV1ZS5wdXNoKHJlc29sdmVkRXZlbnQpO1xuICB9XG4gIHJldHVybiBbc25hcHNob3QsIHtcbiAgICBldmVudDogcmVzb2x2ZWRFdmVudCxcbiAgICBpZCxcbiAgICBkZWxheTogcmVzb2x2ZWREZWxheVxuICB9XTtcbn1cbmZ1bmN0aW9uIGV4ZWN1dGVSYWlzZShhY3RvclNjb3BlLCBwYXJhbXMpIHtcbiAgY29uc3Qge1xuICAgIGV2ZW50LFxuICAgIGRlbGF5LFxuICAgIGlkXG4gIH0gPSBwYXJhbXM7XG4gIGlmICh0eXBlb2YgZGVsYXkgPT09ICdudW1iZXInKSB7XG4gICAgYWN0b3JTY29wZS5kZWZlcigoKSA9PiB7XG4gICAgICBjb25zdCBzZWxmID0gYWN0b3JTY29wZS5zZWxmO1xuICAgICAgYWN0b3JTY29wZS5zeXN0ZW0uc2NoZWR1bGVyLnNjaGVkdWxlKHNlbGYsIHNlbGYsIGV2ZW50LCBkZWxheSwgaWQpO1xuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxufVxuLyoqXG4gKiBSYWlzZXMgYW4gZXZlbnQuIFRoaXMgcGxhY2VzIHRoZSBldmVudCBpbiB0aGUgaW50ZXJuYWwgZXZlbnQgcXVldWUsIHNvIHRoYXRcbiAqIHRoZSBldmVudCBpcyBpbW1lZGlhdGVseSBjb25zdW1lZCBieSB0aGUgbWFjaGluZSBpbiB0aGUgY3VycmVudCBzdGVwLlxuICpcbiAqIEBwYXJhbSBldmVudFR5cGUgVGhlIGV2ZW50IHRvIHJhaXNlLlxuICovXG5mdW5jdGlvbiByYWlzZShldmVudE9yRXhwciwgb3B0aW9ucykge1xuICBpZiAoZXhlY3V0aW5nQ3VzdG9tQWN0aW9uKSB7XG4gICAgY29uc29sZS53YXJuKCdDdXN0b20gYWN0aW9ucyBzaG91bGQgbm90IGNhbGwgYHJhaXNlKClgIGRpcmVjdGx5LCBhcyBpdCBpcyBub3QgaW1wZXJhdGl2ZS4gU2VlIGh0dHBzOi8vc3RhdGVseS5haS9kb2NzL2FjdGlvbnMjYnVpbHQtaW4tYWN0aW9ucyBmb3IgbW9yZSBkZXRhaWxzLicpO1xuICB9XG4gIGZ1bmN0aW9uIHJhaXNlKGFyZ3MsIHBhcmFtcykge1xuICAgIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhpcyBpc24ndCBzdXBwb3NlZCB0byBiZSBjYWxsZWRgKTtcbiAgICB9XG4gIH1cbiAgcmFpc2UudHlwZSA9ICd4c3RhdGUucmFpc2UnO1xuICByYWlzZS5ldmVudCA9IGV2ZW50T3JFeHByO1xuICByYWlzZS5pZCA9IG9wdGlvbnM/LmlkO1xuICByYWlzZS5kZWxheSA9IG9wdGlvbnM/LmRlbGF5O1xuICByYWlzZS5yZXNvbHZlID0gcmVzb2x2ZVJhaXNlO1xuICByYWlzZS5leGVjdXRlID0gZXhlY3V0ZVJhaXNlO1xuICByZXR1cm4gcmFpc2U7XG59XG5cbmV4cG9ydCB7ICQkQUNUT1JfVFlQRSBhcyAkLCBjcmVhdGVBY3RvciBhcyBBLCBBY3RvciBhcyBCLCBpbnRlcnByZXQgYXMgQywgYW5kIGFzIEQsIG5vdCBhcyBFLCBvciBhcyBGLCBzdGF0ZUluIGFzIEcsIGlzTWFjaGluZVNuYXBzaG90IGFzIEgsIGdldEFsbE93bkV2ZW50RGVzY3JpcHRvcnMgYXMgSSwgbWF0Y2hlc1N0YXRlIGFzIEosIHBhdGhUb1N0YXRlVmFsdWUgYXMgSywgdG9PYnNlcnZlciBhcyBMLCBjYW5jZWwgYXMgTSwgTlVMTF9FVkVOVCBhcyBOLCByYWlzZSBhcyBPLCBzcGF3bkNoaWxkIGFzIFAsIHN0b3AgYXMgUSwgc3RvcENoaWxkIGFzIFIsIFNUQVRFX0RFTElNSVRFUiBhcyBTLCBQcm9jZXNzaW5nU3RhdHVzIGFzIFQsIGNsb25lTWFjaGluZVNuYXBzaG90IGFzIFUsIGV4ZWN1dGluZ0N1c3RvbUFjdGlvbiBhcyBWLCBYU1RBVEVfRVJST1IgYXMgVywgWFNUQVRFX1NUT1AgYXMgWCwgY3JlYXRlRXJyb3JBY3RvckV2ZW50IGFzIFksIHRvVHJhbnNpdGlvbkNvbmZpZ0FycmF5IGFzIGEsIGZvcm1hdFRyYW5zaXRpb24gYXMgYiwgY3JlYXRlSW52b2tlSWQgYXMgYywgZm9ybWF0SW5pdGlhbFRyYW5zaXRpb24gYXMgZCwgZXZhbHVhdGVHdWFyZCBhcyBlLCBmb3JtYXRUcmFuc2l0aW9ucyBhcyBmLCBnZXREZWxheWVkVHJhbnNpdGlvbnMgYXMgZywgZ2V0Q2FuZGlkYXRlcyBhcyBoLCBnZXRBbGxTdGF0ZU5vZGVzIGFzIGksIGdldFN0YXRlTm9kZXMgYXMgaiwgY3JlYXRlTWFjaGluZVNuYXBzaG90IGFzIGssIGlzSW5GaW5hbFN0YXRlIGFzIGwsIG1hcFZhbHVlcyBhcyBtLCBtYWNyb3N0ZXAgYXMgbiwgdHJhbnNpdGlvbk5vZGUgYXMgbywgcmVzb2x2ZUFjdGlvbnNBbmRDb250ZXh0IGFzIHAsIGNyZWF0ZUluaXRFdmVudCBhcyBxLCByZXNvbHZlU3RhdGVWYWx1ZSBhcyByLCBtaWNyb3N0ZXAgYXMgcywgdG9BcnJheSBhcyB0LCBnZXRJbml0aWFsU3RhdGVOb2RlcyBhcyB1LCB0b1N0YXRlUGF0aCBhcyB2LCBpc1N0YXRlSWQgYXMgdywgZ2V0U3RhdGVOb2RlQnlQYXRoIGFzIHgsIGdldFBlcnNpc3RlZFNuYXBzaG90IGFzIHksIHJlc29sdmVSZWZlcmVuY2VkQWN0b3IgYXMgeiB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/xstate/dist/raise-5ea71f04.development.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/xstate/dist/xstate.development.esm.js":
/*!************************************************************!*\
  !*** ./node_modules/xstate/dist/xstate.development.esm.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Actor: function() { return /* reexport safe */ _raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.B; },\n/* harmony export */   SimulatedClock: function() { return /* binding */ SimulatedClock; },\n/* harmony export */   SpecialTargets: function() { return /* reexport safe */ _log_38475d87_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.S; },\n/* harmony export */   StateMachine: function() { return /* binding */ StateMachine; },\n/* harmony export */   StateNode: function() { return /* binding */ StateNode; },\n/* harmony export */   __unsafe_getAllOwnEventDescriptors: function() { return /* reexport safe */ _raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.I; },\n/* harmony export */   and: function() { return /* reexport safe */ _raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.D; },\n/* harmony export */   assertEvent: function() { return /* binding */ assertEvent; },\n/* harmony export */   assign: function() { return /* reexport safe */ _log_38475d87_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.a; },\n/* harmony export */   cancel: function() { return /* reexport safe */ _raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.M; },\n/* harmony export */   createActor: function() { return /* reexport safe */ _raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.A; },\n/* harmony export */   createEmptyActor: function() { return /* reexport safe */ _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.createEmptyActor; },\n/* harmony export */   createMachine: function() { return /* binding */ createMachine; },\n/* harmony export */   emit: function() { return /* reexport safe */ _log_38475d87_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.e; },\n/* harmony export */   enqueueActions: function() { return /* reexport safe */ _log_38475d87_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.b; },\n/* harmony export */   forwardTo: function() { return /* reexport safe */ _log_38475d87_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.f; },\n/* harmony export */   fromCallback: function() { return /* reexport safe */ _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.fromCallback; },\n/* harmony export */   fromEventObservable: function() { return /* reexport safe */ _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.fromEventObservable; },\n/* harmony export */   fromObservable: function() { return /* reexport safe */ _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.fromObservable; },\n/* harmony export */   fromPromise: function() { return /* reexport safe */ _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.fromPromise; },\n/* harmony export */   fromTransition: function() { return /* reexport safe */ _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.fromTransition; },\n/* harmony export */   getInitialSnapshot: function() { return /* binding */ getInitialSnapshot; },\n/* harmony export */   getNextSnapshot: function() { return /* binding */ getNextSnapshot; },\n/* harmony export */   getStateNodes: function() { return /* reexport safe */ _raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.j; },\n/* harmony export */   interpret: function() { return /* reexport safe */ _raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.C; },\n/* harmony export */   isMachineSnapshot: function() { return /* reexport safe */ _raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.H; },\n/* harmony export */   log: function() { return /* reexport safe */ _log_38475d87_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.l; },\n/* harmony export */   matchesState: function() { return /* reexport safe */ _raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.J; },\n/* harmony export */   not: function() { return /* reexport safe */ _raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.E; },\n/* harmony export */   or: function() { return /* reexport safe */ _raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.F; },\n/* harmony export */   pathToStateValue: function() { return /* reexport safe */ _raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.K; },\n/* harmony export */   raise: function() { return /* reexport safe */ _raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.O; },\n/* harmony export */   sendParent: function() { return /* reexport safe */ _log_38475d87_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.s; },\n/* harmony export */   sendTo: function() { return /* reexport safe */ _log_38475d87_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.c; },\n/* harmony export */   setup: function() { return /* binding */ setup; },\n/* harmony export */   spawnChild: function() { return /* reexport safe */ _raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.P; },\n/* harmony export */   stateIn: function() { return /* reexport safe */ _raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.G; },\n/* harmony export */   stop: function() { return /* reexport safe */ _raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.Q; },\n/* harmony export */   stopChild: function() { return /* reexport safe */ _raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.R; },\n/* harmony export */   toObserver: function() { return /* reexport safe */ _raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.L; },\n/* harmony export */   toPromise: function() { return /* binding */ toPromise; },\n/* harmony export */   waitFor: function() { return /* binding */ waitFor; }\n/* harmony export */ });\n/* harmony import */ var _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../actors/dist/xstate-actors.development.esm.js */ \"(app-pages-browser)/./node_modules/xstate/actors/dist/xstate-actors.development.esm.js\");\n/* harmony import */ var _raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./raise-5ea71f04.development.esm.js */ \"(app-pages-browser)/./node_modules/xstate/dist/raise-5ea71f04.development.esm.js\");\n/* harmony import */ var _log_38475d87_development_esm_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./log-38475d87.development.esm.js */ \"(app-pages-browser)/./node_modules/xstate/dist/log-38475d87.development.esm.js\");\n/* harmony import */ var _dev_dist_xstate_dev_development_esm_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dev/dist/xstate-dev.development.esm.js */ \"(app-pages-browser)/./node_modules/xstate/dev/dist/xstate-dev.development.esm.js\");\n\n\n\n\n\n\n\n/**\n * Asserts that the given event object is of the specified type or types. Throws\n * an error if the event object is not of the specified types.\n *\n * @example\n *\n * ```ts\n * // ...\n * entry: ({ event }) => {\n *   assertEvent(event, 'doNothing');\n *   // event is { type: 'doNothing' }\n * },\n * // ...\n * exit: ({ event }) => {\n *   assertEvent(event, 'greet');\n *   // event is { type: 'greet'; message: string }\n *\n *   assertEvent(event, ['greet', 'notify']);\n *   // event is { type: 'greet'; message: string }\n *   // or { type: 'notify'; message: string; level: 'info' | 'error' }\n * },\n * ```\n */\nfunction assertEvent(event, type) {\n  const types = (0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.t)(type);\n  if (!types.includes(event.type)) {\n    const typesText = types.length === 1 ? `type \"${types[0]}\"` : `one of types \"${types.join('\", \"')}\"`;\n    throw new Error(`Expected event ${JSON.stringify(event)} to have ${typesText}`);\n  }\n}\n\nconst cache = new WeakMap();\nfunction memo(object, key, fn) {\n  let memoizedData = cache.get(object);\n  if (!memoizedData) {\n    memoizedData = {\n      [key]: fn()\n    };\n    cache.set(object, memoizedData);\n  } else if (!(key in memoizedData)) {\n    memoizedData[key] = fn();\n  }\n  return memoizedData[key];\n}\n\nconst EMPTY_OBJECT = {};\nconst toSerializableAction = action => {\n  if (typeof action === 'string') {\n    return {\n      type: action\n    };\n  }\n  if (typeof action === 'function') {\n    if ('resolve' in action) {\n      return {\n        type: action.type\n      };\n    }\n    return {\n      type: action.name\n    };\n  }\n  return action;\n};\nclass StateNode {\n  constructor(/** The raw config used to create the machine. */\n  config, options) {\n    this.config = config;\n    /**\n     * The relative key of the state node, which represents its location in the\n     * overall state value.\n     */\n    this.key = void 0;\n    /** The unique ID of the state node. */\n    this.id = void 0;\n    /**\n     * The type of this state node:\n     *\n     * - `'atomic'` - no child state nodes\n     * - `'compound'` - nested child state nodes (XOR)\n     * - `'parallel'` - orthogonal nested child state nodes (AND)\n     * - `'history'` - history state node\n     * - `'final'` - final state node\n     */\n    this.type = void 0;\n    /** The string path from the root machine node to this node. */\n    this.path = void 0;\n    /** The child state nodes. */\n    this.states = void 0;\n    /**\n     * The type of history on this state node. Can be:\n     *\n     * - `'shallow'` - recalls only top-level historical state value\n     * - `'deep'` - recalls historical state value at all levels\n     */\n    this.history = void 0;\n    /** The action(s) to be executed upon entering the state node. */\n    this.entry = void 0;\n    /** The action(s) to be executed upon exiting the state node. */\n    this.exit = void 0;\n    /** The parent state node. */\n    this.parent = void 0;\n    /** The root machine node. */\n    this.machine = void 0;\n    /**\n     * The meta data associated with this state node, which will be returned in\n     * State instances.\n     */\n    this.meta = void 0;\n    /**\n     * The output data sent with the \"xstate.done.state._id_\" event if this is a\n     * final state node.\n     */\n    this.output = void 0;\n    /**\n     * The order this state node appears. Corresponds to the implicit document\n     * order.\n     */\n    this.order = -1;\n    this.description = void 0;\n    this.tags = [];\n    this.transitions = void 0;\n    this.always = void 0;\n    this.parent = options._parent;\n    this.key = options._key;\n    this.machine = options._machine;\n    this.path = this.parent ? this.parent.path.concat(this.key) : [];\n    this.id = this.config.id || [this.machine.id, ...this.path].join(_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.S);\n    this.type = this.config.type || (this.config.states && Object.keys(this.config.states).length ? 'compound' : this.config.history ? 'history' : 'atomic');\n    this.description = this.config.description;\n    this.order = this.machine.idMap.size;\n    this.machine.idMap.set(this.id, this);\n    this.states = this.config.states ? (0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.m)(this.config.states, (stateConfig, key) => {\n      const stateNode = new StateNode(stateConfig, {\n        _parent: this,\n        _key: key,\n        _machine: this.machine\n      });\n      return stateNode;\n    }) : EMPTY_OBJECT;\n    if (this.type === 'compound' && !this.config.initial) {\n      throw new Error(`No initial state specified for compound state node \"#${this.id}\". Try adding { initial: \"${Object.keys(this.states)[0]}\" } to the state config.`);\n    }\n\n    // History config\n    this.history = this.config.history === true ? 'shallow' : this.config.history || false;\n    this.entry = (0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.t)(this.config.entry).slice();\n    this.exit = (0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.t)(this.config.exit).slice();\n    this.meta = this.config.meta;\n    this.output = this.type === 'final' || !this.parent ? this.config.output : undefined;\n    this.tags = (0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.t)(config.tags).slice();\n  }\n\n  /** @internal */\n  _initialize() {\n    this.transitions = (0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.f)(this);\n    if (this.config.always) {\n      this.always = (0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)(this.config.always).map(t => (0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.b)(this, _raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.N, t));\n    }\n    Object.keys(this.states).forEach(key => {\n      this.states[key]._initialize();\n    });\n  }\n\n  /** The well-structured state node definition. */\n  get definition() {\n    return {\n      id: this.id,\n      key: this.key,\n      version: this.machine.version,\n      type: this.type,\n      initial: this.initial ? {\n        target: this.initial.target,\n        source: this,\n        actions: this.initial.actions.map(toSerializableAction),\n        eventType: null,\n        reenter: false,\n        toJSON: () => ({\n          target: this.initial.target.map(t => `#${t.id}`),\n          source: `#${this.id}`,\n          actions: this.initial.actions.map(toSerializableAction),\n          eventType: null\n        })\n      } : undefined,\n      history: this.history,\n      states: (0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.m)(this.states, state => {\n        return state.definition;\n      }),\n      on: this.on,\n      transitions: [...this.transitions.values()].flat().map(t => ({\n        ...t,\n        actions: t.actions.map(toSerializableAction)\n      })),\n      entry: this.entry.map(toSerializableAction),\n      exit: this.exit.map(toSerializableAction),\n      meta: this.meta,\n      order: this.order || -1,\n      output: this.output,\n      invoke: this.invoke,\n      description: this.description,\n      tags: this.tags\n    };\n  }\n\n  /** @internal */\n  toJSON() {\n    return this.definition;\n  }\n\n  /** The logic invoked as actors by this state node. */\n  get invoke() {\n    return memo(this, 'invoke', () => (0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.t)(this.config.invoke).map((invokeConfig, i) => {\n      const {\n        src,\n        systemId\n      } = invokeConfig;\n      const resolvedId = invokeConfig.id ?? (0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.c)(this.id, i);\n      const resolvedSrc = typeof src === 'string' ? src : `xstate.invoke.${(0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.c)(this.id, i)}`;\n      return {\n        ...invokeConfig,\n        src: resolvedSrc,\n        id: resolvedId,\n        systemId: systemId,\n        toJSON() {\n          const {\n            onDone,\n            onError,\n            ...invokeDefValues\n          } = invokeConfig;\n          return {\n            ...invokeDefValues,\n            type: 'xstate.invoke',\n            src: resolvedSrc,\n            id: resolvedId\n          };\n        }\n      };\n    }));\n  }\n\n  /** The mapping of events to transitions. */\n  get on() {\n    return memo(this, 'on', () => {\n      const transitions = this.transitions;\n      return [...transitions].flatMap(([descriptor, t]) => t.map(t => [descriptor, t])).reduce((map, [descriptor, transition]) => {\n        map[descriptor] = map[descriptor] || [];\n        map[descriptor].push(transition);\n        return map;\n      }, {});\n    });\n  }\n  get after() {\n    return memo(this, 'delayedTransitions', () => (0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.g)(this));\n  }\n  get initial() {\n    return memo(this, 'initial', () => (0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.d)(this, this.config.initial));\n  }\n\n  /** @internal */\n  next(snapshot, event) {\n    const eventType = event.type;\n    const actions = [];\n    let selectedTransition;\n    const candidates = memo(this, `candidates-${eventType}`, () => (0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.h)(this, eventType));\n    for (const candidate of candidates) {\n      const {\n        guard\n      } = candidate;\n      const resolvedContext = snapshot.context;\n      let guardPassed = false;\n      try {\n        guardPassed = !guard || (0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.e)(guard, resolvedContext, event, snapshot);\n      } catch (err) {\n        const guardType = typeof guard === 'string' ? guard : typeof guard === 'object' ? guard.type : undefined;\n        throw new Error(`Unable to evaluate guard ${guardType ? `'${guardType}' ` : ''}in transition for event '${eventType}' in state node '${this.id}':\\n${err.message}`);\n      }\n      if (guardPassed) {\n        actions.push(...candidate.actions);\n        selectedTransition = candidate;\n        break;\n      }\n    }\n    return selectedTransition ? [selectedTransition] : undefined;\n  }\n\n  /** All the event types accepted by this state node and its descendants. */\n  get events() {\n    return memo(this, 'events', () => {\n      const {\n        states\n      } = this;\n      const events = new Set(this.ownEvents);\n      if (states) {\n        for (const stateId of Object.keys(states)) {\n          const state = states[stateId];\n          if (state.states) {\n            for (const event of state.events) {\n              events.add(`${event}`);\n            }\n          }\n        }\n      }\n      return Array.from(events);\n    });\n  }\n\n  /**\n   * All the events that have transitions directly from this state node.\n   *\n   * Excludes any inert events.\n   */\n  get ownEvents() {\n    const events = new Set([...this.transitions.keys()].filter(descriptor => {\n      return this.transitions.get(descriptor).some(transition => !(!transition.target && !transition.actions.length && !transition.reenter));\n    }));\n    return Array.from(events);\n  }\n}\n\nconst STATE_IDENTIFIER = '#';\nclass StateMachine {\n  constructor(/** The raw config used to create the machine. */\n  config, implementations) {\n    this.config = config;\n    /** The machine's own version. */\n    this.version = void 0;\n    this.schemas = void 0;\n    this.implementations = void 0;\n    /** @internal */\n    this.__xstatenode = true;\n    /** @internal */\n    this.idMap = new Map();\n    this.root = void 0;\n    this.id = void 0;\n    this.states = void 0;\n    this.events = void 0;\n    this.id = config.id || '(machine)';\n    this.implementations = {\n      actors: implementations?.actors ?? {},\n      actions: implementations?.actions ?? {},\n      delays: implementations?.delays ?? {},\n      guards: implementations?.guards ?? {}\n    };\n    this.version = this.config.version;\n    this.schemas = this.config.schemas;\n    this.transition = this.transition.bind(this);\n    this.getInitialSnapshot = this.getInitialSnapshot.bind(this);\n    this.getPersistedSnapshot = this.getPersistedSnapshot.bind(this);\n    this.restoreSnapshot = this.restoreSnapshot.bind(this);\n    this.start = this.start.bind(this);\n    this.root = new StateNode(config, {\n      _key: this.id,\n      _machine: this\n    });\n    this.root._initialize();\n    this.states = this.root.states; // TODO: remove!\n    this.events = this.root.events;\n    if (!('output' in this.root) && Object.values(this.states).some(state => state.type === 'final' && 'output' in state)) {\n      console.warn('Missing `machine.output` declaration (top-level final state with output detected)');\n    }\n  }\n\n  /**\n   * Clones this state machine with the provided implementations and merges the\n   * `context` (if provided).\n   *\n   * @param implementations Options (`actions`, `guards`, `actors`, `delays`,\n   *   `context`) to recursively merge with the existing options.\n   * @returns A new `StateMachine` instance with the provided implementations.\n   */\n  provide(implementations) {\n    const {\n      actions,\n      guards,\n      actors,\n      delays\n    } = this.implementations;\n    return new StateMachine(this.config, {\n      actions: {\n        ...actions,\n        ...implementations.actions\n      },\n      guards: {\n        ...guards,\n        ...implementations.guards\n      },\n      actors: {\n        ...actors,\n        ...implementations.actors\n      },\n      delays: {\n        ...delays,\n        ...implementations.delays\n      }\n    });\n  }\n  resolveState(config) {\n    const resolvedStateValue = (0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.r)(this.root, config.value);\n    const nodeSet = (0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.i)((0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.j)(this.root, resolvedStateValue));\n    return (0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.k)({\n      _nodes: [...nodeSet],\n      context: config.context || {},\n      children: {},\n      status: (0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.l)(nodeSet, this.root) ? 'done' : config.status || 'active',\n      output: config.output,\n      error: config.error,\n      historyValue: config.historyValue\n    }, this);\n  }\n\n  /**\n   * Determines the next snapshot given the current `snapshot` and received\n   * `event`. Calculates a full macrostep from all microsteps.\n   *\n   * @param snapshot The current snapshot\n   * @param event The received event\n   */\n  transition(snapshot, event, actorScope) {\n    return (0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.n)(snapshot, event, actorScope).snapshot;\n  }\n\n  /**\n   * Determines the next state given the current `state` and `event`. Calculates\n   * a microstep.\n   *\n   * @param state The current state\n   * @param event The received event\n   */\n  microstep(snapshot, event, actorScope) {\n    return (0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.n)(snapshot, event, actorScope).microstates;\n  }\n  getTransitionData(snapshot, event) {\n    return (0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.o)(this.root, snapshot.value, snapshot, event) || [];\n  }\n\n  /**\n   * The initial state _before_ evaluating any microsteps. This \"pre-initial\"\n   * state is provided to initial actions executed in the initial state.\n   */\n  getPreInitialState(actorScope, initEvent, internalQueue) {\n    const {\n      context\n    } = this.config;\n    const preInitial = (0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.k)({\n      context: typeof context !== 'function' && context ? context : {},\n      _nodes: [this.root],\n      children: {},\n      status: 'active'\n    }, this);\n    if (typeof context === 'function') {\n      const assignment = ({\n        spawn,\n        event,\n        self\n      }) => context({\n        spawn,\n        input: event.input,\n        self\n      });\n      return (0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.p)(preInitial, initEvent, actorScope, [(0,_log_38475d87_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.a)(assignment)], internalQueue);\n    }\n    return preInitial;\n  }\n\n  /**\n   * Returns the initial `State` instance, with reference to `self` as an\n   * `ActorRef`.\n   */\n  getInitialSnapshot(actorScope, input) {\n    const initEvent = (0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.q)(input); // TODO: fix;\n    const internalQueue = [];\n    const preInitialState = this.getPreInitialState(actorScope, initEvent, internalQueue);\n    const nextState = (0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.s)([{\n      target: [...(0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.u)(this.root)],\n      source: this.root,\n      reenter: true,\n      actions: [],\n      eventType: null,\n      toJSON: null // TODO: fix\n    }], preInitialState, actorScope, initEvent, true, internalQueue);\n    const {\n      snapshot: macroState\n    } = (0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.n)(nextState, initEvent, actorScope, internalQueue);\n    return macroState;\n  }\n  start(snapshot) {\n    Object.values(snapshot.children).forEach(child => {\n      if (child.getSnapshot().status === 'active') {\n        child.start();\n      }\n    });\n  }\n  getStateNodeById(stateId) {\n    const fullPath = (0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.v)(stateId);\n    const relativePath = fullPath.slice(1);\n    const resolvedStateId = (0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.w)(fullPath[0]) ? fullPath[0].slice(STATE_IDENTIFIER.length) : fullPath[0];\n    const stateNode = this.idMap.get(resolvedStateId);\n    if (!stateNode) {\n      throw new Error(`Child state node '#${resolvedStateId}' does not exist on machine '${this.id}'`);\n    }\n    return (0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.x)(stateNode, relativePath);\n  }\n  get definition() {\n    return this.root.definition;\n  }\n  toJSON() {\n    return this.definition;\n  }\n  getPersistedSnapshot(snapshot, options) {\n    return (0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.y)(snapshot, options);\n  }\n  restoreSnapshot(snapshot, _actorScope) {\n    const children = {};\n    const snapshotChildren = snapshot.children;\n    Object.keys(snapshotChildren).forEach(actorId => {\n      const actorData = snapshotChildren[actorId];\n      const childState = actorData.snapshot;\n      const src = actorData.src;\n      const logic = typeof src === 'string' ? (0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.z)(this, src) : src;\n      if (!logic) {\n        return;\n      }\n      const actorRef = (0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.A)(logic, {\n        id: actorId,\n        parent: _actorScope.self,\n        syncSnapshot: actorData.syncSnapshot,\n        snapshot: childState,\n        src,\n        systemId: actorData.systemId\n      });\n      children[actorId] = actorRef;\n    });\n    const restoredSnapshot = (0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.k)({\n      ...snapshot,\n      children,\n      _nodes: Array.from((0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.i)((0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.j)(this.root, snapshot.value)))\n    }, this);\n    let seen = new Set();\n    function reviveContext(contextPart, children) {\n      if (seen.has(contextPart)) {\n        return;\n      }\n      seen.add(contextPart);\n      for (let key in contextPart) {\n        const value = contextPart[key];\n        if (value && typeof value === 'object') {\n          if ('xstate$$type' in value && value.xstate$$type === _raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.$) {\n            contextPart[key] = children[value.id];\n            continue;\n          }\n          reviveContext(value, children);\n        }\n      }\n    }\n    reviveContext(restoredSnapshot.context, children);\n    return restoredSnapshot;\n  }\n}\n\n// this is not 100% accurate since we can't make parallel regions required in the result\n// `TTestValue` doesn't encode this information anyhow for us to be able to do that\n// this is fine for most practical use cases anyway though\n\n/**\n * Creates a state machine (statechart) with the given configuration.\n *\n * The state machine represents the pure logic of a state machine actor.\n *\n * @example\n *\n * ```ts\n * import { createMachine } from 'xstate';\n *\n * const lightMachine = createMachine({\n *   id: 'light',\n *   initial: 'green',\n *   states: {\n *     green: {\n *       on: {\n *         TIMER: { target: 'yellow' }\n *       }\n *     },\n *     yellow: {\n *       on: {\n *         TIMER: { target: 'red' }\n *       }\n *     },\n *     red: {\n *       on: {\n *         TIMER: { target: 'green' }\n *       }\n *     }\n *   }\n * });\n *\n * const lightActor = createActor(lightMachine);\n * lightActor.start();\n *\n * lightActor.send({ type: 'TIMER' });\n * ```\n *\n * @param config The state machine configuration.\n * @param options DEPRECATED: use `setup({ ... })` or `machine.provide({ ... })`\n *   to provide machine implementations instead.\n */\nfunction createMachine(config, implementations) {\n  return new StateMachine(config, implementations);\n}\n\n/** @internal */\nfunction createInertActorScope(actorLogic) {\n  const self = (0,_raise_5ea71f04_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.A)(actorLogic);\n  const inertActorScope = {\n    self,\n    defer: () => {},\n    id: '',\n    logger: () => {},\n    sessionId: '',\n    stopChild: () => {},\n    system: self.system,\n    emit: () => {}\n  };\n  return inertActorScope;\n}\nfunction getInitialSnapshot(actorLogic, ...[input]) {\n  const actorScope = createInertActorScope(actorLogic);\n  return actorLogic.getInitialSnapshot(actorScope, input);\n}\n\n/**\n * Determines the next snapshot for the given `actorLogic` based on the given\n * `snapshot` and `event`.\n *\n * If the `snapshot` is `undefined`, the initial snapshot of the `actorLogic` is\n * used.\n *\n * @example\n *\n * ```ts\n * import { getNextSnapshot } from 'xstate';\n * import { trafficLightMachine } from './trafficLightMachine.ts';\n *\n * const nextSnapshot = getNextSnapshot(\n *   trafficLightMachine, // actor logic\n *   undefined, // snapshot (or initial state if undefined)\n *   { type: 'TIMER' }\n * ); // event object\n *\n * console.log(nextSnapshot.value);\n * // => 'yellow'\n *\n * const nextSnapshot2 = getNextSnapshot(\n *   trafficLightMachine, // actor logic\n *   nextSnapshot, // snapshot\n *   { type: 'TIMER' }\n * ); // event object\n *\n * console.log(nextSnapshot2.value);\n * // =>'red'\n * ```\n */\nfunction getNextSnapshot(actorLogic, snapshot, event) {\n  const inertActorScope = createInertActorScope(actorLogic);\n  inertActorScope.self._snapshot = snapshot;\n  return actorLogic.transition(snapshot, event, inertActorScope);\n}\n\n// at the moment we allow extra actors - ones that are not specified by `children`\n// this could be reconsidered in the future\n\nfunction setup({\n  schemas,\n  actors,\n  actions,\n  guards,\n  delays\n}) {\n  return {\n    createMachine: config => createMachine({\n      ...config,\n      schemas\n    }, {\n      actors,\n      actions,\n      guards,\n      delays\n    })\n  };\n}\n\nclass SimulatedClock {\n  constructor() {\n    this.timeouts = new Map();\n    this._now = 0;\n    this._id = 0;\n    this._flushing = false;\n    this._flushingInvalidated = false;\n  }\n  now() {\n    return this._now;\n  }\n  getId() {\n    return this._id++;\n  }\n  setTimeout(fn, timeout) {\n    this._flushingInvalidated = this._flushing;\n    const id = this.getId();\n    this.timeouts.set(id, {\n      start: this.now(),\n      timeout,\n      fn\n    });\n    return id;\n  }\n  clearTimeout(id) {\n    this._flushingInvalidated = this._flushing;\n    this.timeouts.delete(id);\n  }\n  set(time) {\n    if (this._now > time) {\n      throw new Error('Unable to travel back in time');\n    }\n    this._now = time;\n    this.flushTimeouts();\n  }\n  flushTimeouts() {\n    if (this._flushing) {\n      this._flushingInvalidated = true;\n      return;\n    }\n    this._flushing = true;\n    const sorted = [...this.timeouts].sort(([_idA, timeoutA], [_idB, timeoutB]) => {\n      const endA = timeoutA.start + timeoutA.timeout;\n      const endB = timeoutB.start + timeoutB.timeout;\n      return endB > endA ? -1 : 1;\n    });\n    for (const [id, timeout] of sorted) {\n      if (this._flushingInvalidated) {\n        this._flushingInvalidated = false;\n        this._flushing = false;\n        this.flushTimeouts();\n        return;\n      }\n      if (this.now() - timeout.start >= timeout.timeout) {\n        this.timeouts.delete(id);\n        timeout.fn.call(null);\n      }\n    }\n    this._flushing = false;\n  }\n  increment(ms) {\n    this._now += ms;\n    this.flushTimeouts();\n  }\n}\n\n/**\n * Returns a promise that resolves to the `output` of the actor when it is done.\n *\n * @example\n *\n * ```ts\n * const machine = createMachine({\n *   // ...\n *   output: {\n *     count: 42\n *   }\n * });\n *\n * const actor = createActor(machine);\n *\n * actor.start();\n *\n * const output = await toPromise(actor);\n *\n * console.log(output);\n * // logs { count: 42 }\n * ```\n */\nfunction toPromise(actor) {\n  return new Promise((resolve, reject) => {\n    actor.subscribe({\n      complete: () => {\n        resolve(actor.getSnapshot().output);\n      },\n      error: reject\n    });\n  });\n}\n\nconst defaultWaitForOptions = {\n  timeout: Infinity // much more than 10 seconds\n};\n\n/**\n * Subscribes to an actor ref and waits for its emitted value to satisfy a\n * predicate, and then resolves with that value. Will throw if the desired state\n * is not reached after an optional timeout. (defaults to Infinity).\n *\n * @example\n *\n * ```js\n * const state = await waitFor(someService, (state) => {\n *   return state.hasTag('loaded');\n * });\n *\n * state.hasTag('loaded'); // true\n * ```\n *\n * @param actorRef The actor ref to subscribe to\n * @param predicate Determines if a value matches the condition to wait for\n * @param options\n * @returns A promise that eventually resolves to the emitted value that matches\n *   the condition\n */\nfunction waitFor(actorRef, predicate, options) {\n  const resolvedOptions = {\n    ...defaultWaitForOptions,\n    ...options\n  };\n  return new Promise((res, rej) => {\n    const {\n      signal\n    } = resolvedOptions;\n    if (signal?.aborted) {\n      rej(signal.reason);\n      return;\n    }\n    let done = false;\n    if (resolvedOptions.timeout < 0) {\n      console.error('`timeout` passed to `waitFor` is negative and it will reject its internal promise immediately.');\n    }\n    const handle = resolvedOptions.timeout === Infinity ? undefined : setTimeout(() => {\n      dispose();\n      rej(new Error(`Timeout of ${resolvedOptions.timeout} ms exceeded`));\n    }, resolvedOptions.timeout);\n    const dispose = () => {\n      clearTimeout(handle);\n      done = true;\n      sub?.unsubscribe();\n      if (abortListener) {\n        signal.removeEventListener('abort', abortListener);\n      }\n    };\n    function checkEmitted(emitted) {\n      if (predicate(emitted)) {\n        dispose();\n        res(emitted);\n      }\n    }\n\n    /**\n     * If the `signal` option is provided, this will be the listener for its\n     * `abort` event\n     */\n    let abortListener;\n    let sub; // avoid TDZ when disposing synchronously\n\n    // See if the current snapshot already matches the predicate\n    checkEmitted(actorRef.getSnapshot());\n    if (done) {\n      return;\n    }\n\n    // only define the `abortListener` if the `signal` option is provided\n    if (signal) {\n      abortListener = () => {\n        dispose();\n        // XState does not \"own\" the signal, so we should reject with its reason (if any)\n        rej(signal.reason);\n      };\n      signal.addEventListener('abort', abortListener);\n    }\n    sub = actorRef.subscribe({\n      next: checkEmitted,\n      error: err => {\n        dispose();\n        rej(err);\n      },\n      complete: () => {\n        dispose();\n        rej(new Error(`Actor terminated without satisfying predicate`));\n      }\n    });\n    if (done) {\n      sub.unsubscribe();\n    }\n  });\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy94c3RhdGUvZGlzdC94c3RhdGUuZGV2ZWxvcG1lbnQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBbUs7QUFDNGlCO0FBQzVXO0FBQ25TO0FBQzZHO0FBQzFIOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsbUJBQW1CO0FBQ25CLElBQUk7QUFDSjtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQyxhQUFhLGdCQUFnQixpQkFBaUI7QUFDOUMsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxRUFBTztBQUN2QjtBQUNBLG9EQUFvRCxTQUFTLHNCQUFzQixtQkFBbUI7QUFDdEcsc0NBQXNDLHVCQUF1QixVQUFVLFVBQVU7QUFDakY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx5QkFBeUI7QUFDM0QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFK0kiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3hzdGF0ZS9kaXN0L3hzdGF0ZS5kZXZlbG9wbWVudC5lc20uanM/NzE2NyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBjcmVhdGVFbXB0eUFjdG9yLCBmcm9tQ2FsbGJhY2ssIGZyb21FdmVudE9ic2VydmFibGUsIGZyb21PYnNlcnZhYmxlLCBmcm9tUHJvbWlzZSwgZnJvbVRyYW5zaXRpb24gfSBmcm9tICcuLi9hY3RvcnMvZGlzdC94c3RhdGUtYWN0b3JzLmRldmVsb3BtZW50LmVzbS5qcyc7XG5pbXBvcnQgeyB0IGFzIHRvQXJyYXksIFMgYXMgU1RBVEVfREVMSU1JVEVSLCBtIGFzIG1hcFZhbHVlcywgZiBhcyBmb3JtYXRUcmFuc2l0aW9ucywgYSBhcyB0b1RyYW5zaXRpb25Db25maWdBcnJheSwgYiBhcyBmb3JtYXRUcmFuc2l0aW9uLCBOIGFzIE5VTExfRVZFTlQsIGUgYXMgZXZhbHVhdGVHdWFyZCwgYyBhcyBjcmVhdGVJbnZva2VJZCwgZyBhcyBnZXREZWxheWVkVHJhbnNpdGlvbnMsIGQgYXMgZm9ybWF0SW5pdGlhbFRyYW5zaXRpb24sIGggYXMgZ2V0Q2FuZGlkYXRlcywgciBhcyByZXNvbHZlU3RhdGVWYWx1ZSwgaSBhcyBnZXRBbGxTdGF0ZU5vZGVzLCBqIGFzIGdldFN0YXRlTm9kZXMsIGsgYXMgY3JlYXRlTWFjaGluZVNuYXBzaG90LCBsIGFzIGlzSW5GaW5hbFN0YXRlLCBuIGFzIG1hY3Jvc3RlcCwgbyBhcyB0cmFuc2l0aW9uTm9kZSwgcCBhcyByZXNvbHZlQWN0aW9uc0FuZENvbnRleHQsIHEgYXMgY3JlYXRlSW5pdEV2ZW50LCBzIGFzIG1pY3Jvc3RlcCwgdSBhcyBnZXRJbml0aWFsU3RhdGVOb2RlcywgdiBhcyB0b1N0YXRlUGF0aCwgdyBhcyBpc1N0YXRlSWQsIHggYXMgZ2V0U3RhdGVOb2RlQnlQYXRoLCB5IGFzIGdldFBlcnNpc3RlZFNuYXBzaG90LCB6IGFzIHJlc29sdmVSZWZlcmVuY2VkQWN0b3IsIEEgYXMgY3JlYXRlQWN0b3IsICQgYXMgJCRBQ1RPUl9UWVBFIH0gZnJvbSAnLi9yYWlzZS01ZWE3MWYwNC5kZXZlbG9wbWVudC5lc20uanMnO1xuZXhwb3J0IHsgQiBhcyBBY3RvciwgSSBhcyBfX3Vuc2FmZV9nZXRBbGxPd25FdmVudERlc2NyaXB0b3JzLCBEIGFzIGFuZCwgTSBhcyBjYW5jZWwsIEEgYXMgY3JlYXRlQWN0b3IsIGogYXMgZ2V0U3RhdGVOb2RlcywgQyBhcyBpbnRlcnByZXQsIEggYXMgaXNNYWNoaW5lU25hcHNob3QsIEogYXMgbWF0Y2hlc1N0YXRlLCBFIGFzIG5vdCwgRiBhcyBvciwgSyBhcyBwYXRoVG9TdGF0ZVZhbHVlLCBPIGFzIHJhaXNlLCBQIGFzIHNwYXduQ2hpbGQsIEcgYXMgc3RhdGVJbiwgUSBhcyBzdG9wLCBSIGFzIHN0b3BDaGlsZCwgTCBhcyB0b09ic2VydmVyIH0gZnJvbSAnLi9yYWlzZS01ZWE3MWYwNC5kZXZlbG9wbWVudC5lc20uanMnO1xuaW1wb3J0IHsgYSBhcyBhc3NpZ24gfSBmcm9tICcuL2xvZy0zODQ3NWQ4Ny5kZXZlbG9wbWVudC5lc20uanMnO1xuZXhwb3J0IHsgUyBhcyBTcGVjaWFsVGFyZ2V0cywgYSBhcyBhc3NpZ24sIGUgYXMgZW1pdCwgYiBhcyBlbnF1ZXVlQWN0aW9ucywgZiBhcyBmb3J3YXJkVG8sIGwgYXMgbG9nLCBzIGFzIHNlbmRQYXJlbnQsIGMgYXMgc2VuZFRvIH0gZnJvbSAnLi9sb2ctMzg0NzVkODcuZGV2ZWxvcG1lbnQuZXNtLmpzJztcbmltcG9ydCAnLi4vZGV2L2Rpc3QveHN0YXRlLWRldi5kZXZlbG9wbWVudC5lc20uanMnO1xuXG4vKipcbiAqIEFzc2VydHMgdGhhdCB0aGUgZ2l2ZW4gZXZlbnQgb2JqZWN0IGlzIG9mIHRoZSBzcGVjaWZpZWQgdHlwZSBvciB0eXBlcy4gVGhyb3dzXG4gKiBhbiBlcnJvciBpZiB0aGUgZXZlbnQgb2JqZWN0IGlzIG5vdCBvZiB0aGUgc3BlY2lmaWVkIHR5cGVzLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIC8vIC4uLlxuICogZW50cnk6ICh7IGV2ZW50IH0pID0+IHtcbiAqICAgYXNzZXJ0RXZlbnQoZXZlbnQsICdkb05vdGhpbmcnKTtcbiAqICAgLy8gZXZlbnQgaXMgeyB0eXBlOiAnZG9Ob3RoaW5nJyB9XG4gKiB9LFxuICogLy8gLi4uXG4gKiBleGl0OiAoeyBldmVudCB9KSA9PiB7XG4gKiAgIGFzc2VydEV2ZW50KGV2ZW50LCAnZ3JlZXQnKTtcbiAqICAgLy8gZXZlbnQgaXMgeyB0eXBlOiAnZ3JlZXQnOyBtZXNzYWdlOiBzdHJpbmcgfVxuICpcbiAqICAgYXNzZXJ0RXZlbnQoZXZlbnQsIFsnZ3JlZXQnLCAnbm90aWZ5J10pO1xuICogICAvLyBldmVudCBpcyB7IHR5cGU6ICdncmVldCc7IG1lc3NhZ2U6IHN0cmluZyB9XG4gKiAgIC8vIG9yIHsgdHlwZTogJ25vdGlmeSc7IG1lc3NhZ2U6IHN0cmluZzsgbGV2ZWw6ICdpbmZvJyB8ICdlcnJvcicgfVxuICogfSxcbiAqIGBgYFxuICovXG5mdW5jdGlvbiBhc3NlcnRFdmVudChldmVudCwgdHlwZSkge1xuICBjb25zdCB0eXBlcyA9IHRvQXJyYXkodHlwZSk7XG4gIGlmICghdHlwZXMuaW5jbHVkZXMoZXZlbnQudHlwZSkpIHtcbiAgICBjb25zdCB0eXBlc1RleHQgPSB0eXBlcy5sZW5ndGggPT09IDEgPyBgdHlwZSBcIiR7dHlwZXNbMF19XCJgIDogYG9uZSBvZiB0eXBlcyBcIiR7dHlwZXMuam9pbignXCIsIFwiJyl9XCJgO1xuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgZXZlbnQgJHtKU09OLnN0cmluZ2lmeShldmVudCl9IHRvIGhhdmUgJHt0eXBlc1RleHR9YCk7XG4gIH1cbn1cblxuY29uc3QgY2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gbWVtbyhvYmplY3QsIGtleSwgZm4pIHtcbiAgbGV0IG1lbW9pemVkRGF0YSA9IGNhY2hlLmdldChvYmplY3QpO1xuICBpZiAoIW1lbW9pemVkRGF0YSkge1xuICAgIG1lbW9pemVkRGF0YSA9IHtcbiAgICAgIFtrZXldOiBmbigpXG4gICAgfTtcbiAgICBjYWNoZS5zZXQob2JqZWN0LCBtZW1vaXplZERhdGEpO1xuICB9IGVsc2UgaWYgKCEoa2V5IGluIG1lbW9pemVkRGF0YSkpIHtcbiAgICBtZW1vaXplZERhdGFba2V5XSA9IGZuKCk7XG4gIH1cbiAgcmV0dXJuIG1lbW9pemVkRGF0YVtrZXldO1xufVxuXG5jb25zdCBFTVBUWV9PQkpFQ1QgPSB7fTtcbmNvbnN0IHRvU2VyaWFsaXphYmxlQWN0aW9uID0gYWN0aW9uID0+IHtcbiAgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IGFjdGlvblxuICAgIH07XG4gIH1cbiAgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoJ3Jlc29sdmUnIGluIGFjdGlvbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogYWN0aW9uLnR5cGVcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBhY3Rpb24ubmFtZVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGFjdGlvbjtcbn07XG5jbGFzcyBTdGF0ZU5vZGUge1xuICBjb25zdHJ1Y3RvcigvKiogVGhlIHJhdyBjb25maWcgdXNlZCB0byBjcmVhdGUgdGhlIG1hY2hpbmUuICovXG4gIGNvbmZpZywgb3B0aW9ucykge1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIC8qKlxuICAgICAqIFRoZSByZWxhdGl2ZSBrZXkgb2YgdGhlIHN0YXRlIG5vZGUsIHdoaWNoIHJlcHJlc2VudHMgaXRzIGxvY2F0aW9uIGluIHRoZVxuICAgICAqIG92ZXJhbGwgc3RhdGUgdmFsdWUuXG4gICAgICovXG4gICAgdGhpcy5rZXkgPSB2b2lkIDA7XG4gICAgLyoqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIHN0YXRlIG5vZGUuICovXG4gICAgdGhpcy5pZCA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGlzIHN0YXRlIG5vZGU6XG4gICAgICpcbiAgICAgKiAtIGAnYXRvbWljJ2AgLSBubyBjaGlsZCBzdGF0ZSBub2Rlc1xuICAgICAqIC0gYCdjb21wb3VuZCdgIC0gbmVzdGVkIGNoaWxkIHN0YXRlIG5vZGVzIChYT1IpXG4gICAgICogLSBgJ3BhcmFsbGVsJ2AgLSBvcnRob2dvbmFsIG5lc3RlZCBjaGlsZCBzdGF0ZSBub2RlcyAoQU5EKVxuICAgICAqIC0gYCdoaXN0b3J5J2AgLSBoaXN0b3J5IHN0YXRlIG5vZGVcbiAgICAgKiAtIGAnZmluYWwnYCAtIGZpbmFsIHN0YXRlIG5vZGVcbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSB2b2lkIDA7XG4gICAgLyoqIFRoZSBzdHJpbmcgcGF0aCBmcm9tIHRoZSByb290IG1hY2hpbmUgbm9kZSB0byB0aGlzIG5vZGUuICovXG4gICAgdGhpcy5wYXRoID0gdm9pZCAwO1xuICAgIC8qKiBUaGUgY2hpbGQgc3RhdGUgbm9kZXMuICovXG4gICAgdGhpcy5zdGF0ZXMgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgaGlzdG9yeSBvbiB0aGlzIHN0YXRlIG5vZGUuIENhbiBiZTpcbiAgICAgKlxuICAgICAqIC0gYCdzaGFsbG93J2AgLSByZWNhbGxzIG9ubHkgdG9wLWxldmVsIGhpc3RvcmljYWwgc3RhdGUgdmFsdWVcbiAgICAgKiAtIGAnZGVlcCdgIC0gcmVjYWxscyBoaXN0b3JpY2FsIHN0YXRlIHZhbHVlIGF0IGFsbCBsZXZlbHNcbiAgICAgKi9cbiAgICB0aGlzLmhpc3RvcnkgPSB2b2lkIDA7XG4gICAgLyoqIFRoZSBhY3Rpb24ocykgdG8gYmUgZXhlY3V0ZWQgdXBvbiBlbnRlcmluZyB0aGUgc3RhdGUgbm9kZS4gKi9cbiAgICB0aGlzLmVudHJ5ID0gdm9pZCAwO1xuICAgIC8qKiBUaGUgYWN0aW9uKHMpIHRvIGJlIGV4ZWN1dGVkIHVwb24gZXhpdGluZyB0aGUgc3RhdGUgbm9kZS4gKi9cbiAgICB0aGlzLmV4aXQgPSB2b2lkIDA7XG4gICAgLyoqIFRoZSBwYXJlbnQgc3RhdGUgbm9kZS4gKi9cbiAgICB0aGlzLnBhcmVudCA9IHZvaWQgMDtcbiAgICAvKiogVGhlIHJvb3QgbWFjaGluZSBub2RlLiAqL1xuICAgIHRoaXMubWFjaGluZSA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBUaGUgbWV0YSBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHN0YXRlIG5vZGUsIHdoaWNoIHdpbGwgYmUgcmV0dXJuZWQgaW5cbiAgICAgKiBTdGF0ZSBpbnN0YW5jZXMuXG4gICAgICovXG4gICAgdGhpcy5tZXRhID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIFRoZSBvdXRwdXQgZGF0YSBzZW50IHdpdGggdGhlIFwieHN0YXRlLmRvbmUuc3RhdGUuX2lkX1wiIGV2ZW50IGlmIHRoaXMgaXMgYVxuICAgICAqIGZpbmFsIHN0YXRlIG5vZGUuXG4gICAgICovXG4gICAgdGhpcy5vdXRwdXQgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogVGhlIG9yZGVyIHRoaXMgc3RhdGUgbm9kZSBhcHBlYXJzLiBDb3JyZXNwb25kcyB0byB0aGUgaW1wbGljaXQgZG9jdW1lbnRcbiAgICAgKiBvcmRlci5cbiAgICAgKi9cbiAgICB0aGlzLm9yZGVyID0gLTE7XG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IHZvaWQgMDtcbiAgICB0aGlzLnRhZ3MgPSBbXTtcbiAgICB0aGlzLnRyYW5zaXRpb25zID0gdm9pZCAwO1xuICAgIHRoaXMuYWx3YXlzID0gdm9pZCAwO1xuICAgIHRoaXMucGFyZW50ID0gb3B0aW9ucy5fcGFyZW50O1xuICAgIHRoaXMua2V5ID0gb3B0aW9ucy5fa2V5O1xuICAgIHRoaXMubWFjaGluZSA9IG9wdGlvbnMuX21hY2hpbmU7XG4gICAgdGhpcy5wYXRoID0gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5wYXRoLmNvbmNhdCh0aGlzLmtleSkgOiBbXTtcbiAgICB0aGlzLmlkID0gdGhpcy5jb25maWcuaWQgfHwgW3RoaXMubWFjaGluZS5pZCwgLi4udGhpcy5wYXRoXS5qb2luKFNUQVRFX0RFTElNSVRFUik7XG4gICAgdGhpcy50eXBlID0gdGhpcy5jb25maWcudHlwZSB8fCAodGhpcy5jb25maWcuc3RhdGVzICYmIE9iamVjdC5rZXlzKHRoaXMuY29uZmlnLnN0YXRlcykubGVuZ3RoID8gJ2NvbXBvdW5kJyA6IHRoaXMuY29uZmlnLmhpc3RvcnkgPyAnaGlzdG9yeScgOiAnYXRvbWljJyk7XG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IHRoaXMuY29uZmlnLmRlc2NyaXB0aW9uO1xuICAgIHRoaXMub3JkZXIgPSB0aGlzLm1hY2hpbmUuaWRNYXAuc2l6ZTtcbiAgICB0aGlzLm1hY2hpbmUuaWRNYXAuc2V0KHRoaXMuaWQsIHRoaXMpO1xuICAgIHRoaXMuc3RhdGVzID0gdGhpcy5jb25maWcuc3RhdGVzID8gbWFwVmFsdWVzKHRoaXMuY29uZmlnLnN0YXRlcywgKHN0YXRlQ29uZmlnLCBrZXkpID0+IHtcbiAgICAgIGNvbnN0IHN0YXRlTm9kZSA9IG5ldyBTdGF0ZU5vZGUoc3RhdGVDb25maWcsIHtcbiAgICAgICAgX3BhcmVudDogdGhpcyxcbiAgICAgICAgX2tleToga2V5LFxuICAgICAgICBfbWFjaGluZTogdGhpcy5tYWNoaW5lXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzdGF0ZU5vZGU7XG4gICAgfSkgOiBFTVBUWV9PQkpFQ1Q7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gJ2NvbXBvdW5kJyAmJiAhdGhpcy5jb25maWcuaW5pdGlhbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBpbml0aWFsIHN0YXRlIHNwZWNpZmllZCBmb3IgY29tcG91bmQgc3RhdGUgbm9kZSBcIiMke3RoaXMuaWR9XCIuIFRyeSBhZGRpbmcgeyBpbml0aWFsOiBcIiR7T2JqZWN0LmtleXModGhpcy5zdGF0ZXMpWzBdfVwiIH0gdG8gdGhlIHN0YXRlIGNvbmZpZy5gKTtcbiAgICB9XG5cbiAgICAvLyBIaXN0b3J5IGNvbmZpZ1xuICAgIHRoaXMuaGlzdG9yeSA9IHRoaXMuY29uZmlnLmhpc3RvcnkgPT09IHRydWUgPyAnc2hhbGxvdycgOiB0aGlzLmNvbmZpZy5oaXN0b3J5IHx8IGZhbHNlO1xuICAgIHRoaXMuZW50cnkgPSB0b0FycmF5KHRoaXMuY29uZmlnLmVudHJ5KS5zbGljZSgpO1xuICAgIHRoaXMuZXhpdCA9IHRvQXJyYXkodGhpcy5jb25maWcuZXhpdCkuc2xpY2UoKTtcbiAgICB0aGlzLm1ldGEgPSB0aGlzLmNvbmZpZy5tZXRhO1xuICAgIHRoaXMub3V0cHV0ID0gdGhpcy50eXBlID09PSAnZmluYWwnIHx8ICF0aGlzLnBhcmVudCA/IHRoaXMuY29uZmlnLm91dHB1dCA6IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRhZ3MgPSB0b0FycmF5KGNvbmZpZy50YWdzKS5zbGljZSgpO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLnRyYW5zaXRpb25zID0gZm9ybWF0VHJhbnNpdGlvbnModGhpcyk7XG4gICAgaWYgKHRoaXMuY29uZmlnLmFsd2F5cykge1xuICAgICAgdGhpcy5hbHdheXMgPSB0b1RyYW5zaXRpb25Db25maWdBcnJheSh0aGlzLmNvbmZpZy5hbHdheXMpLm1hcCh0ID0+IGZvcm1hdFRyYW5zaXRpb24odGhpcywgTlVMTF9FVkVOVCwgdCkpO1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyh0aGlzLnN0YXRlcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgdGhpcy5zdGF0ZXNba2V5XS5faW5pdGlhbGl6ZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIFRoZSB3ZWxsLXN0cnVjdHVyZWQgc3RhdGUgbm9kZSBkZWZpbml0aW9uLiAqL1xuICBnZXQgZGVmaW5pdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICBrZXk6IHRoaXMua2V5LFxuICAgICAgdmVyc2lvbjogdGhpcy5tYWNoaW5lLnZlcnNpb24sXG4gICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICBpbml0aWFsOiB0aGlzLmluaXRpYWwgPyB7XG4gICAgICAgIHRhcmdldDogdGhpcy5pbml0aWFsLnRhcmdldCxcbiAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICBhY3Rpb25zOiB0aGlzLmluaXRpYWwuYWN0aW9ucy5tYXAodG9TZXJpYWxpemFibGVBY3Rpb24pLFxuICAgICAgICBldmVudFR5cGU6IG51bGwsXG4gICAgICAgIHJlZW50ZXI6IGZhbHNlLFxuICAgICAgICB0b0pTT046ICgpID0+ICh7XG4gICAgICAgICAgdGFyZ2V0OiB0aGlzLmluaXRpYWwudGFyZ2V0Lm1hcCh0ID0+IGAjJHt0LmlkfWApLFxuICAgICAgICAgIHNvdXJjZTogYCMke3RoaXMuaWR9YCxcbiAgICAgICAgICBhY3Rpb25zOiB0aGlzLmluaXRpYWwuYWN0aW9ucy5tYXAodG9TZXJpYWxpemFibGVBY3Rpb24pLFxuICAgICAgICAgIGV2ZW50VHlwZTogbnVsbFxuICAgICAgICB9KVxuICAgICAgfSA6IHVuZGVmaW5lZCxcbiAgICAgIGhpc3Rvcnk6IHRoaXMuaGlzdG9yeSxcbiAgICAgIHN0YXRlczogbWFwVmFsdWVzKHRoaXMuc3RhdGVzLCBzdGF0ZSA9PiB7XG4gICAgICAgIHJldHVybiBzdGF0ZS5kZWZpbml0aW9uO1xuICAgICAgfSksXG4gICAgICBvbjogdGhpcy5vbixcbiAgICAgIHRyYW5zaXRpb25zOiBbLi4udGhpcy50cmFuc2l0aW9ucy52YWx1ZXMoKV0uZmxhdCgpLm1hcCh0ID0+ICh7XG4gICAgICAgIC4uLnQsXG4gICAgICAgIGFjdGlvbnM6IHQuYWN0aW9ucy5tYXAodG9TZXJpYWxpemFibGVBY3Rpb24pXG4gICAgICB9KSksXG4gICAgICBlbnRyeTogdGhpcy5lbnRyeS5tYXAodG9TZXJpYWxpemFibGVBY3Rpb24pLFxuICAgICAgZXhpdDogdGhpcy5leGl0Lm1hcCh0b1NlcmlhbGl6YWJsZUFjdGlvbiksXG4gICAgICBtZXRhOiB0aGlzLm1ldGEsXG4gICAgICBvcmRlcjogdGhpcy5vcmRlciB8fCAtMSxcbiAgICAgIG91dHB1dDogdGhpcy5vdXRwdXQsXG4gICAgICBpbnZva2U6IHRoaXMuaW52b2tlLFxuICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXG4gICAgICB0YWdzOiB0aGlzLnRhZ3NcbiAgICB9O1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmaW5pdGlvbjtcbiAgfVxuXG4gIC8qKiBUaGUgbG9naWMgaW52b2tlZCBhcyBhY3RvcnMgYnkgdGhpcyBzdGF0ZSBub2RlLiAqL1xuICBnZXQgaW52b2tlKCkge1xuICAgIHJldHVybiBtZW1vKHRoaXMsICdpbnZva2UnLCAoKSA9PiB0b0FycmF5KHRoaXMuY29uZmlnLmludm9rZSkubWFwKChpbnZva2VDb25maWcsIGkpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3JjLFxuICAgICAgICBzeXN0ZW1JZFxuICAgICAgfSA9IGludm9rZUNvbmZpZztcbiAgICAgIGNvbnN0IHJlc29sdmVkSWQgPSBpbnZva2VDb25maWcuaWQgPz8gY3JlYXRlSW52b2tlSWQodGhpcy5pZCwgaSk7XG4gICAgICBjb25zdCByZXNvbHZlZFNyYyA9IHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnID8gc3JjIDogYHhzdGF0ZS5pbnZva2UuJHtjcmVhdGVJbnZva2VJZCh0aGlzLmlkLCBpKX1gO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uaW52b2tlQ29uZmlnLFxuICAgICAgICBzcmM6IHJlc29sdmVkU3JjLFxuICAgICAgICBpZDogcmVzb2x2ZWRJZCxcbiAgICAgICAgc3lzdGVtSWQ6IHN5c3RlbUlkLFxuICAgICAgICB0b0pTT04oKSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgb25Eb25lLFxuICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgICAgIC4uLmludm9rZURlZlZhbHVlc1xuICAgICAgICAgIH0gPSBpbnZva2VDb25maWc7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmludm9rZURlZlZhbHVlcyxcbiAgICAgICAgICAgIHR5cGU6ICd4c3RhdGUuaW52b2tlJyxcbiAgICAgICAgICAgIHNyYzogcmVzb2x2ZWRTcmMsXG4gICAgICAgICAgICBpZDogcmVzb2x2ZWRJZFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSkpO1xuICB9XG5cbiAgLyoqIFRoZSBtYXBwaW5nIG9mIGV2ZW50cyB0byB0cmFuc2l0aW9ucy4gKi9cbiAgZ2V0IG9uKCkge1xuICAgIHJldHVybiBtZW1vKHRoaXMsICdvbicsICgpID0+IHtcbiAgICAgIGNvbnN0IHRyYW5zaXRpb25zID0gdGhpcy50cmFuc2l0aW9ucztcbiAgICAgIHJldHVybiBbLi4udHJhbnNpdGlvbnNdLmZsYXRNYXAoKFtkZXNjcmlwdG9yLCB0XSkgPT4gdC5tYXAodCA9PiBbZGVzY3JpcHRvciwgdF0pKS5yZWR1Y2UoKG1hcCwgW2Rlc2NyaXB0b3IsIHRyYW5zaXRpb25dKSA9PiB7XG4gICAgICAgIG1hcFtkZXNjcmlwdG9yXSA9IG1hcFtkZXNjcmlwdG9yXSB8fCBbXTtcbiAgICAgICAgbWFwW2Rlc2NyaXB0b3JdLnB1c2godHJhbnNpdGlvbik7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgICB9LCB7fSk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0IGFmdGVyKCkge1xuICAgIHJldHVybiBtZW1vKHRoaXMsICdkZWxheWVkVHJhbnNpdGlvbnMnLCAoKSA9PiBnZXREZWxheWVkVHJhbnNpdGlvbnModGhpcykpO1xuICB9XG4gIGdldCBpbml0aWFsKCkge1xuICAgIHJldHVybiBtZW1vKHRoaXMsICdpbml0aWFsJywgKCkgPT4gZm9ybWF0SW5pdGlhbFRyYW5zaXRpb24odGhpcywgdGhpcy5jb25maWcuaW5pdGlhbCkpO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBuZXh0KHNuYXBzaG90LCBldmVudCkge1xuICAgIGNvbnN0IGV2ZW50VHlwZSA9IGV2ZW50LnR5cGU7XG4gICAgY29uc3QgYWN0aW9ucyA9IFtdO1xuICAgIGxldCBzZWxlY3RlZFRyYW5zaXRpb247XG4gICAgY29uc3QgY2FuZGlkYXRlcyA9IG1lbW8odGhpcywgYGNhbmRpZGF0ZXMtJHtldmVudFR5cGV9YCwgKCkgPT4gZ2V0Q2FuZGlkYXRlcyh0aGlzLCBldmVudFR5cGUpKTtcbiAgICBmb3IgKGNvbnN0IGNhbmRpZGF0ZSBvZiBjYW5kaWRhdGVzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGd1YXJkXG4gICAgICB9ID0gY2FuZGlkYXRlO1xuICAgICAgY29uc3QgcmVzb2x2ZWRDb250ZXh0ID0gc25hcHNob3QuY29udGV4dDtcbiAgICAgIGxldCBndWFyZFBhc3NlZCA9IGZhbHNlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZ3VhcmRQYXNzZWQgPSAhZ3VhcmQgfHwgZXZhbHVhdGVHdWFyZChndWFyZCwgcmVzb2x2ZWRDb250ZXh0LCBldmVudCwgc25hcHNob3QpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IGd1YXJkVHlwZSA9IHR5cGVvZiBndWFyZCA9PT0gJ3N0cmluZycgPyBndWFyZCA6IHR5cGVvZiBndWFyZCA9PT0gJ29iamVjdCcgPyBndWFyZC50eXBlIDogdW5kZWZpbmVkO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBldmFsdWF0ZSBndWFyZCAke2d1YXJkVHlwZSA/IGAnJHtndWFyZFR5cGV9JyBgIDogJyd9aW4gdHJhbnNpdGlvbiBmb3IgZXZlbnQgJyR7ZXZlbnRUeXBlfScgaW4gc3RhdGUgbm9kZSAnJHt0aGlzLmlkfSc6XFxuJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICAgIGlmIChndWFyZFBhc3NlZCkge1xuICAgICAgICBhY3Rpb25zLnB1c2goLi4uY2FuZGlkYXRlLmFjdGlvbnMpO1xuICAgICAgICBzZWxlY3RlZFRyYW5zaXRpb24gPSBjYW5kaWRhdGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0ZWRUcmFuc2l0aW9uID8gW3NlbGVjdGVkVHJhbnNpdGlvbl0gOiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKiogQWxsIHRoZSBldmVudCB0eXBlcyBhY2NlcHRlZCBieSB0aGlzIHN0YXRlIG5vZGUgYW5kIGl0cyBkZXNjZW5kYW50cy4gKi9cbiAgZ2V0IGV2ZW50cygpIHtcbiAgICByZXR1cm4gbWVtbyh0aGlzLCAnZXZlbnRzJywgKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzdGF0ZXNcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgY29uc3QgZXZlbnRzID0gbmV3IFNldCh0aGlzLm93bkV2ZW50cyk7XG4gICAgICBpZiAoc3RhdGVzKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc3RhdGVJZCBvZiBPYmplY3Qua2V5cyhzdGF0ZXMpKSB7XG4gICAgICAgICAgY29uc3Qgc3RhdGUgPSBzdGF0ZXNbc3RhdGVJZF07XG4gICAgICAgICAgaWYgKHN0YXRlLnN0YXRlcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiBzdGF0ZS5ldmVudHMpIHtcbiAgICAgICAgICAgICAgZXZlbnRzLmFkZChgJHtldmVudH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBBcnJheS5mcm9tKGV2ZW50cyk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWxsIHRoZSBldmVudHMgdGhhdCBoYXZlIHRyYW5zaXRpb25zIGRpcmVjdGx5IGZyb20gdGhpcyBzdGF0ZSBub2RlLlxuICAgKlxuICAgKiBFeGNsdWRlcyBhbnkgaW5lcnQgZXZlbnRzLlxuICAgKi9cbiAgZ2V0IG93bkV2ZW50cygpIHtcbiAgICBjb25zdCBldmVudHMgPSBuZXcgU2V0KFsuLi50aGlzLnRyYW5zaXRpb25zLmtleXMoKV0uZmlsdGVyKGRlc2NyaXB0b3IgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvbnMuZ2V0KGRlc2NyaXB0b3IpLnNvbWUodHJhbnNpdGlvbiA9PiAhKCF0cmFuc2l0aW9uLnRhcmdldCAmJiAhdHJhbnNpdGlvbi5hY3Rpb25zLmxlbmd0aCAmJiAhdHJhbnNpdGlvbi5yZWVudGVyKSk7XG4gICAgfSkpO1xuICAgIHJldHVybiBBcnJheS5mcm9tKGV2ZW50cyk7XG4gIH1cbn1cblxuY29uc3QgU1RBVEVfSURFTlRJRklFUiA9ICcjJztcbmNsYXNzIFN0YXRlTWFjaGluZSB7XG4gIGNvbnN0cnVjdG9yKC8qKiBUaGUgcmF3IGNvbmZpZyB1c2VkIHRvIGNyZWF0ZSB0aGUgbWFjaGluZS4gKi9cbiAgY29uZmlnLCBpbXBsZW1lbnRhdGlvbnMpIHtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAvKiogVGhlIG1hY2hpbmUncyBvd24gdmVyc2lvbi4gKi9cbiAgICB0aGlzLnZlcnNpb24gPSB2b2lkIDA7XG4gICAgdGhpcy5zY2hlbWFzID0gdm9pZCAwO1xuICAgIHRoaXMuaW1wbGVtZW50YXRpb25zID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9feHN0YXRlbm9kZSA9IHRydWU7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuaWRNYXAgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5yb290ID0gdm9pZCAwO1xuICAgIHRoaXMuaWQgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGF0ZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5ldmVudHMgPSB2b2lkIDA7XG4gICAgdGhpcy5pZCA9IGNvbmZpZy5pZCB8fCAnKG1hY2hpbmUpJztcbiAgICB0aGlzLmltcGxlbWVudGF0aW9ucyA9IHtcbiAgICAgIGFjdG9yczogaW1wbGVtZW50YXRpb25zPy5hY3RvcnMgPz8ge30sXG4gICAgICBhY3Rpb25zOiBpbXBsZW1lbnRhdGlvbnM/LmFjdGlvbnMgPz8ge30sXG4gICAgICBkZWxheXM6IGltcGxlbWVudGF0aW9ucz8uZGVsYXlzID8/IHt9LFxuICAgICAgZ3VhcmRzOiBpbXBsZW1lbnRhdGlvbnM/Lmd1YXJkcyA/PyB7fVxuICAgIH07XG4gICAgdGhpcy52ZXJzaW9uID0gdGhpcy5jb25maWcudmVyc2lvbjtcbiAgICB0aGlzLnNjaGVtYXMgPSB0aGlzLmNvbmZpZy5zY2hlbWFzO1xuICAgIHRoaXMudHJhbnNpdGlvbiA9IHRoaXMudHJhbnNpdGlvbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZ2V0SW5pdGlhbFNuYXBzaG90ID0gdGhpcy5nZXRJbml0aWFsU25hcHNob3QuYmluZCh0aGlzKTtcbiAgICB0aGlzLmdldFBlcnNpc3RlZFNuYXBzaG90ID0gdGhpcy5nZXRQZXJzaXN0ZWRTbmFwc2hvdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMucmVzdG9yZVNuYXBzaG90ID0gdGhpcy5yZXN0b3JlU25hcHNob3QuYmluZCh0aGlzKTtcbiAgICB0aGlzLnN0YXJ0ID0gdGhpcy5zdGFydC5iaW5kKHRoaXMpO1xuICAgIHRoaXMucm9vdCA9IG5ldyBTdGF0ZU5vZGUoY29uZmlnLCB7XG4gICAgICBfa2V5OiB0aGlzLmlkLFxuICAgICAgX21hY2hpbmU6IHRoaXNcbiAgICB9KTtcbiAgICB0aGlzLnJvb3QuX2luaXRpYWxpemUoKTtcbiAgICB0aGlzLnN0YXRlcyA9IHRoaXMucm9vdC5zdGF0ZXM7IC8vIFRPRE86IHJlbW92ZSFcbiAgICB0aGlzLmV2ZW50cyA9IHRoaXMucm9vdC5ldmVudHM7XG4gICAgaWYgKCEoJ291dHB1dCcgaW4gdGhpcy5yb290KSAmJiBPYmplY3QudmFsdWVzKHRoaXMuc3RhdGVzKS5zb21lKHN0YXRlID0+IHN0YXRlLnR5cGUgPT09ICdmaW5hbCcgJiYgJ291dHB1dCcgaW4gc3RhdGUpKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ01pc3NpbmcgYG1hY2hpbmUub3V0cHV0YCBkZWNsYXJhdGlvbiAodG9wLWxldmVsIGZpbmFsIHN0YXRlIHdpdGggb3V0cHV0IGRldGVjdGVkKScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9uZXMgdGhpcyBzdGF0ZSBtYWNoaW5lIHdpdGggdGhlIHByb3ZpZGVkIGltcGxlbWVudGF0aW9ucyBhbmQgbWVyZ2VzIHRoZVxuICAgKiBgY29udGV4dGAgKGlmIHByb3ZpZGVkKS5cbiAgICpcbiAgICogQHBhcmFtIGltcGxlbWVudGF0aW9ucyBPcHRpb25zIChgYWN0aW9uc2AsIGBndWFyZHNgLCBgYWN0b3JzYCwgYGRlbGF5c2AsXG4gICAqICAgYGNvbnRleHRgKSB0byByZWN1cnNpdmVseSBtZXJnZSB3aXRoIHRoZSBleGlzdGluZyBvcHRpb25zLlxuICAgKiBAcmV0dXJucyBBIG5ldyBgU3RhdGVNYWNoaW5lYCBpbnN0YW5jZSB3aXRoIHRoZSBwcm92aWRlZCBpbXBsZW1lbnRhdGlvbnMuXG4gICAqL1xuICBwcm92aWRlKGltcGxlbWVudGF0aW9ucykge1xuICAgIGNvbnN0IHtcbiAgICAgIGFjdGlvbnMsXG4gICAgICBndWFyZHMsXG4gICAgICBhY3RvcnMsXG4gICAgICBkZWxheXNcbiAgICB9ID0gdGhpcy5pbXBsZW1lbnRhdGlvbnM7XG4gICAgcmV0dXJuIG5ldyBTdGF0ZU1hY2hpbmUodGhpcy5jb25maWcsIHtcbiAgICAgIGFjdGlvbnM6IHtcbiAgICAgICAgLi4uYWN0aW9ucyxcbiAgICAgICAgLi4uaW1wbGVtZW50YXRpb25zLmFjdGlvbnNcbiAgICAgIH0sXG4gICAgICBndWFyZHM6IHtcbiAgICAgICAgLi4uZ3VhcmRzLFxuICAgICAgICAuLi5pbXBsZW1lbnRhdGlvbnMuZ3VhcmRzXG4gICAgICB9LFxuICAgICAgYWN0b3JzOiB7XG4gICAgICAgIC4uLmFjdG9ycyxcbiAgICAgICAgLi4uaW1wbGVtZW50YXRpb25zLmFjdG9yc1xuICAgICAgfSxcbiAgICAgIGRlbGF5czoge1xuICAgICAgICAuLi5kZWxheXMsXG4gICAgICAgIC4uLmltcGxlbWVudGF0aW9ucy5kZWxheXNcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXNvbHZlU3RhdGUoY29uZmlnKSB7XG4gICAgY29uc3QgcmVzb2x2ZWRTdGF0ZVZhbHVlID0gcmVzb2x2ZVN0YXRlVmFsdWUodGhpcy5yb290LCBjb25maWcudmFsdWUpO1xuICAgIGNvbnN0IG5vZGVTZXQgPSBnZXRBbGxTdGF0ZU5vZGVzKGdldFN0YXRlTm9kZXModGhpcy5yb290LCByZXNvbHZlZFN0YXRlVmFsdWUpKTtcbiAgICByZXR1cm4gY3JlYXRlTWFjaGluZVNuYXBzaG90KHtcbiAgICAgIF9ub2RlczogWy4uLm5vZGVTZXRdLFxuICAgICAgY29udGV4dDogY29uZmlnLmNvbnRleHQgfHwge30sXG4gICAgICBjaGlsZHJlbjoge30sXG4gICAgICBzdGF0dXM6IGlzSW5GaW5hbFN0YXRlKG5vZGVTZXQsIHRoaXMucm9vdCkgPyAnZG9uZScgOiBjb25maWcuc3RhdHVzIHx8ICdhY3RpdmUnLFxuICAgICAgb3V0cHV0OiBjb25maWcub3V0cHV0LFxuICAgICAgZXJyb3I6IGNvbmZpZy5lcnJvcixcbiAgICAgIGhpc3RvcnlWYWx1ZTogY29uZmlnLmhpc3RvcnlWYWx1ZVxuICAgIH0sIHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgdGhlIG5leHQgc25hcHNob3QgZ2l2ZW4gdGhlIGN1cnJlbnQgYHNuYXBzaG90YCBhbmQgcmVjZWl2ZWRcbiAgICogYGV2ZW50YC4gQ2FsY3VsYXRlcyBhIGZ1bGwgbWFjcm9zdGVwIGZyb20gYWxsIG1pY3Jvc3RlcHMuXG4gICAqXG4gICAqIEBwYXJhbSBzbmFwc2hvdCBUaGUgY3VycmVudCBzbmFwc2hvdFxuICAgKiBAcGFyYW0gZXZlbnQgVGhlIHJlY2VpdmVkIGV2ZW50XG4gICAqL1xuICB0cmFuc2l0aW9uKHNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSkge1xuICAgIHJldHVybiBtYWNyb3N0ZXAoc25hcHNob3QsIGV2ZW50LCBhY3RvclNjb3BlKS5zbmFwc2hvdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBuZXh0IHN0YXRlIGdpdmVuIHRoZSBjdXJyZW50IGBzdGF0ZWAgYW5kIGBldmVudGAuIENhbGN1bGF0ZXNcbiAgICogYSBtaWNyb3N0ZXAuXG4gICAqXG4gICAqIEBwYXJhbSBzdGF0ZSBUaGUgY3VycmVudCBzdGF0ZVxuICAgKiBAcGFyYW0gZXZlbnQgVGhlIHJlY2VpdmVkIGV2ZW50XG4gICAqL1xuICBtaWNyb3N0ZXAoc25hcHNob3QsIGV2ZW50LCBhY3RvclNjb3BlKSB7XG4gICAgcmV0dXJuIG1hY3Jvc3RlcChzbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUpLm1pY3Jvc3RhdGVzO1xuICB9XG4gIGdldFRyYW5zaXRpb25EYXRhKHNuYXBzaG90LCBldmVudCkge1xuICAgIHJldHVybiB0cmFuc2l0aW9uTm9kZSh0aGlzLnJvb3QsIHNuYXBzaG90LnZhbHVlLCBzbmFwc2hvdCwgZXZlbnQpIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBpbml0aWFsIHN0YXRlIF9iZWZvcmVfIGV2YWx1YXRpbmcgYW55IG1pY3Jvc3RlcHMuIFRoaXMgXCJwcmUtaW5pdGlhbFwiXG4gICAqIHN0YXRlIGlzIHByb3ZpZGVkIHRvIGluaXRpYWwgYWN0aW9ucyBleGVjdXRlZCBpbiB0aGUgaW5pdGlhbCBzdGF0ZS5cbiAgICovXG4gIGdldFByZUluaXRpYWxTdGF0ZShhY3RvclNjb3BlLCBpbml0RXZlbnQsIGludGVybmFsUXVldWUpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250ZXh0XG4gICAgfSA9IHRoaXMuY29uZmlnO1xuICAgIGNvbnN0IHByZUluaXRpYWwgPSBjcmVhdGVNYWNoaW5lU25hcHNob3Qoe1xuICAgICAgY29udGV4dDogdHlwZW9mIGNvbnRleHQgIT09ICdmdW5jdGlvbicgJiYgY29udGV4dCA/IGNvbnRleHQgOiB7fSxcbiAgICAgIF9ub2RlczogW3RoaXMucm9vdF0sXG4gICAgICBjaGlsZHJlbjoge30sXG4gICAgICBzdGF0dXM6ICdhY3RpdmUnXG4gICAgfSwgdGhpcyk7XG4gICAgaWYgKHR5cGVvZiBjb250ZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zdCBhc3NpZ25tZW50ID0gKHtcbiAgICAgICAgc3Bhd24sXG4gICAgICAgIGV2ZW50LFxuICAgICAgICBzZWxmXG4gICAgICB9KSA9PiBjb250ZXh0KHtcbiAgICAgICAgc3Bhd24sXG4gICAgICAgIGlucHV0OiBldmVudC5pbnB1dCxcbiAgICAgICAgc2VsZlxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzb2x2ZUFjdGlvbnNBbmRDb250ZXh0KHByZUluaXRpYWwsIGluaXRFdmVudCwgYWN0b3JTY29wZSwgW2Fzc2lnbihhc3NpZ25tZW50KV0sIGludGVybmFsUXVldWUpO1xuICAgIH1cbiAgICByZXR1cm4gcHJlSW5pdGlhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbml0aWFsIGBTdGF0ZWAgaW5zdGFuY2UsIHdpdGggcmVmZXJlbmNlIHRvIGBzZWxmYCBhcyBhblxuICAgKiBgQWN0b3JSZWZgLlxuICAgKi9cbiAgZ2V0SW5pdGlhbFNuYXBzaG90KGFjdG9yU2NvcGUsIGlucHV0KSB7XG4gICAgY29uc3QgaW5pdEV2ZW50ID0gY3JlYXRlSW5pdEV2ZW50KGlucHV0KTsgLy8gVE9ETzogZml4O1xuICAgIGNvbnN0IGludGVybmFsUXVldWUgPSBbXTtcbiAgICBjb25zdCBwcmVJbml0aWFsU3RhdGUgPSB0aGlzLmdldFByZUluaXRpYWxTdGF0ZShhY3RvclNjb3BlLCBpbml0RXZlbnQsIGludGVybmFsUXVldWUpO1xuICAgIGNvbnN0IG5leHRTdGF0ZSA9IG1pY3Jvc3RlcChbe1xuICAgICAgdGFyZ2V0OiBbLi4uZ2V0SW5pdGlhbFN0YXRlTm9kZXModGhpcy5yb290KV0sXG4gICAgICBzb3VyY2U6IHRoaXMucm9vdCxcbiAgICAgIHJlZW50ZXI6IHRydWUsXG4gICAgICBhY3Rpb25zOiBbXSxcbiAgICAgIGV2ZW50VHlwZTogbnVsbCxcbiAgICAgIHRvSlNPTjogbnVsbCAvLyBUT0RPOiBmaXhcbiAgICB9XSwgcHJlSW5pdGlhbFN0YXRlLCBhY3RvclNjb3BlLCBpbml0RXZlbnQsIHRydWUsIGludGVybmFsUXVldWUpO1xuICAgIGNvbnN0IHtcbiAgICAgIHNuYXBzaG90OiBtYWNyb1N0YXRlXG4gICAgfSA9IG1hY3Jvc3RlcChuZXh0U3RhdGUsIGluaXRFdmVudCwgYWN0b3JTY29wZSwgaW50ZXJuYWxRdWV1ZSk7XG4gICAgcmV0dXJuIG1hY3JvU3RhdGU7XG4gIH1cbiAgc3RhcnQoc25hcHNob3QpIHtcbiAgICBPYmplY3QudmFsdWVzKHNuYXBzaG90LmNoaWxkcmVuKS5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgIGlmIChjaGlsZC5nZXRTbmFwc2hvdCgpLnN0YXR1cyA9PT0gJ2FjdGl2ZScpIHtcbiAgICAgICAgY2hpbGQuc3RhcnQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXRTdGF0ZU5vZGVCeUlkKHN0YXRlSWQpIHtcbiAgICBjb25zdCBmdWxsUGF0aCA9IHRvU3RhdGVQYXRoKHN0YXRlSWQpO1xuICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IGZ1bGxQYXRoLnNsaWNlKDEpO1xuICAgIGNvbnN0IHJlc29sdmVkU3RhdGVJZCA9IGlzU3RhdGVJZChmdWxsUGF0aFswXSkgPyBmdWxsUGF0aFswXS5zbGljZShTVEFURV9JREVOVElGSUVSLmxlbmd0aCkgOiBmdWxsUGF0aFswXTtcbiAgICBjb25zdCBzdGF0ZU5vZGUgPSB0aGlzLmlkTWFwLmdldChyZXNvbHZlZFN0YXRlSWQpO1xuICAgIGlmICghc3RhdGVOb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENoaWxkIHN0YXRlIG5vZGUgJyMke3Jlc29sdmVkU3RhdGVJZH0nIGRvZXMgbm90IGV4aXN0IG9uIG1hY2hpbmUgJyR7dGhpcy5pZH0nYCk7XG4gICAgfVxuICAgIHJldHVybiBnZXRTdGF0ZU5vZGVCeVBhdGgoc3RhdGVOb2RlLCByZWxhdGl2ZVBhdGgpO1xuICB9XG4gIGdldCBkZWZpbml0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJvb3QuZGVmaW5pdGlvbjtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmaW5pdGlvbjtcbiAgfVxuICBnZXRQZXJzaXN0ZWRTbmFwc2hvdChzbmFwc2hvdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBnZXRQZXJzaXN0ZWRTbmFwc2hvdChzbmFwc2hvdCwgb3B0aW9ucyk7XG4gIH1cbiAgcmVzdG9yZVNuYXBzaG90KHNuYXBzaG90LCBfYWN0b3JTY29wZSkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0ge307XG4gICAgY29uc3Qgc25hcHNob3RDaGlsZHJlbiA9IHNuYXBzaG90LmNoaWxkcmVuO1xuICAgIE9iamVjdC5rZXlzKHNuYXBzaG90Q2hpbGRyZW4pLmZvckVhY2goYWN0b3JJZCA9PiB7XG4gICAgICBjb25zdCBhY3RvckRhdGEgPSBzbmFwc2hvdENoaWxkcmVuW2FjdG9ySWRdO1xuICAgICAgY29uc3QgY2hpbGRTdGF0ZSA9IGFjdG9yRGF0YS5zbmFwc2hvdDtcbiAgICAgIGNvbnN0IHNyYyA9IGFjdG9yRGF0YS5zcmM7XG4gICAgICBjb25zdCBsb2dpYyA9IHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnID8gcmVzb2x2ZVJlZmVyZW5jZWRBY3Rvcih0aGlzLCBzcmMpIDogc3JjO1xuICAgICAgaWYgKCFsb2dpYykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBhY3RvclJlZiA9IGNyZWF0ZUFjdG9yKGxvZ2ljLCB7XG4gICAgICAgIGlkOiBhY3RvcklkLFxuICAgICAgICBwYXJlbnQ6IF9hY3RvclNjb3BlLnNlbGYsXG4gICAgICAgIHN5bmNTbmFwc2hvdDogYWN0b3JEYXRhLnN5bmNTbmFwc2hvdCxcbiAgICAgICAgc25hcHNob3Q6IGNoaWxkU3RhdGUsXG4gICAgICAgIHNyYyxcbiAgICAgICAgc3lzdGVtSWQ6IGFjdG9yRGF0YS5zeXN0ZW1JZFxuICAgICAgfSk7XG4gICAgICBjaGlsZHJlblthY3RvcklkXSA9IGFjdG9yUmVmO1xuICAgIH0pO1xuICAgIGNvbnN0IHJlc3RvcmVkU25hcHNob3QgPSBjcmVhdGVNYWNoaW5lU25hcHNob3Qoe1xuICAgICAgLi4uc25hcHNob3QsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIF9ub2RlczogQXJyYXkuZnJvbShnZXRBbGxTdGF0ZU5vZGVzKGdldFN0YXRlTm9kZXModGhpcy5yb290LCBzbmFwc2hvdC52YWx1ZSkpKVxuICAgIH0sIHRoaXMpO1xuICAgIGxldCBzZWVuID0gbmV3IFNldCgpO1xuICAgIGZ1bmN0aW9uIHJldml2ZUNvbnRleHQoY29udGV4dFBhcnQsIGNoaWxkcmVuKSB7XG4gICAgICBpZiAoc2Vlbi5oYXMoY29udGV4dFBhcnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlZW4uYWRkKGNvbnRleHRQYXJ0KTtcbiAgICAgIGZvciAobGV0IGtleSBpbiBjb250ZXh0UGFydCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGNvbnRleHRQYXJ0W2tleV07XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgaWYgKCd4c3RhdGUkJHR5cGUnIGluIHZhbHVlICYmIHZhbHVlLnhzdGF0ZSQkdHlwZSA9PT0gJCRBQ1RPUl9UWVBFKSB7XG4gICAgICAgICAgICBjb250ZXh0UGFydFtrZXldID0gY2hpbGRyZW5bdmFsdWUuaWRdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldml2ZUNvbnRleHQodmFsdWUsIGNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXZpdmVDb250ZXh0KHJlc3RvcmVkU25hcHNob3QuY29udGV4dCwgY2hpbGRyZW4pO1xuICAgIHJldHVybiByZXN0b3JlZFNuYXBzaG90O1xuICB9XG59XG5cbi8vIHRoaXMgaXMgbm90IDEwMCUgYWNjdXJhdGUgc2luY2Ugd2UgY2FuJ3QgbWFrZSBwYXJhbGxlbCByZWdpb25zIHJlcXVpcmVkIGluIHRoZSByZXN1bHRcbi8vIGBUVGVzdFZhbHVlYCBkb2Vzbid0IGVuY29kZSB0aGlzIGluZm9ybWF0aW9uIGFueWhvdyBmb3IgdXMgdG8gYmUgYWJsZSB0byBkbyB0aGF0XG4vLyB0aGlzIGlzIGZpbmUgZm9yIG1vc3QgcHJhY3RpY2FsIHVzZSBjYXNlcyBhbnl3YXkgdGhvdWdoXG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YXRlIG1hY2hpbmUgKHN0YXRlY2hhcnQpIHdpdGggdGhlIGdpdmVuIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogVGhlIHN0YXRlIG1hY2hpbmUgcmVwcmVzZW50cyB0aGUgcHVyZSBsb2dpYyBvZiBhIHN0YXRlIG1hY2hpbmUgYWN0b3IuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgY3JlYXRlTWFjaGluZSB9IGZyb20gJ3hzdGF0ZSc7XG4gKlxuICogY29uc3QgbGlnaHRNYWNoaW5lID0gY3JlYXRlTWFjaGluZSh7XG4gKiAgIGlkOiAnbGlnaHQnLFxuICogICBpbml0aWFsOiAnZ3JlZW4nLFxuICogICBzdGF0ZXM6IHtcbiAqICAgICBncmVlbjoge1xuICogICAgICAgb246IHtcbiAqICAgICAgICAgVElNRVI6IHsgdGFyZ2V0OiAneWVsbG93JyB9XG4gKiAgICAgICB9XG4gKiAgICAgfSxcbiAqICAgICB5ZWxsb3c6IHtcbiAqICAgICAgIG9uOiB7XG4gKiAgICAgICAgIFRJTUVSOiB7IHRhcmdldDogJ3JlZCcgfVxuICogICAgICAgfVxuICogICAgIH0sXG4gKiAgICAgcmVkOiB7XG4gKiAgICAgICBvbjoge1xuICogICAgICAgICBUSU1FUjogeyB0YXJnZXQ6ICdncmVlbicgfVxuICogICAgICAgfVxuICogICAgIH1cbiAqICAgfVxuICogfSk7XG4gKlxuICogY29uc3QgbGlnaHRBY3RvciA9IGNyZWF0ZUFjdG9yKGxpZ2h0TWFjaGluZSk7XG4gKiBsaWdodEFjdG9yLnN0YXJ0KCk7XG4gKlxuICogbGlnaHRBY3Rvci5zZW5kKHsgdHlwZTogJ1RJTUVSJyB9KTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBjb25maWcgVGhlIHN0YXRlIG1hY2hpbmUgY29uZmlndXJhdGlvbi5cbiAqIEBwYXJhbSBvcHRpb25zIERFUFJFQ0FURUQ6IHVzZSBgc2V0dXAoeyAuLi4gfSlgIG9yIGBtYWNoaW5lLnByb3ZpZGUoeyAuLi4gfSlgXG4gKiAgIHRvIHByb3ZpZGUgbWFjaGluZSBpbXBsZW1lbnRhdGlvbnMgaW5zdGVhZC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWFjaGluZShjb25maWcsIGltcGxlbWVudGF0aW9ucykge1xuICByZXR1cm4gbmV3IFN0YXRlTWFjaGluZShjb25maWcsIGltcGxlbWVudGF0aW9ucyk7XG59XG5cbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIGNyZWF0ZUluZXJ0QWN0b3JTY29wZShhY3RvckxvZ2ljKSB7XG4gIGNvbnN0IHNlbGYgPSBjcmVhdGVBY3RvcihhY3RvckxvZ2ljKTtcbiAgY29uc3QgaW5lcnRBY3RvclNjb3BlID0ge1xuICAgIHNlbGYsXG4gICAgZGVmZXI6ICgpID0+IHt9LFxuICAgIGlkOiAnJyxcbiAgICBsb2dnZXI6ICgpID0+IHt9LFxuICAgIHNlc3Npb25JZDogJycsXG4gICAgc3RvcENoaWxkOiAoKSA9PiB7fSxcbiAgICBzeXN0ZW06IHNlbGYuc3lzdGVtLFxuICAgIGVtaXQ6ICgpID0+IHt9XG4gIH07XG4gIHJldHVybiBpbmVydEFjdG9yU2NvcGU7XG59XG5mdW5jdGlvbiBnZXRJbml0aWFsU25hcHNob3QoYWN0b3JMb2dpYywgLi4uW2lucHV0XSkge1xuICBjb25zdCBhY3RvclNjb3BlID0gY3JlYXRlSW5lcnRBY3RvclNjb3BlKGFjdG9yTG9naWMpO1xuICByZXR1cm4gYWN0b3JMb2dpYy5nZXRJbml0aWFsU25hcHNob3QoYWN0b3JTY29wZSwgaW5wdXQpO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgdGhlIG5leHQgc25hcHNob3QgZm9yIHRoZSBnaXZlbiBgYWN0b3JMb2dpY2AgYmFzZWQgb24gdGhlIGdpdmVuXG4gKiBgc25hcHNob3RgIGFuZCBgZXZlbnRgLlxuICpcbiAqIElmIHRoZSBgc25hcHNob3RgIGlzIGB1bmRlZmluZWRgLCB0aGUgaW5pdGlhbCBzbmFwc2hvdCBvZiB0aGUgYGFjdG9yTG9naWNgIGlzXG4gKiB1c2VkLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGdldE5leHRTbmFwc2hvdCB9IGZyb20gJ3hzdGF0ZSc7XG4gKiBpbXBvcnQgeyB0cmFmZmljTGlnaHRNYWNoaW5lIH0gZnJvbSAnLi90cmFmZmljTGlnaHRNYWNoaW5lLnRzJztcbiAqXG4gKiBjb25zdCBuZXh0U25hcHNob3QgPSBnZXROZXh0U25hcHNob3QoXG4gKiAgIHRyYWZmaWNMaWdodE1hY2hpbmUsIC8vIGFjdG9yIGxvZ2ljXG4gKiAgIHVuZGVmaW5lZCwgLy8gc25hcHNob3QgKG9yIGluaXRpYWwgc3RhdGUgaWYgdW5kZWZpbmVkKVxuICogICB7IHR5cGU6ICdUSU1FUicgfVxuICogKTsgLy8gZXZlbnQgb2JqZWN0XG4gKlxuICogY29uc29sZS5sb2cobmV4dFNuYXBzaG90LnZhbHVlKTtcbiAqIC8vID0+ICd5ZWxsb3cnXG4gKlxuICogY29uc3QgbmV4dFNuYXBzaG90MiA9IGdldE5leHRTbmFwc2hvdChcbiAqICAgdHJhZmZpY0xpZ2h0TWFjaGluZSwgLy8gYWN0b3IgbG9naWNcbiAqICAgbmV4dFNuYXBzaG90LCAvLyBzbmFwc2hvdFxuICogICB7IHR5cGU6ICdUSU1FUicgfVxuICogKTsgLy8gZXZlbnQgb2JqZWN0XG4gKlxuICogY29uc29sZS5sb2cobmV4dFNuYXBzaG90Mi52YWx1ZSk7XG4gKiAvLyA9PidyZWQnXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gZ2V0TmV4dFNuYXBzaG90KGFjdG9yTG9naWMsIHNuYXBzaG90LCBldmVudCkge1xuICBjb25zdCBpbmVydEFjdG9yU2NvcGUgPSBjcmVhdGVJbmVydEFjdG9yU2NvcGUoYWN0b3JMb2dpYyk7XG4gIGluZXJ0QWN0b3JTY29wZS5zZWxmLl9zbmFwc2hvdCA9IHNuYXBzaG90O1xuICByZXR1cm4gYWN0b3JMb2dpYy50cmFuc2l0aW9uKHNuYXBzaG90LCBldmVudCwgaW5lcnRBY3RvclNjb3BlKTtcbn1cblxuLy8gYXQgdGhlIG1vbWVudCB3ZSBhbGxvdyBleHRyYSBhY3RvcnMgLSBvbmVzIHRoYXQgYXJlIG5vdCBzcGVjaWZpZWQgYnkgYGNoaWxkcmVuYFxuLy8gdGhpcyBjb3VsZCBiZSByZWNvbnNpZGVyZWQgaW4gdGhlIGZ1dHVyZVxuXG5mdW5jdGlvbiBzZXR1cCh7XG4gIHNjaGVtYXMsXG4gIGFjdG9ycyxcbiAgYWN0aW9ucyxcbiAgZ3VhcmRzLFxuICBkZWxheXNcbn0pIHtcbiAgcmV0dXJuIHtcbiAgICBjcmVhdGVNYWNoaW5lOiBjb25maWcgPT4gY3JlYXRlTWFjaGluZSh7XG4gICAgICAuLi5jb25maWcsXG4gICAgICBzY2hlbWFzXG4gICAgfSwge1xuICAgICAgYWN0b3JzLFxuICAgICAgYWN0aW9ucyxcbiAgICAgIGd1YXJkcyxcbiAgICAgIGRlbGF5c1xuICAgIH0pXG4gIH07XG59XG5cbmNsYXNzIFNpbXVsYXRlZENsb2NrIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy50aW1lb3V0cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9ub3cgPSAwO1xuICAgIHRoaXMuX2lkID0gMDtcbiAgICB0aGlzLl9mbHVzaGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX2ZsdXNoaW5nSW52YWxpZGF0ZWQgPSBmYWxzZTtcbiAgfVxuICBub3coKSB7XG4gICAgcmV0dXJuIHRoaXMuX25vdztcbiAgfVxuICBnZXRJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faWQrKztcbiAgfVxuICBzZXRUaW1lb3V0KGZuLCB0aW1lb3V0KSB7XG4gICAgdGhpcy5fZmx1c2hpbmdJbnZhbGlkYXRlZCA9IHRoaXMuX2ZsdXNoaW5nO1xuICAgIGNvbnN0IGlkID0gdGhpcy5nZXRJZCgpO1xuICAgIHRoaXMudGltZW91dHMuc2V0KGlkLCB7XG4gICAgICBzdGFydDogdGhpcy5ub3coKSxcbiAgICAgIHRpbWVvdXQsXG4gICAgICBmblxuICAgIH0pO1xuICAgIHJldHVybiBpZDtcbiAgfVxuICBjbGVhclRpbWVvdXQoaWQpIHtcbiAgICB0aGlzLl9mbHVzaGluZ0ludmFsaWRhdGVkID0gdGhpcy5fZmx1c2hpbmc7XG4gICAgdGhpcy50aW1lb3V0cy5kZWxldGUoaWQpO1xuICB9XG4gIHNldCh0aW1lKSB7XG4gICAgaWYgKHRoaXMuX25vdyA+IHRpbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHRyYXZlbCBiYWNrIGluIHRpbWUnKTtcbiAgICB9XG4gICAgdGhpcy5fbm93ID0gdGltZTtcbiAgICB0aGlzLmZsdXNoVGltZW91dHMoKTtcbiAgfVxuICBmbHVzaFRpbWVvdXRzKCkge1xuICAgIGlmICh0aGlzLl9mbHVzaGluZykge1xuICAgICAgdGhpcy5fZmx1c2hpbmdJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2ZsdXNoaW5nID0gdHJ1ZTtcbiAgICBjb25zdCBzb3J0ZWQgPSBbLi4udGhpcy50aW1lb3V0c10uc29ydCgoW19pZEEsIHRpbWVvdXRBXSwgW19pZEIsIHRpbWVvdXRCXSkgPT4ge1xuICAgICAgY29uc3QgZW5kQSA9IHRpbWVvdXRBLnN0YXJ0ICsgdGltZW91dEEudGltZW91dDtcbiAgICAgIGNvbnN0IGVuZEIgPSB0aW1lb3V0Qi5zdGFydCArIHRpbWVvdXRCLnRpbWVvdXQ7XG4gICAgICByZXR1cm4gZW5kQiA+IGVuZEEgPyAtMSA6IDE7XG4gICAgfSk7XG4gICAgZm9yIChjb25zdCBbaWQsIHRpbWVvdXRdIG9mIHNvcnRlZCkge1xuICAgICAgaWYgKHRoaXMuX2ZsdXNoaW5nSW52YWxpZGF0ZWQpIHtcbiAgICAgICAgdGhpcy5fZmx1c2hpbmdJbnZhbGlkYXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9mbHVzaGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZsdXNoVGltZW91dHMoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubm93KCkgLSB0aW1lb3V0LnN0YXJ0ID49IHRpbWVvdXQudGltZW91dCkge1xuICAgICAgICB0aGlzLnRpbWVvdXRzLmRlbGV0ZShpZCk7XG4gICAgICAgIHRpbWVvdXQuZm4uY2FsbChudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZmx1c2hpbmcgPSBmYWxzZTtcbiAgfVxuICBpbmNyZW1lbnQobXMpIHtcbiAgICB0aGlzLl9ub3cgKz0gbXM7XG4gICAgdGhpcy5mbHVzaFRpbWVvdXRzKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBgb3V0cHV0YCBvZiB0aGUgYWN0b3Igd2hlbiBpdCBpcyBkb25lLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IG1hY2hpbmUgPSBjcmVhdGVNYWNoaW5lKHtcbiAqICAgLy8gLi4uXG4gKiAgIG91dHB1dDoge1xuICogICAgIGNvdW50OiA0MlxuICogICB9XG4gKiB9KTtcbiAqXG4gKiBjb25zdCBhY3RvciA9IGNyZWF0ZUFjdG9yKG1hY2hpbmUpO1xuICpcbiAqIGFjdG9yLnN0YXJ0KCk7XG4gKlxuICogY29uc3Qgb3V0cHV0ID0gYXdhaXQgdG9Qcm9taXNlKGFjdG9yKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhvdXRwdXQpO1xuICogLy8gbG9ncyB7IGNvdW50OiA0MiB9XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gdG9Qcm9taXNlKGFjdG9yKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgYWN0b3Iuc3Vic2NyaWJlKHtcbiAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgIHJlc29sdmUoYWN0b3IuZ2V0U25hcHNob3QoKS5vdXRwdXQpO1xuICAgICAgfSxcbiAgICAgIGVycm9yOiByZWplY3RcbiAgICB9KTtcbiAgfSk7XG59XG5cbmNvbnN0IGRlZmF1bHRXYWl0Rm9yT3B0aW9ucyA9IHtcbiAgdGltZW91dDogSW5maW5pdHkgLy8gbXVjaCBtb3JlIHRoYW4gMTAgc2Vjb25kc1xufTtcblxuLyoqXG4gKiBTdWJzY3JpYmVzIHRvIGFuIGFjdG9yIHJlZiBhbmQgd2FpdHMgZm9yIGl0cyBlbWl0dGVkIHZhbHVlIHRvIHNhdGlzZnkgYVxuICogcHJlZGljYXRlLCBhbmQgdGhlbiByZXNvbHZlcyB3aXRoIHRoYXQgdmFsdWUuIFdpbGwgdGhyb3cgaWYgdGhlIGRlc2lyZWQgc3RhdGVcbiAqIGlzIG5vdCByZWFjaGVkIGFmdGVyIGFuIG9wdGlvbmFsIHRpbWVvdXQuIChkZWZhdWx0cyB0byBJbmZpbml0eSkuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogY29uc3Qgc3RhdGUgPSBhd2FpdCB3YWl0Rm9yKHNvbWVTZXJ2aWNlLCAoc3RhdGUpID0+IHtcbiAqICAgcmV0dXJuIHN0YXRlLmhhc1RhZygnbG9hZGVkJyk7XG4gKiB9KTtcbiAqXG4gKiBzdGF0ZS5oYXNUYWcoJ2xvYWRlZCcpOyAvLyB0cnVlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYWN0b3JSZWYgVGhlIGFjdG9yIHJlZiB0byBzdWJzY3JpYmUgdG9cbiAqIEBwYXJhbSBwcmVkaWNhdGUgRGV0ZXJtaW5lcyBpZiBhIHZhbHVlIG1hdGNoZXMgdGhlIGNvbmRpdGlvbiB0byB3YWl0IGZvclxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IGV2ZW50dWFsbHkgcmVzb2x2ZXMgdG8gdGhlIGVtaXR0ZWQgdmFsdWUgdGhhdCBtYXRjaGVzXG4gKiAgIHRoZSBjb25kaXRpb25cbiAqL1xuZnVuY3Rpb24gd2FpdEZvcihhY3RvclJlZiwgcHJlZGljYXRlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJlc29sdmVkT3B0aW9ucyA9IHtcbiAgICAuLi5kZWZhdWx0V2FpdEZvck9wdGlvbnMsXG4gICAgLi4ub3B0aW9uc1xuICB9O1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgc2lnbmFsXG4gICAgfSA9IHJlc29sdmVkT3B0aW9ucztcbiAgICBpZiAoc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICByZWooc2lnbmFsLnJlYXNvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgaWYgKHJlc29sdmVkT3B0aW9ucy50aW1lb3V0IDwgMCkge1xuICAgICAgY29uc29sZS5lcnJvcignYHRpbWVvdXRgIHBhc3NlZCB0byBgd2FpdEZvcmAgaXMgbmVnYXRpdmUgYW5kIGl0IHdpbGwgcmVqZWN0IGl0cyBpbnRlcm5hbCBwcm9taXNlIGltbWVkaWF0ZWx5LicpO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGUgPSByZXNvbHZlZE9wdGlvbnMudGltZW91dCA9PT0gSW5maW5pdHkgPyB1bmRlZmluZWQgOiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGRpc3Bvc2UoKTtcbiAgICAgIHJlaihuZXcgRXJyb3IoYFRpbWVvdXQgb2YgJHtyZXNvbHZlZE9wdGlvbnMudGltZW91dH0gbXMgZXhjZWVkZWRgKSk7XG4gICAgfSwgcmVzb2x2ZWRPcHRpb25zLnRpbWVvdXQpO1xuICAgIGNvbnN0IGRpc3Bvc2UgPSAoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQoaGFuZGxlKTtcbiAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgc3ViPy51bnN1YnNjcmliZSgpO1xuICAgICAgaWYgKGFib3J0TGlzdGVuZXIpIHtcbiAgICAgICAgc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBjaGVja0VtaXR0ZWQoZW1pdHRlZCkge1xuICAgICAgaWYgKHByZWRpY2F0ZShlbWl0dGVkKSkge1xuICAgICAgICBkaXNwb3NlKCk7XG4gICAgICAgIHJlcyhlbWl0dGVkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgYHNpZ25hbGAgb3B0aW9uIGlzIHByb3ZpZGVkLCB0aGlzIHdpbGwgYmUgdGhlIGxpc3RlbmVyIGZvciBpdHNcbiAgICAgKiBgYWJvcnRgIGV2ZW50XG4gICAgICovXG4gICAgbGV0IGFib3J0TGlzdGVuZXI7XG4gICAgbGV0IHN1YjsgLy8gYXZvaWQgVERaIHdoZW4gZGlzcG9zaW5nIHN5bmNocm9ub3VzbHlcblxuICAgIC8vIFNlZSBpZiB0aGUgY3VycmVudCBzbmFwc2hvdCBhbHJlYWR5IG1hdGNoZXMgdGhlIHByZWRpY2F0ZVxuICAgIGNoZWNrRW1pdHRlZChhY3RvclJlZi5nZXRTbmFwc2hvdCgpKTtcbiAgICBpZiAoZG9uZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIG9ubHkgZGVmaW5lIHRoZSBgYWJvcnRMaXN0ZW5lcmAgaWYgdGhlIGBzaWduYWxgIG9wdGlvbiBpcyBwcm92aWRlZFxuICAgIGlmIChzaWduYWwpIHtcbiAgICAgIGFib3J0TGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgIGRpc3Bvc2UoKTtcbiAgICAgICAgLy8gWFN0YXRlIGRvZXMgbm90IFwib3duXCIgdGhlIHNpZ25hbCwgc28gd2Ugc2hvdWxkIHJlamVjdCB3aXRoIGl0cyByZWFzb24gKGlmIGFueSlcbiAgICAgICAgcmVqKHNpZ25hbC5yZWFzb24pO1xuICAgICAgfTtcbiAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0TGlzdGVuZXIpO1xuICAgIH1cbiAgICBzdWIgPSBhY3RvclJlZi5zdWJzY3JpYmUoe1xuICAgICAgbmV4dDogY2hlY2tFbWl0dGVkLFxuICAgICAgZXJyb3I6IGVyciA9PiB7XG4gICAgICAgIGRpc3Bvc2UoKTtcbiAgICAgICAgcmVqKGVycik7XG4gICAgICB9LFxuICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgZGlzcG9zZSgpO1xuICAgICAgICByZWoobmV3IEVycm9yKGBBY3RvciB0ZXJtaW5hdGVkIHdpdGhvdXQgc2F0aXNmeWluZyBwcmVkaWNhdGVgKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCB7IFNpbXVsYXRlZENsb2NrLCBTdGF0ZU1hY2hpbmUsIFN0YXRlTm9kZSwgYXNzZXJ0RXZlbnQsIGNyZWF0ZU1hY2hpbmUsIGdldEluaXRpYWxTbmFwc2hvdCwgZ2V0TmV4dFNuYXBzaG90LCBzZXR1cCwgdG9Qcm9taXNlLCB3YWl0Rm9yIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/xstate/dist/xstate.development.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@sanity/comlink/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@sanity/comlink/dist/index.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DOMAIN: function() { return /* binding */ DOMAIN; },\n/* harmony export */   HANDSHAKE_INTERVAL: function() { return /* binding */ HANDSHAKE_INTERVAL; },\n/* harmony export */   HANDSHAKE_MSG_TYPES: function() { return /* binding */ HANDSHAKE_MSG_TYPES; },\n/* harmony export */   HEARTBEAT_INTERVAL: function() { return /* binding */ HEARTBEAT_INTERVAL; },\n/* harmony export */   INTERNAL_MSG_TYPES: function() { return /* binding */ INTERNAL_MSG_TYPES; },\n/* harmony export */   MSG_DISCONNECT: function() { return /* binding */ MSG_DISCONNECT; },\n/* harmony export */   MSG_HANDSHAKE_ACK: function() { return /* binding */ MSG_HANDSHAKE_ACK; },\n/* harmony export */   MSG_HANDSHAKE_SYN: function() { return /* binding */ MSG_HANDSHAKE_SYN; },\n/* harmony export */   MSG_HANDSHAKE_SYN_ACK: function() { return /* binding */ MSG_HANDSHAKE_SYN_ACK; },\n/* harmony export */   MSG_HEARTBEAT: function() { return /* binding */ MSG_HEARTBEAT; },\n/* harmony export */   MSG_RESPONSE: function() { return /* binding */ MSG_RESPONSE; },\n/* harmony export */   RESPONSE_TIMEOUT: function() { return /* binding */ RESPONSE_TIMEOUT; },\n/* harmony export */   createChannel: function() { return /* binding */ createChannel; },\n/* harmony export */   createChannelMachine: function() { return /* binding */ createChannelMachine; },\n/* harmony export */   createController: function() { return /* binding */ createController; },\n/* harmony export */   createListenLogic: function() { return /* binding */ createListenLogic; },\n/* harmony export */   createNode: function() { return /* binding */ createNode; },\n/* harmony export */   createNodeMachine: function() { return /* binding */ createNodeMachine; },\n/* harmony export */   createRequestMachine: function() { return /* binding */ createRequestMachine; }\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! uuid */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/v4.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! xstate */ \"(app-pages-browser)/./node_modules/xstate/actors/dist/xstate-actors.development.esm.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! xstate */ \"(app-pages-browser)/./node_modules/xstate/dist/xstate.development.esm.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! xstate */ \"(app-pages-browser)/./node_modules/xstate/dist/log-38475d87.development.esm.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! xstate */ \"(app-pages-browser)/./node_modules/xstate/dist/raise-5ea71f04.development.esm.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rxjs */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/observable/defer.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/observable/fromEvent.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/map.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/util/pipe.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/filter.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/bufferCount.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! rxjs */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/concatMap.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! rxjs */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/take.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! rxjs */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/observable/empty.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! rxjs */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/takeUntil.js\");\n\n\n\nconst listenInputFromContext = (config) => ({\n  context\n}) => {\n  const { count, include, exclude, responseType = \"message.received\" } = config;\n  return {\n    count,\n    domain: context.domain,\n    from: context.connectTo,\n    include: include ? Array.isArray(include) ? include : [include] : [],\n    exclude: exclude ? Array.isArray(exclude) ? exclude : [exclude] : [],\n    responseType,\n    target: context.target,\n    to: context.name\n  };\n}, listenFilter = (input) => (event) => {\n  const { data } = event;\n  return (input.include.length ? input.include.includes(data.type) : !0) && (input.exclude.length ? !input.exclude.includes(data.type) : !0) && data.domain === input.domain && data.from === input.from && data.to === input.to && (!input.target || event.source === input.target);\n}, eventToMessage = (type) => (event) => ({\n  type,\n  message: event\n}), messageEvents$ = (0,rxjs__WEBPACK_IMPORTED_MODULE_0__.defer)(\n  () => (0,rxjs__WEBPACK_IMPORTED_MODULE_1__.fromEvent)(window, \"message\")\n), createListenLogic = (compatMap) => (0,xstate__WEBPACK_IMPORTED_MODULE_2__.fromEventObservable)(({ input }) => messageEvents$.pipe(\n  compatMap ? (0,rxjs__WEBPACK_IMPORTED_MODULE_3__.map)(compatMap) : (0,rxjs__WEBPACK_IMPORTED_MODULE_4__.pipe)(),\n  (0,rxjs__WEBPACK_IMPORTED_MODULE_5__.filter)(listenFilter(input)),\n  (0,rxjs__WEBPACK_IMPORTED_MODULE_3__.map)(eventToMessage(input.responseType)),\n  input.count ? (0,rxjs__WEBPACK_IMPORTED_MODULE_4__.pipe)(\n    (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.bufferCount)(input.count),\n    (0,rxjs__WEBPACK_IMPORTED_MODULE_7__.concatMap)((arr) => arr),\n    (0,rxjs__WEBPACK_IMPORTED_MODULE_8__.take)(input.count)\n  ) : (0,rxjs__WEBPACK_IMPORTED_MODULE_4__.pipe)()\n)), DOMAIN = \"sanity/comlink\", RESPONSE_TIMEOUT = 1e4, HEARTBEAT_INTERVAL = 1e3, HANDSHAKE_INTERVAL = 500, MSG_RESPONSE = \"comlink/response\", MSG_HEARTBEAT = \"comlink/heartbeat\", MSG_DISCONNECT = \"comlink/disconnect\", MSG_HANDSHAKE_SYN = \"comlink/handshake/syn\", MSG_HANDSHAKE_SYN_ACK = \"comlink/handshake/syn-ack\", MSG_HANDSHAKE_ACK = \"comlink/handshake/ack\", HANDSHAKE_MSG_TYPES = [\n  MSG_HANDSHAKE_SYN,\n  MSG_HANDSHAKE_SYN_ACK,\n  MSG_HANDSHAKE_ACK\n], INTERNAL_MSG_TYPES = [\n  MSG_RESPONSE,\n  MSG_DISCONNECT,\n  MSG_HEARTBEAT,\n  ...HANDSHAKE_MSG_TYPES\n], throwOnEvent = (message) => (source) => source.pipe(\n  (0,rxjs__WEBPACK_IMPORTED_MODULE_8__.take)(1),\n  (0,rxjs__WEBPACK_IMPORTED_MODULE_3__.map)(() => {\n    throw new Error(message);\n  })\n), createRequestMachine = () => (0,xstate__WEBPACK_IMPORTED_MODULE_9__.setup)({\n  types: {},\n  actors: {\n    listen: (0,xstate__WEBPACK_IMPORTED_MODULE_2__.fromEventObservable)(\n      ({\n        input\n      }) => {\n        const abortSignal$ = input.signal ? (0,rxjs__WEBPACK_IMPORTED_MODULE_1__.fromEvent)(input.signal, \"abort\").pipe(\n          throwOnEvent(`Request ${input.requestId} aborted`)\n        ) : rxjs__WEBPACK_IMPORTED_MODULE_10__.EMPTY, messageFilter = (event) => event.data?.type === MSG_RESPONSE && event.data?.responseTo === input.requestId && !!event.source && input.sources.has(event.source);\n        return (0,rxjs__WEBPACK_IMPORTED_MODULE_1__.fromEvent)(window, \"message\").pipe(\n          (0,rxjs__WEBPACK_IMPORTED_MODULE_5__.filter)(messageFilter),\n          (0,rxjs__WEBPACK_IMPORTED_MODULE_8__.take)(input.sources.size),\n          (0,rxjs__WEBPACK_IMPORTED_MODULE_11__.takeUntil)(abortSignal$)\n        );\n      }\n    )\n  },\n  actions: {\n    \"send message\": ({ context }, params) => {\n      const { sources, targetOrigin } = context, { message } = params;\n      sources.forEach((source) => {\n        source.postMessage(message, { targetOrigin });\n      });\n    },\n    \"on success\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.c)(\n      ({ context }) => context.parentRef,\n      ({ context, self }) => (context.response && context.resolvable?.resolve(context.response), {\n        type: \"request.success\",\n        requestId: self.id,\n        response: context.response,\n        responseTo: context.responseTo\n      })\n    ),\n    \"on fail\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.c)(\n      ({ context }) => context.parentRef,\n      ({ context, self }) => (context.suppressWarnings || console.warn(\n        `[@sanity/comlink] Received no response to message '${context.type}' on client '${context.from}' (ID: '${context.id}').`\n      ), context.resolvable?.reject(new Error(\"No response received\")), { type: \"request.failed\", requestId: self.id })\n    ),\n    \"on abort\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.c)(\n      ({ context }) => context.parentRef,\n      ({ context, self }) => (context.resolvable?.reject(new Error(\"Request aborted\")), { type: \"request.aborted\", requestId: self.id })\n    )\n  },\n  guards: {\n    expectsResponse: ({ context }) => context.expectResponse\n  },\n  delays: {\n    initialTimeout: 0,\n    responseTimeout: RESPONSE_TIMEOUT\n  }\n}).createMachine({\n  /** @xstate-layout N4IgpgJg5mDOIC5QAoC2BDAxgCwJYDswBKAOlwgBswBiAD1gBd0GwT0AzFgJ2QNwdzoKAFVyowAewCuDItTRY8hUuSoBtAAwBdRKAAOE2P1wT8ukLUQBGAEwBWEgBYAnK+eOAzB7sB2DzY8rABoQAE9rDQc3V0cNTw8fAA4NHwBfVJCFHAJiElgwfAgCKGpNHSQQAyMBU3NLBDsrDxI7DTaAjQA2OOcNDxDwhHsNJx9Ou0TOq2cJxP9HdMyMbOU8gqL8ErUrcv1DY1qK+sbm1vaPLp6+gcRnGydo9wDGycWQLKVc9AB3dGNN6jiWCwdAwMrmKoHMxHRCJRKOEiJHwuZKBZwXKzBMKIGyYkhtAkXOweTqOHw2RJvD45Ug-P4CAH0JgsNicMA8LhwAz4fKicTSWTyZafWm-f5QcEVSE1aGgepwhFIlF9aYYrGDC4+JzEppjGzOUkeGbpDIgfASCBwczU5QQ-YyuqIAC0nRuCBd+IJXu9KSpwppZEoYDt1RMsosiEcNjdVjiJEeGisiSTHkcVgWpptuXyhWKIahjqGzi1BqRJINnVcdkcbuTLS9VYC8ISfsUAbp4vzDphCHJIyjBvJNlxNmRNexQ3sJGH43GPj8jWJrZWuXYfyoEC7YcLsbrgRsjkcvkmdgNbopVhIPhVfnsh8ClMz-tWsCkmEwcHgUvt257u8v+6Hse4xnhOdZnImVidPqCRNB4JqpEAA */\n  context: ({ input }) => ({\n    connectionId: input.connectionId,\n    data: input.data,\n    domain: input.domain,\n    expectResponse: input.expectResponse ?? !1,\n    from: input.from,\n    id: `msg-${(0,uuid__WEBPACK_IMPORTED_MODULE_13__[\"default\"])()}`,\n    parentRef: input.parentRef,\n    resolvable: input.resolvable,\n    response: null,\n    responseTo: input.responseTo,\n    signal: input.signal,\n    sources: input.sources instanceof Set ? input.sources : /* @__PURE__ */ new Set([input.sources]),\n    suppressWarnings: input.suppressWarnings,\n    targetOrigin: input.targetOrigin,\n    to: input.to,\n    type: input.type\n  }),\n  initial: \"idle\",\n  on: {\n    abort: \".aborted\"\n  },\n  states: {\n    idle: {\n      after: {\n        initialTimeout: [\n          {\n            target: \"sending\"\n          }\n        ]\n      }\n    },\n    sending: {\n      entry: {\n        type: \"send message\",\n        params: ({ context }) => {\n          const { connectionId, data, domain, from, id, responseTo, to, type } = context;\n          return { message: {\n            connectionId,\n            data,\n            domain,\n            from,\n            id,\n            to,\n            type,\n            responseTo\n          } };\n        }\n      },\n      always: [\n        {\n          guard: \"expectsResponse\",\n          target: \"awaiting\"\n        },\n        \"success\"\n      ]\n    },\n    awaiting: {\n      invoke: {\n        id: \"listen for response\",\n        src: \"listen\",\n        input: ({ context }) => ({\n          requestId: context.id,\n          sources: context.sources,\n          signal: context.signal\n        }),\n        onError: \"aborted\"\n      },\n      after: {\n        responseTimeout: \"failed\"\n      },\n      on: {\n        message: {\n          actions: (0,xstate__WEBPACK_IMPORTED_MODULE_12__.a)({\n            response: ({ event }) => event.data.data,\n            responseTo: ({ event }) => event.data.responseTo\n          }),\n          target: \"success\"\n        }\n      }\n    },\n    failed: {\n      type: \"final\",\n      entry: \"on fail\"\n    },\n    success: {\n      type: \"final\",\n      entry: \"on success\"\n    },\n    aborted: {\n      type: \"final\",\n      entry: \"on abort\"\n    }\n  },\n  output: ({ context, self }) => ({\n    requestId: self.id,\n    response: context.response,\n    responseTo: context.responseTo\n  })\n}), sendBackAtInterval = (0,xstate__WEBPACK_IMPORTED_MODULE_2__.fromCallback)(({ sendBack, input }) => {\n  const send = () => {\n    sendBack(input.event);\n  };\n  input.immediate && send();\n  const interval = setInterval(send, input.interval);\n  return () => {\n    clearInterval(interval);\n  };\n}), createChannelMachine = () => (0,xstate__WEBPACK_IMPORTED_MODULE_9__.setup)({\n  types: {},\n  actors: {\n    requestMachine: createRequestMachine(),\n    listen: createListenLogic(),\n    sendBackAtInterval\n  },\n  actions: {\n    \"buffer message\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.b)(({ enqueue }) => {\n      enqueue.assign({\n        buffer: ({ event, context }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"post\"), [...context.buffer, event.data])\n      }), enqueue.emit(({ event }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"post\"), {\n        type: \"_buffer.added\",\n        message: event.data\n      }));\n    }),\n    \"create request\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.a)({\n      requests: ({ context, event, self, spawn }) => {\n        (0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"request\");\n        const requests = (Array.isArray(event.data) ? event.data : [event.data]).map((request) => {\n          const id = `req-${(0,uuid__WEBPACK_IMPORTED_MODULE_13__[\"default\"])()}`;\n          return spawn(\"requestMachine\", {\n            id,\n            input: {\n              connectionId: context.connectionId,\n              data: request.data,\n              domain: context.domain,\n              expectResponse: request.expectResponse,\n              from: context.name,\n              parentRef: self,\n              responseTo: request.responseTo,\n              sources: context.target,\n              targetOrigin: context.targetOrigin,\n              to: context.connectTo,\n              type: request.type\n            }\n          });\n        });\n        return [...context.requests, ...requests];\n      }\n    }),\n    \"emit received message\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.b)(({ enqueue }) => {\n      enqueue.emit(({ event }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"message.received\"), {\n        type: \"_message\",\n        message: event.message.data\n      })), enqueue.emit(({ event }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"message.received\"), {\n        type: event.message.data.type,\n        message: event.message.data\n      }));\n    }),\n    \"flush buffer\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.b)(({ enqueue }) => {\n      enqueue.raise(({ context }) => ({\n        type: \"request\",\n        data: context.buffer.map(({ data, type }) => ({ data, type }))\n      })), enqueue.emit(({ context }) => ({\n        type: \"_buffer.flushed\",\n        messages: context.buffer\n      })), enqueue.assign({\n        buffer: []\n      });\n    }),\n    post: (0,xstate__WEBPACK_IMPORTED_MODULE_14__.O)(({ event }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"post\"), {\n      type: \"request\",\n      data: {\n        data: event.data.data,\n        expectResponse: !0,\n        type: event.data.type\n      }\n    })),\n    \"remove request\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.b)(({ context, enqueue, event }) => {\n      (0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, [\"request.success\", \"request.failed\", \"request.aborted\"]), (0,xstate__WEBPACK_IMPORTED_MODULE_14__.R)(event.requestId), enqueue.assign({ requests: context.requests.filter(({ id }) => id !== event.requestId) });\n    }),\n    respond: (0,xstate__WEBPACK_IMPORTED_MODULE_14__.O)(({ event }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"response\"), {\n      type: \"request\",\n      data: {\n        data: event.data,\n        type: MSG_RESPONSE,\n        responseTo: event.respondTo\n      }\n    })),\n    \"send handshake ack\": (0,xstate__WEBPACK_IMPORTED_MODULE_14__.O)({\n      type: \"request\",\n      data: { type: MSG_HANDSHAKE_ACK }\n    }),\n    \"send disconnect\": (0,xstate__WEBPACK_IMPORTED_MODULE_14__.O)(() => ({\n      type: \"request\",\n      data: { type: MSG_DISCONNECT }\n    })),\n    \"send handshake syn\": (0,xstate__WEBPACK_IMPORTED_MODULE_14__.O)({\n      type: \"request\",\n      data: { type: MSG_HANDSHAKE_SYN }\n    }),\n    \"set target\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.a)({\n      target: ({ event }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"target.set\"), event.target)\n    })\n  },\n  guards: {\n    \"has target\": ({ context }) => !!context.target,\n    \"should send heartbeats\": ({ context }) => context.heartbeat\n  }\n}).createMachine({\n  /** @xstate-layout N4IgpgJg5mDOIC5QGMAWBDAdpsAbAxAC7oBOMhAdLGIQNoAMAuoqAA4D2sAloV+5ixAAPRAHZRAJgoAWABz0ArHICMy2QGZZCgJwAaEAE9EE+tIrb6ANgkLl46fTuj1AXxf60WHARJgAjgCucJSwAcjIcLAMzEggHNy8-IIiCKLS2hQS6qb2yurisrL6RgjK9LIyCuqq0g7WstZuHhjYePi+gcEUAGboXLiQ0YLxPHwCsSmiCgoykpayDtqS6trqxYjKEk0gnq24FFwQA-jI-DjIdEzDnKNJExuOZpZ12eq29OrSCuupypYUojUaTKCnm5Wk2123gORzA+HilxibBuiXGoBSGnUAIU4gU9FWamUtR+lmUM1EllBEkslMUEnpkJa0JaEFgGAA1lxMFB8LADJghrERqjkhtshk3mTtNo5OpqpYfqCKhTptoqpY1WUtu4dky8BQWWz0Jzue1-EFYIjrgkxqLSupqRRPpoPqJtLI0hIioZENJJE7NnJ8ZYHVk1YyvPrDRyuTyEYLkTa7uixVlMh81KGFhS1j6EPkZlpVjTphr8mkI3sDVhWTHTQBbSLoGAUXwRLgAN0GVyFKNt91KimUFEKXvKC2s9R+6X+jipnzJeSqEJ1UKjNaNJp5EC4sFOrQuCbifeTwg2cgoym0RPxDtqkj0eaB9Ao8zSolMEivZVcq71+33c5CEgeFOCtXskzRM8EDxKRpmkSw3QJbQsmpH5tHmV8JHSbJpDsakV2aSMALOMALhAjoLXAxNbiglI-SxWw1Vw0QNDw0Qfg9KQ7EJSxHHxApK2hQCyOAiAzVgDhMGoI9hX7FMEHSF8cWkelpHURCbBsb481xAEgT9BQJCmWQsiE-URPI8TG1gWBmzAVsyLATtuyRY9ILtWoKmlL82Kqd0tAVJ91LMHFZDKIkVlkNVZHMkiDzE-Adz3UjDx7GiRQHCKnheD53k+HSSkDDIwpBVTqQwuKKEssSDTAUhCAAI3qyg0DIrd8Fkk86MQUMnVM+RynoegTDJH48hGp0vR-FDRqqKqasgOqGua9AQjATAd1NSiul6fpXOtWi7Wy19cslD4vnG7IX3oVjVDUVYEJQqrksW8SdstLqPKy0wKgG1RhtMWogqKhoMjkWp6XxUyFBe3c3tAz70vco6fq+V8PTkGUFzdQqNnELEM2yClrwwzQ4ZShKQJqr7UYU98AS0W9pT4z5pHG0yXwMkNNTyGk3B1TB2AgOBBDXXBDsyhSFG9EovQqN5i1JeRcKqw4Bkl+ToMx8x0j+EaqQ9XMSkBURMgMkEwQWKro2NWNNdPFJAzN0lJGM4slDxhBEJfXyplBd03wW1KxIdnrBxBh4JAyW75C8rJpmDqmIGWkgmpasPjqUcaHooMLHA0uU1UkJOgKW1B6rT1bWor5At0zgcTAkK7hrz1irB0D8cW0UvRPLyv07WqgNq2qAG+l9SnXUz0UOXD5xuMs3Y4+DVJBX7UiKrV6Q8gcfoJO54rFefLLqfJYX1WKYNLxL4NO1NwgA */\n  id: \"channel\",\n  context: ({ input }) => ({\n    id: input.id || `${input.name}-${(0,uuid__WEBPACK_IMPORTED_MODULE_13__[\"default\"])()}`,\n    buffer: [],\n    connectionId: `cnx-${(0,uuid__WEBPACK_IMPORTED_MODULE_13__[\"default\"])()}`,\n    connectTo: input.connectTo,\n    domain: input.domain ?? DOMAIN,\n    heartbeat: input.heartbeat ?? !1,\n    name: input.name,\n    requests: [],\n    target: input.target,\n    targetOrigin: input.targetOrigin\n  }),\n  on: {\n    \"target.set\": {\n      actions: \"set target\"\n    },\n    \"request.success\": {\n      actions: \"remove request\"\n    },\n    \"request.failed\": {\n      actions: \"remove request\"\n    }\n  },\n  initial: \"idle\",\n  states: {\n    idle: {\n      on: {\n        connect: {\n          target: \"handshaking\",\n          guard: \"has target\"\n        },\n        post: {\n          actions: \"buffer message\"\n        }\n      }\n    },\n    handshaking: {\n      id: \"handshaking\",\n      invoke: [\n        {\n          id: \"send syn\",\n          src: \"sendBackAtInterval\",\n          input: () => ({\n            event: { type: \"syn\" },\n            interval: HANDSHAKE_INTERVAL,\n            immediate: !0\n          })\n        },\n        {\n          id: \"listen for handshake\",\n          src: \"listen\",\n          input: (input) => listenInputFromContext({\n            include: MSG_HANDSHAKE_SYN_ACK,\n            count: 1\n          })(input)\n          /* Below would maybe be more readable than transitioning to\n          'connected' on 'message', and 'ack' on exit but having onDone when\n          using passing invocations currently breaks XState Editor */\n          // onDone: {\n          //   target: 'connected',\n          //   actions: 'ack',\n          // },\n        }\n      ],\n      on: {\n        syn: {\n          actions: \"send handshake syn\"\n        },\n        request: {\n          actions: \"create request\"\n        },\n        post: {\n          actions: \"buffer message\"\n        },\n        \"message.received\": {\n          target: \"connected\"\n        },\n        disconnect: {\n          target: \"disconnected\"\n        }\n      },\n      exit: \"send handshake ack\"\n    },\n    connected: {\n      entry: \"flush buffer\",\n      invoke: {\n        id: \"listen for messages\",\n        src: \"listen\",\n        input: listenInputFromContext({\n          exclude: [MSG_RESPONSE, MSG_HEARTBEAT]\n        })\n      },\n      on: {\n        post: {\n          actions: \"post\"\n        },\n        request: {\n          actions: \"create request\"\n        },\n        response: {\n          actions: \"respond\"\n        },\n        \"message.received\": {\n          actions: \"emit received message\"\n        },\n        disconnect: {\n          target: \"disconnected\"\n        }\n      },\n      initial: \"heartbeat\",\n      states: {\n        heartbeat: {\n          initial: \"checking\",\n          states: {\n            checking: {\n              always: {\n                guard: \"should send heartbeats\",\n                target: \"sending\"\n              }\n            },\n            sending: {\n              on: {\n                \"request.failed\": {\n                  target: \"#handshaking\"\n                }\n              },\n              invoke: {\n                id: \"send heartbeat\",\n                src: \"sendBackAtInterval\",\n                input: () => ({\n                  event: { type: \"post\", data: { type: MSG_HEARTBEAT, data: void 0 } },\n                  interval: 2e3,\n                  immediate: !1\n                })\n              }\n            }\n          }\n        }\n      }\n    },\n    disconnected: {\n      id: \"disconnected\",\n      entry: \"send disconnect\",\n      on: {\n        request: {\n          actions: \"create request\"\n        },\n        post: {\n          actions: \"buffer message\"\n        },\n        connect: {\n          target: \"handshaking\",\n          guard: \"has target\"\n        }\n      }\n    }\n  }\n}), createChannel = (input, machine = createChannelMachine()) => {\n  const id = input.id || `${input.name}-${(0,uuid__WEBPACK_IMPORTED_MODULE_13__[\"default\"])()}`, actor = (0,xstate__WEBPACK_IMPORTED_MODULE_14__.A)(machine, {\n    input: { ...input, id }\n  }), on = (type, handler) => {\n    const { unsubscribe } = actor.on(\n      // @ts-expect-error @todo `type` typing\n      type,\n      async (event) => {\n        const response = await handler(event.message.data);\n        response && actor.send({ type: \"response\", respondTo: event.message.id, data: response });\n      }\n    );\n    return unsubscribe;\n  }, connect = () => {\n    actor.send({ type: \"connect\" });\n  }, disconnect = () => {\n    actor.send({ type: \"disconnect\" });\n  }, onStatus = (handler) => {\n    const currentSnapshot = actor.getSnapshot();\n    let currentStatus = typeof currentSnapshot.value == \"string\" ? currentSnapshot.value : Object.keys(currentSnapshot.value)[0];\n    const { unsubscribe } = actor.subscribe((state) => {\n      const status = typeof state.value == \"string\" ? state.value : Object.keys(state.value)[0];\n      currentStatus !== status && (currentStatus = status, handler(status));\n    });\n    return unsubscribe;\n  }, setTarget = (target) => {\n    actor.send({ type: \"target.set\", target });\n  }, post = (data) => {\n    actor.send({ type: \"post\", data });\n  }, stop = () => {\n    actor.stop();\n  }, start = () => (actor.start(), stop);\n  return {\n    actor,\n    connect,\n    disconnect,\n    id,\n    name: input.name,\n    machine,\n    on,\n    onStatus,\n    post,\n    setTarget,\n    start,\n    stop,\n    get target() {\n      return actor.getSnapshot().context.target;\n    }\n  };\n}, noop = () => {\n}, createController = (input) => {\n  const { targetOrigin } = input, targets = /* @__PURE__ */ new Set(), connections = /* @__PURE__ */ new Set(), addTarget = (target) => {\n    if (targets.has(target))\n      return noop;\n    if (!targets.size || !connections.size)\n      return targets.add(target), connections.forEach((connection) => {\n        connection.channels.forEach((channel) => {\n          channel.setTarget(target), channel.connect();\n        });\n      }), () => {\n        targets.delete(target), connections.forEach((connection) => {\n          connection.channels.forEach((channel) => {\n            channel.target === target && channel.disconnect();\n          });\n        });\n      };\n    targets.add(target);\n    const targetChannels = /* @__PURE__ */ new Set();\n    return connections.forEach((connection) => {\n      const channel = createChannel(\n        {\n          ...connection.input,\n          target,\n          targetOrigin\n        },\n        connection.machine\n      );\n      targetChannels.add(channel), connection.channels.add(channel), connection.subscribers.forEach(({ type, handler, unsubscribers }) => {\n        unsubscribers.push(channel.on(type, handler));\n      }), connection.internalEventSubscribers.forEach(({ type, handler, unsubscribers }) => {\n        unsubscribers.push(channel.actor.on(type, handler).unsubscribe);\n      }), connection.statusSubscribers.forEach(({ handler, unsubscribers }) => {\n        unsubscribers.push(channel.onStatus((status) => handler({ channel: channel.id, status })));\n      }), channel.start(), channel.connect();\n    }), () => {\n      targets.delete(target), targetChannels.forEach((channel) => {\n        cleanupChannel(channel), connections.forEach((connection) => {\n          connection.channels.delete(channel);\n        });\n      });\n    };\n  }, cleanupChannel = (channel) => {\n    channel.disconnect(), setTimeout(() => {\n      channel.stop();\n    }, 0);\n  };\n  return {\n    addTarget,\n    createConnection: (input2, machine = createChannelMachine()) => {\n      const connection = {\n        channels: /* @__PURE__ */ new Set(),\n        input: input2,\n        internalEventSubscribers: /* @__PURE__ */ new Set(),\n        machine,\n        statusSubscribers: /* @__PURE__ */ new Set(),\n        subscribers: /* @__PURE__ */ new Set()\n      };\n      connections.add(connection);\n      const { channels, internalEventSubscribers, statusSubscribers, subscribers } = connection;\n      if (targets.size)\n        targets.forEach((target) => {\n          const channel = createChannel(\n            {\n              ...input2,\n              target,\n              targetOrigin\n            },\n            machine\n          );\n          channels.add(channel);\n        });\n      else {\n        const channel = createChannel({ ...input2, targetOrigin }, machine);\n        channels.add(channel);\n      }\n      const post = (data) => {\n        channels.forEach((channel) => {\n          channel.post(data);\n        });\n      }, on = (type, handler) => {\n        const unsubscribers = [];\n        channels.forEach((channel) => {\n          unsubscribers.push(channel.on(type, handler));\n        });\n        const subscriber = { type, handler, unsubscribers };\n        return subscribers.add(subscriber), () => {\n          unsubscribers.forEach((unsub) => unsub()), subscribers.delete(subscriber);\n        };\n      }, onInternalEvent = (type, handler) => {\n        const unsubscribers = [];\n        channels.forEach((channel) => {\n          unsubscribers.push(channel.actor.on(type, handler).unsubscribe);\n        });\n        const subscriber = { type, handler, unsubscribers };\n        return internalEventSubscribers.add(subscriber), () => {\n          unsubscribers.forEach((unsub) => unsub()), internalEventSubscribers.delete(subscriber);\n        };\n      }, onStatus = (handler) => {\n        const unsubscribers = [];\n        channels.forEach((channel) => {\n          unsubscribers.push(channel.onStatus((status) => handler({ channel: channel.id, status })));\n        });\n        const subscriber = { handler, unsubscribers };\n        return statusSubscribers.add(subscriber), () => {\n          unsubscribers.forEach((unsub) => unsub()), statusSubscribers.delete(subscriber);\n        };\n      }, stop = () => {\n        channels.forEach((channel) => {\n          channel.disconnect(), channel.stop();\n        });\n      };\n      return {\n        on,\n        onInternalEvent,\n        onStatus,\n        post,\n        start: () => (channels.forEach((channel) => {\n          channel.start(), channel.connect();\n        }), stop),\n        stop\n      };\n    },\n    destroy: () => {\n      connections.forEach(({ channels }) => {\n        channels.forEach((channel) => {\n          cleanupChannel(channel), channels.delete(channel);\n        });\n      });\n    }\n  };\n}, createNodeMachine = () => (0,xstate__WEBPACK_IMPORTED_MODULE_9__.setup)({\n  types: {},\n  actors: {\n    requestMachine: createRequestMachine(),\n    listen: createListenLogic()\n  },\n  actions: {\n    \"buffer incoming message\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.a)({\n      handshakeBuffer: ({ event, context }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"message.received\"), [...context.handshakeBuffer, event])\n    }),\n    \"buffer message\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.b)(({ enqueue }) => {\n      enqueue.assign({\n        buffer: ({ event, context }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"post\"), [\n          ...context.buffer,\n          {\n            data: event.data,\n            resolvable: event.resolvable,\n            options: event.options\n          }\n        ])\n      }), enqueue.emit(({ event }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"post\"), {\n        type: \"_buffer.added\",\n        message: event.data\n      }));\n    }),\n    \"create request\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.a)({\n      requests: ({ context, event, self, spawn }) => {\n        (0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"request\");\n        const requests = (Array.isArray(event.data) ? event.data : [event.data]).map((request) => {\n          const id = `req-${(0,uuid__WEBPACK_IMPORTED_MODULE_13__[\"default\"])()}`;\n          return spawn(\"requestMachine\", {\n            id,\n            input: {\n              connectionId: context.connectionId,\n              data: request.data,\n              domain: context.domain,\n              expectResponse: request.expectResponse,\n              from: context.name,\n              parentRef: self,\n              resolvable: request.resolvable,\n              responseTo: request.responseTo,\n              signal: request.options?.signal,\n              sources: context.target,\n              suppressWarnings: request.options?.suppressWarnings,\n              targetOrigin: context.targetOrigin,\n              to: context.connectTo,\n              type: request.type\n            }\n          });\n        });\n        return [...context.requests, ...requests];\n      }\n    }),\n    \"emit heartbeat\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.e)(() => ({\n      type: \"_heartbeat\"\n    })),\n    \"emit received message\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.b)(({ enqueue }) => {\n      enqueue.emit(({ event }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"message.received\"), {\n        type: \"_message\",\n        message: event.message.data\n      })), enqueue.emit(({ event }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"message.received\"), {\n        type: event.message.data.type,\n        message: event.message.data\n      }));\n    }),\n    \"flush buffer\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.b)(({ enqueue }) => {\n      enqueue.raise(({ context }) => ({\n        type: \"request\",\n        data: context.buffer.map(({ data, resolvable, options }) => ({\n          data: data.data,\n          type: data.type,\n          expectResponse: !!resolvable,\n          resolvable,\n          options\n        }))\n      })), enqueue.emit(({ context }) => ({\n        type: \"_buffer.flushed\",\n        messages: context.buffer.map(({ data }) => data)\n      })), enqueue.assign({\n        buffer: []\n      });\n    }),\n    \"flush handshake buffer\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.b)(({ context, enqueue }) => {\n      context.handshakeBuffer.forEach((event) => enqueue.raise(event)), enqueue.assign({\n        handshakeBuffer: []\n      });\n    }),\n    post: (0,xstate__WEBPACK_IMPORTED_MODULE_14__.O)(({ event }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"post\"), {\n      type: \"request\",\n      data: {\n        data: event.data.data,\n        expectResponse: !!event.resolvable,\n        type: event.data.type,\n        resolvable: event.resolvable,\n        options: event.options\n      }\n    })),\n    \"remove request\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.b)(({ context, enqueue, event }) => {\n      (0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, [\"request.success\", \"request.failed\", \"request.aborted\"]), (0,xstate__WEBPACK_IMPORTED_MODULE_14__.R)(event.requestId), enqueue.assign({ requests: context.requests.filter(({ id }) => id !== event.requestId) });\n    }),\n    \"send response\": (0,xstate__WEBPACK_IMPORTED_MODULE_14__.O)(({ event }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, [\"message.received\", \"heartbeat.received\"]), {\n      type: \"request\",\n      data: {\n        type: MSG_RESPONSE,\n        responseTo: event.message.data.id,\n        data: void 0\n      }\n    })),\n    \"send handshake syn ack\": (0,xstate__WEBPACK_IMPORTED_MODULE_14__.O)({\n      type: \"request\",\n      data: { type: MSG_HANDSHAKE_SYN_ACK }\n    }),\n    \"set connection config\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.a)({\n      connectionId: ({ event }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"message.received\"), event.message.data.connectionId),\n      target: ({ event }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"message.received\"), event.message.source || void 0),\n      targetOrigin: ({ event }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"message.received\"), event.message.origin)\n    })\n  },\n  guards: {\n    hasSource: ({ context }) => context.target !== null\n  }\n}).createMachine({\n  /** @xstate-layout N4IgpgJg5mDOIC5QDsD2EwGIBOYCOArnAC4B0sBAxpXLANoAMAuoqAA6qwCWxXqyrEAA9EAVgYAWUgEYJDUQA4JAZmUSJC0coDsAGhABPRNIYLSErdOkBOAGzbx227YUBfV-rQYc+IrDIAZgCGXAA2kIwsSCAc3Lz8giIIoiakqgBMDKbp2tYS0srp+kYI0ununuhgpFwQ4ZgQ-NVcyABuqADW1V7NdWAILe2UQfHIkZGCsTx8AtFJ6aKipAzWOtrpC7Z5BUWGiNoK6aS26RLW2tLaqkqqFSA9NX2YALa0QTCkuDRcrRHMk5xpgk5ogJLZSNZIVDoVCFLZiohbIVSLkXLZRHZDgxbHcHrV6rFiBNolNRolEVJbCsdGUzsoyhiEcllOC1DowelVmVrOUPPcqqQABZBZAQWDCjotKANJo1NqdboC4Wi8VBSXIKADeXDUbjf4kwFkkEILbg8RZMHKOzWKzKJkHJa086Xa4qZS4pUisUSqU+QgkYnsQ0zcnJaRLDbpZwKNQSBYspm2MEyC5KTnaDSSd18h7K71q32EwMxYPA0BJFLKY5yZxIrKSURM0RnFHSBTrQqQ9babQejBCr2q9XSiBcWCUfjIMCUIn6oNxEPGtTWFFR0RUy7iGzt+3Ip0XURXVZKPvVCfIKczyB+vyzqLzoGzcuIG0MGTyCztjRtjaJjbHVMNAUTdu1PUhz0vYhryLOcSwXMthBfK0ZGsLQGBZekCi0Jso1IdI23WG04zOE4wIg6coIgBox3Imdi1JRdnxNOxSHNSQkWtW0mTjMxMQ7fDzgcbNKn7WjKJeN4Pi+MAfj+e84MfUMFHbZZwxOHZNDyO09gQOQjmAhZJCM9IMjIycKOvQUwCCbBiAAI2sshpNkiB6NLJ9EIQBQbWOdJlMhYCUjbJkchXGsFmsJQMVsWl3BzKp4GiHoAXgjykgAWmkZZ6xy3LZF2EobCy6xsQWJQ42kE4FjA-EwBSxTjSRUhDgqkzgO2BxdykU4AvXFQ-KjMC8yHKV6qNJi6WOdcypcZsXGxe0JG0XySKjM5lKsMyLwsiAxsYzylDfONznUEqrmi+1ThkHqXDONbULi1wgA */\n  id: \"node\",\n  context: ({ input }) => ({\n    buffer: [],\n    connectionId: null,\n    connectTo: input.connectTo,\n    domain: input.domain ?? DOMAIN,\n    handshakeBuffer: [],\n    name: input.name,\n    requests: [],\n    target: void 0,\n    targetOrigin: null\n  }),\n  on: {\n    \"request.success\": {\n      actions: \"remove request\"\n    },\n    \"request.failed\": {\n      actions: \"remove request\"\n    },\n    \"request.aborted\": {\n      actions: \"remove request\"\n    }\n  },\n  initial: \"idle\",\n  states: {\n    idle: {\n      invoke: {\n        id: \"listen for handshake syn\",\n        src: \"listen\",\n        input: listenInputFromContext({\n          include: MSG_HANDSHAKE_SYN,\n          count: 1\n        }),\n        onDone: {\n          target: \"handshaking\",\n          guard: \"hasSource\"\n        }\n      },\n      on: {\n        \"message.received\": {\n          actions: \"set connection config\"\n        },\n        post: {\n          actions: \"buffer message\"\n        }\n      }\n    },\n    handshaking: {\n      entry: \"send handshake syn ack\",\n      invoke: [\n        {\n          id: \"listen for handshake ack\",\n          src: \"listen\",\n          input: listenInputFromContext({\n            include: MSG_HANDSHAKE_ACK,\n            count: 1,\n            // Override the default `message.received` responseType to prevent\n            // buffering the ack message. We transition to the connected state\n            // using onDone instead of listening to this event using `on`\n            responseType: \"handshake.complete\"\n          }),\n          onDone: \"connected\"\n        },\n        {\n          id: \"listen for disconnect\",\n          src: \"listen\",\n          input: listenInputFromContext({\n            include: MSG_DISCONNECT,\n            count: 1,\n            responseType: \"disconnect\"\n          })\n        },\n        {\n          id: \"listen for messages\",\n          src: \"listen\",\n          input: listenInputFromContext({\n            exclude: [MSG_DISCONNECT, MSG_HANDSHAKE_ACK, MSG_HEARTBEAT, MSG_RESPONSE]\n          })\n        }\n      ],\n      on: {\n        request: {\n          actions: \"create request\"\n        },\n        post: {\n          actions: \"buffer message\"\n        },\n        \"message.received\": {\n          actions: \"buffer incoming message\"\n        },\n        disconnect: {\n          target: \"idle\"\n        }\n      }\n    },\n    connected: {\n      entry: [\"flush handshake buffer\", \"flush buffer\"],\n      invoke: [\n        {\n          id: \"listen for messages\",\n          src: \"listen\",\n          input: listenInputFromContext({\n            exclude: [MSG_RESPONSE, MSG_HEARTBEAT]\n          })\n        },\n        {\n          id: \"listen for heartbeat\",\n          src: \"listen\",\n          input: listenInputFromContext({\n            include: MSG_HEARTBEAT,\n            responseType: \"heartbeat.received\"\n          })\n        },\n        {\n          id: \"listen for disconnect\",\n          src: \"listen\",\n          input: listenInputFromContext({\n            include: MSG_DISCONNECT,\n            count: 1,\n            responseType: \"disconnect\"\n          })\n        }\n      ],\n      on: {\n        request: {\n          actions: \"create request\"\n        },\n        post: {\n          actions: \"post\"\n        },\n        disconnect: {\n          target: \"idle\"\n        },\n        \"message.received\": {\n          actions: [\"send response\", \"emit received message\"]\n        },\n        \"heartbeat.received\": {\n          actions: [\"send response\", \"emit heartbeat\"]\n        }\n      }\n    }\n  }\n}), createNode = (input, machine = createNodeMachine()) => {\n  const actor = (0,xstate__WEBPACK_IMPORTED_MODULE_14__.A)(machine, {\n    input\n  }), on = (type, handler) => {\n    const { unsubscribe } = actor.on(\n      // @ts-expect-error @todo `type` typing\n      type,\n      (event) => {\n        handler(event.message.data);\n      }\n    );\n    return unsubscribe;\n  }, onStatus = (handler) => {\n    const snapshot = actor.getSnapshot();\n    let currentStatus = typeof snapshot.value == \"string\" ? snapshot.value : Object.keys(snapshot.value)[0];\n    const { unsubscribe } = actor.subscribe((state) => {\n      const status = typeof state.value == \"string\" ? state.value : Object.keys(state.value)[0];\n      currentStatus !== status && (currentStatus = status, handler(status));\n    });\n    return unsubscribe;\n  }, post = (data) => {\n    actor.send({ type: \"post\", data });\n  }, fetch = (data, options) => {\n    const resolvable = Promise.withResolvers();\n    return actor.send({\n      type: \"post\",\n      data,\n      resolvable,\n      options\n    }), resolvable.promise;\n  }, stop = () => {\n    actor.stop();\n  };\n  return {\n    actor,\n    fetch,\n    machine,\n    on,\n    onStatus,\n    post,\n    start: () => (actor.start(), stop),\n    stop\n  };\n};\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2NvbWxpbmsvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTBCO0FBQzBIO0FBQ3pDO0FBQzNHO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsVUFBVSw2REFBNkQ7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsVUFBVSxPQUFPO0FBQ2pCO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQiwyQ0FBSztBQUMxQixRQUFRLCtDQUFTO0FBQ2pCLHNDQUFzQywyREFBbUIsSUFBSSxPQUFPO0FBQ3BFLGNBQWMseUNBQUcsY0FBYywwQ0FBSTtBQUNuQyxFQUFFLDRDQUFNO0FBQ1IsRUFBRSx5Q0FBRztBQUNMLGdCQUFnQiwwQ0FBSTtBQUNwQixJQUFJLGlEQUFXO0FBQ2YsSUFBSSwrQ0FBUztBQUNiLElBQUksMENBQUk7QUFDUixNQUFNLDBDQUFJO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLDBDQUFJO0FBQ04sRUFBRSx5Q0FBRztBQUNMO0FBQ0EsR0FBRztBQUNILGdDQUFnQyw2Q0FBSztBQUNyQyxXQUFXO0FBQ1g7QUFDQSxZQUFZLDJEQUFtQjtBQUMvQjtBQUNBO0FBQ0EsT0FBTztBQUNQLDRDQUE0QywrQ0FBUztBQUNyRCxrQ0FBa0MsaUJBQWlCO0FBQ25ELFlBQVksd0NBQUs7QUFDakIsZUFBZSwrQ0FBUztBQUN4QixVQUFVLDRDQUFNO0FBQ2hCLFVBQVUsMENBQUk7QUFDZCxVQUFVLGdEQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDLGNBQWMsd0JBQXdCLGFBQWEsVUFBVTtBQUM3RDtBQUNBLHNDQUFzQyxjQUFjO0FB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QUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFxQkU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jb21saW5rL2Rpc3QvaW5kZXguanM/YzUwNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB2NCB9IGZyb20gXCJ1dWlkXCI7XG5pbXBvcnQgeyBmcm9tRXZlbnRPYnNlcnZhYmxlLCBzZXR1cCwgc2VuZFRvLCBhc3NpZ24sIGZyb21DYWxsYmFjaywgZW5xdWV1ZUFjdGlvbnMsIGFzc2VydEV2ZW50LCByYWlzZSwgc3RvcENoaWxkLCBjcmVhdGVBY3RvciwgZW1pdCB9IGZyb20gXCJ4c3RhdGVcIjtcbmltcG9ydCB7IGRlZmVyLCBmcm9tRXZlbnQsIG1hcCwgcGlwZSwgZmlsdGVyLCBidWZmZXJDb3VudCwgY29uY2F0TWFwLCB0YWtlLCBFTVBUWSwgdGFrZVVudGlsIH0gZnJvbSBcInJ4anNcIjtcbmNvbnN0IGxpc3RlbklucHV0RnJvbUNvbnRleHQgPSAoY29uZmlnKSA9PiAoe1xuICBjb250ZXh0XG59KSA9PiB7XG4gIGNvbnN0IHsgY291bnQsIGluY2x1ZGUsIGV4Y2x1ZGUsIHJlc3BvbnNlVHlwZSA9IFwibWVzc2FnZS5yZWNlaXZlZFwiIH0gPSBjb25maWc7XG4gIHJldHVybiB7XG4gICAgY291bnQsXG4gICAgZG9tYWluOiBjb250ZXh0LmRvbWFpbixcbiAgICBmcm9tOiBjb250ZXh0LmNvbm5lY3RUbyxcbiAgICBpbmNsdWRlOiBpbmNsdWRlID8gQXJyYXkuaXNBcnJheShpbmNsdWRlKSA/IGluY2x1ZGUgOiBbaW5jbHVkZV0gOiBbXSxcbiAgICBleGNsdWRlOiBleGNsdWRlID8gQXJyYXkuaXNBcnJheShleGNsdWRlKSA/IGV4Y2x1ZGUgOiBbZXhjbHVkZV0gOiBbXSxcbiAgICByZXNwb25zZVR5cGUsXG4gICAgdGFyZ2V0OiBjb250ZXh0LnRhcmdldCxcbiAgICB0bzogY29udGV4dC5uYW1lXG4gIH07XG59LCBsaXN0ZW5GaWx0ZXIgPSAoaW5wdXQpID0+IChldmVudCkgPT4ge1xuICBjb25zdCB7IGRhdGEgfSA9IGV2ZW50O1xuICByZXR1cm4gKGlucHV0LmluY2x1ZGUubGVuZ3RoID8gaW5wdXQuaW5jbHVkZS5pbmNsdWRlcyhkYXRhLnR5cGUpIDogITApICYmIChpbnB1dC5leGNsdWRlLmxlbmd0aCA/ICFpbnB1dC5leGNsdWRlLmluY2x1ZGVzKGRhdGEudHlwZSkgOiAhMCkgJiYgZGF0YS5kb21haW4gPT09IGlucHV0LmRvbWFpbiAmJiBkYXRhLmZyb20gPT09IGlucHV0LmZyb20gJiYgZGF0YS50byA9PT0gaW5wdXQudG8gJiYgKCFpbnB1dC50YXJnZXQgfHwgZXZlbnQuc291cmNlID09PSBpbnB1dC50YXJnZXQpO1xufSwgZXZlbnRUb01lc3NhZ2UgPSAodHlwZSkgPT4gKGV2ZW50KSA9PiAoe1xuICB0eXBlLFxuICBtZXNzYWdlOiBldmVudFxufSksIG1lc3NhZ2VFdmVudHMkID0gZGVmZXIoXG4gICgpID0+IGZyb21FdmVudCh3aW5kb3csIFwibWVzc2FnZVwiKVxuKSwgY3JlYXRlTGlzdGVuTG9naWMgPSAoY29tcGF0TWFwKSA9PiBmcm9tRXZlbnRPYnNlcnZhYmxlKCh7IGlucHV0IH0pID0+IG1lc3NhZ2VFdmVudHMkLnBpcGUoXG4gIGNvbXBhdE1hcCA/IG1hcChjb21wYXRNYXApIDogcGlwZSgpLFxuICBmaWx0ZXIobGlzdGVuRmlsdGVyKGlucHV0KSksXG4gIG1hcChldmVudFRvTWVzc2FnZShpbnB1dC5yZXNwb25zZVR5cGUpKSxcbiAgaW5wdXQuY291bnQgPyBwaXBlKFxuICAgIGJ1ZmZlckNvdW50KGlucHV0LmNvdW50KSxcbiAgICBjb25jYXRNYXAoKGFycikgPT4gYXJyKSxcbiAgICB0YWtlKGlucHV0LmNvdW50KVxuICApIDogcGlwZSgpXG4pKSwgRE9NQUlOID0gXCJzYW5pdHkvY29tbGlua1wiLCBSRVNQT05TRV9USU1FT1VUID0gMWU0LCBIRUFSVEJFQVRfSU5URVJWQUwgPSAxZTMsIEhBTkRTSEFLRV9JTlRFUlZBTCA9IDUwMCwgTVNHX1JFU1BPTlNFID0gXCJjb21saW5rL3Jlc3BvbnNlXCIsIE1TR19IRUFSVEJFQVQgPSBcImNvbWxpbmsvaGVhcnRiZWF0XCIsIE1TR19ESVNDT05ORUNUID0gXCJjb21saW5rL2Rpc2Nvbm5lY3RcIiwgTVNHX0hBTkRTSEFLRV9TWU4gPSBcImNvbWxpbmsvaGFuZHNoYWtlL3N5blwiLCBNU0dfSEFORFNIQUtFX1NZTl9BQ0sgPSBcImNvbWxpbmsvaGFuZHNoYWtlL3N5bi1hY2tcIiwgTVNHX0hBTkRTSEFLRV9BQ0sgPSBcImNvbWxpbmsvaGFuZHNoYWtlL2Fja1wiLCBIQU5EU0hBS0VfTVNHX1RZUEVTID0gW1xuICBNU0dfSEFORFNIQUtFX1NZTixcbiAgTVNHX0hBTkRTSEFLRV9TWU5fQUNLLFxuICBNU0dfSEFORFNIQUtFX0FDS1xuXSwgSU5URVJOQUxfTVNHX1RZUEVTID0gW1xuICBNU0dfUkVTUE9OU0UsXG4gIE1TR19ESVNDT05ORUNULFxuICBNU0dfSEVBUlRCRUFULFxuICAuLi5IQU5EU0hBS0VfTVNHX1RZUEVTXG5dLCB0aHJvd09uRXZlbnQgPSAobWVzc2FnZSkgPT4gKHNvdXJjZSkgPT4gc291cmNlLnBpcGUoXG4gIHRha2UoMSksXG4gIG1hcCgoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9KVxuKSwgY3JlYXRlUmVxdWVzdE1hY2hpbmUgPSAoKSA9PiBzZXR1cCh7XG4gIHR5cGVzOiB7fSxcbiAgYWN0b3JzOiB7XG4gICAgbGlzdGVuOiBmcm9tRXZlbnRPYnNlcnZhYmxlKFxuICAgICAgKHtcbiAgICAgICAgaW5wdXRcbiAgICAgIH0pID0+IHtcbiAgICAgICAgY29uc3QgYWJvcnRTaWduYWwkID0gaW5wdXQuc2lnbmFsID8gZnJvbUV2ZW50KGlucHV0LnNpZ25hbCwgXCJhYm9ydFwiKS5waXBlKFxuICAgICAgICAgIHRocm93T25FdmVudChgUmVxdWVzdCAke2lucHV0LnJlcXVlc3RJZH0gYWJvcnRlZGApXG4gICAgICAgICkgOiBFTVBUWSwgbWVzc2FnZUZpbHRlciA9IChldmVudCkgPT4gZXZlbnQuZGF0YT8udHlwZSA9PT0gTVNHX1JFU1BPTlNFICYmIGV2ZW50LmRhdGE/LnJlc3BvbnNlVG8gPT09IGlucHV0LnJlcXVlc3RJZCAmJiAhIWV2ZW50LnNvdXJjZSAmJiBpbnB1dC5zb3VyY2VzLmhhcyhldmVudC5zb3VyY2UpO1xuICAgICAgICByZXR1cm4gZnJvbUV2ZW50KHdpbmRvdywgXCJtZXNzYWdlXCIpLnBpcGUoXG4gICAgICAgICAgZmlsdGVyKG1lc3NhZ2VGaWx0ZXIpLFxuICAgICAgICAgIHRha2UoaW5wdXQuc291cmNlcy5zaXplKSxcbiAgICAgICAgICB0YWtlVW50aWwoYWJvcnRTaWduYWwkKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIClcbiAgfSxcbiAgYWN0aW9uczoge1xuICAgIFwic2VuZCBtZXNzYWdlXCI6ICh7IGNvbnRleHQgfSwgcGFyYW1zKSA9PiB7XG4gICAgICBjb25zdCB7IHNvdXJjZXMsIHRhcmdldE9yaWdpbiB9ID0gY29udGV4dCwgeyBtZXNzYWdlIH0gPSBwYXJhbXM7XG4gICAgICBzb3VyY2VzLmZvckVhY2goKHNvdXJjZSkgPT4ge1xuICAgICAgICBzb3VyY2UucG9zdE1lc3NhZ2UobWVzc2FnZSwgeyB0YXJnZXRPcmlnaW4gfSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIFwib24gc3VjY2Vzc1wiOiBzZW5kVG8oXG4gICAgICAoeyBjb250ZXh0IH0pID0+IGNvbnRleHQucGFyZW50UmVmLFxuICAgICAgKHsgY29udGV4dCwgc2VsZiB9KSA9PiAoY29udGV4dC5yZXNwb25zZSAmJiBjb250ZXh0LnJlc29sdmFibGU/LnJlc29sdmUoY29udGV4dC5yZXNwb25zZSksIHtcbiAgICAgICAgdHlwZTogXCJyZXF1ZXN0LnN1Y2Nlc3NcIixcbiAgICAgICAgcmVxdWVzdElkOiBzZWxmLmlkLFxuICAgICAgICByZXNwb25zZTogY29udGV4dC5yZXNwb25zZSxcbiAgICAgICAgcmVzcG9uc2VUbzogY29udGV4dC5yZXNwb25zZVRvXG4gICAgICB9KVxuICAgICksXG4gICAgXCJvbiBmYWlsXCI6IHNlbmRUbyhcbiAgICAgICh7IGNvbnRleHQgfSkgPT4gY29udGV4dC5wYXJlbnRSZWYsXG4gICAgICAoeyBjb250ZXh0LCBzZWxmIH0pID0+IChjb250ZXh0LnN1cHByZXNzV2FybmluZ3MgfHwgY29uc29sZS53YXJuKFxuICAgICAgICBgW0BzYW5pdHkvY29tbGlua10gUmVjZWl2ZWQgbm8gcmVzcG9uc2UgdG8gbWVzc2FnZSAnJHtjb250ZXh0LnR5cGV9JyBvbiBjbGllbnQgJyR7Y29udGV4dC5mcm9tfScgKElEOiAnJHtjb250ZXh0LmlkfScpLmBcbiAgICAgICksIGNvbnRleHQucmVzb2x2YWJsZT8ucmVqZWN0KG5ldyBFcnJvcihcIk5vIHJlc3BvbnNlIHJlY2VpdmVkXCIpKSwgeyB0eXBlOiBcInJlcXVlc3QuZmFpbGVkXCIsIHJlcXVlc3RJZDogc2VsZi5pZCB9KVxuICAgICksXG4gICAgXCJvbiBhYm9ydFwiOiBzZW5kVG8oXG4gICAgICAoeyBjb250ZXh0IH0pID0+IGNvbnRleHQucGFyZW50UmVmLFxuICAgICAgKHsgY29udGV4dCwgc2VsZiB9KSA9PiAoY29udGV4dC5yZXNvbHZhYmxlPy5yZWplY3QobmV3IEVycm9yKFwiUmVxdWVzdCBhYm9ydGVkXCIpKSwgeyB0eXBlOiBcInJlcXVlc3QuYWJvcnRlZFwiLCByZXF1ZXN0SWQ6IHNlbGYuaWQgfSlcbiAgICApXG4gIH0sXG4gIGd1YXJkczoge1xuICAgIGV4cGVjdHNSZXNwb25zZTogKHsgY29udGV4dCB9KSA9PiBjb250ZXh0LmV4cGVjdFJlc3BvbnNlXG4gIH0sXG4gIGRlbGF5czoge1xuICAgIGluaXRpYWxUaW1lb3V0OiAwLFxuICAgIHJlc3BvbnNlVGltZW91dDogUkVTUE9OU0VfVElNRU9VVFxuICB9XG59KS5jcmVhdGVNYWNoaW5lKHtcbiAgLyoqIEB4c3RhdGUtbGF5b3V0IE40SWdwZ0pnNW1ET0lDNVFBb0MyQkRBeGdDd0pZRHN3QktBT2x3Z0Jzd0JpQUQxZ0JkMEd3VDBBekZnSjJRTndkem9LQUZWeW93QWV3Q3VESXRUUlk4aFV1U29CdEFBd0JkUktBQU9FMlAxd1Q4dWtMVVFCR0FFd0JXRWdCWUFuSytlT0F6QjdzQjJEelk4ckFCb1FBRTlyRFFjM1YwY05UdzhmQUE0Tkh3QmZWSkNGSEFKaUVsZ3dmQWdDS0dwTkhTUVFBeU1CVTNOTEJEc3JEeEk3RFRhQWpRQTJPT2NORHhEd2hIc05KeDlPdTBUT3EyY0p4UDlIZE15TWJPVThncUw4RXJVcmN2MURZMXFLK3NibTF2YVBMcDYrZ2NSbkd5ZG85d0RHeWNXUUxLVmM5QUIzZEdOTjZqaVdDd2RBd01ybUtvSE14SFJDSlJLT0VpSkh3dVpLQlp3WEt6Qk1LSUd5WWtodEFrWE93ZVRxT0h3MlJKdkQ0NVVnLVA0Q0FIMEpnc05pY01BOExod0F6NGZLaWNUU1dUeVphZldtLWY1UWNFVlNFMWFHZ2Vwd2hGSWxGOWFZWXJHREM0K0p6RXBwakd6T1VrZUdicERJZ2ZBU0NCd2N6VTVRUS1ZeXVxSUFDMG5SdUNCZCtJSlh1OUtTcHdwcFpFb1lEdDFSTXNvc2lFY05qZFZqaUpFZUdpc2lTVEhrY1ZnV3BwdHVYeWhXS0lhaGpxR3ppMUJxUkpJTm5WY2RrY2J1VExTOVZZQzhJU2ZzVUFicDR2ekRwaENISkl5akJ2Sk5seE5tUk5leFEzc0pHSDQzR1BqOGpXSnJaV3VYWWZ5b0VDN1ljTHNicmdSc2prY3ZrbWRnTmJvcFZoSVBoVmZuc2g4Q2xNei10V3NDa21Fd2NIZ1V2dDI1N3U4dis2SHNlNHhuaE9kWm5JbVZpZFBxQ1JOQjRKcXBFQUEgKi9cbiAgY29udGV4dDogKHsgaW5wdXQgfSkgPT4gKHtcbiAgICBjb25uZWN0aW9uSWQ6IGlucHV0LmNvbm5lY3Rpb25JZCxcbiAgICBkYXRhOiBpbnB1dC5kYXRhLFxuICAgIGRvbWFpbjogaW5wdXQuZG9tYWluLFxuICAgIGV4cGVjdFJlc3BvbnNlOiBpbnB1dC5leHBlY3RSZXNwb25zZSA/PyAhMSxcbiAgICBmcm9tOiBpbnB1dC5mcm9tLFxuICAgIGlkOiBgbXNnLSR7djQoKX1gLFxuICAgIHBhcmVudFJlZjogaW5wdXQucGFyZW50UmVmLFxuICAgIHJlc29sdmFibGU6IGlucHV0LnJlc29sdmFibGUsXG4gICAgcmVzcG9uc2U6IG51bGwsXG4gICAgcmVzcG9uc2VUbzogaW5wdXQucmVzcG9uc2VUbyxcbiAgICBzaWduYWw6IGlucHV0LnNpZ25hbCxcbiAgICBzb3VyY2VzOiBpbnB1dC5zb3VyY2VzIGluc3RhbmNlb2YgU2V0ID8gaW5wdXQuc291cmNlcyA6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtpbnB1dC5zb3VyY2VzXSksXG4gICAgc3VwcHJlc3NXYXJuaW5nczogaW5wdXQuc3VwcHJlc3NXYXJuaW5ncyxcbiAgICB0YXJnZXRPcmlnaW46IGlucHV0LnRhcmdldE9yaWdpbixcbiAgICB0bzogaW5wdXQudG8sXG4gICAgdHlwZTogaW5wdXQudHlwZVxuICB9KSxcbiAgaW5pdGlhbDogXCJpZGxlXCIsXG4gIG9uOiB7XG4gICAgYWJvcnQ6IFwiLmFib3J0ZWRcIlxuICB9LFxuICBzdGF0ZXM6IHtcbiAgICBpZGxlOiB7XG4gICAgICBhZnRlcjoge1xuICAgICAgICBpbml0aWFsVGltZW91dDogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRhcmdldDogXCJzZW5kaW5nXCJcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH1cbiAgICB9LFxuICAgIHNlbmRpbmc6IHtcbiAgICAgIGVudHJ5OiB7XG4gICAgICAgIHR5cGU6IFwic2VuZCBtZXNzYWdlXCIsXG4gICAgICAgIHBhcmFtczogKHsgY29udGV4dCB9KSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBjb25uZWN0aW9uSWQsIGRhdGEsIGRvbWFpbiwgZnJvbSwgaWQsIHJlc3BvbnNlVG8sIHRvLCB0eXBlIH0gPSBjb250ZXh0O1xuICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25JZCxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBkb21haW4sXG4gICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICB0byxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICByZXNwb25zZVRvXG4gICAgICAgICAgfSB9O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYWx3YXlzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBndWFyZDogXCJleHBlY3RzUmVzcG9uc2VcIixcbiAgICAgICAgICB0YXJnZXQ6IFwiYXdhaXRpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcInN1Y2Nlc3NcIlxuICAgICAgXVxuICAgIH0sXG4gICAgYXdhaXRpbmc6IHtcbiAgICAgIGludm9rZToge1xuICAgICAgICBpZDogXCJsaXN0ZW4gZm9yIHJlc3BvbnNlXCIsXG4gICAgICAgIHNyYzogXCJsaXN0ZW5cIixcbiAgICAgICAgaW5wdXQ6ICh7IGNvbnRleHQgfSkgPT4gKHtcbiAgICAgICAgICByZXF1ZXN0SWQ6IGNvbnRleHQuaWQsXG4gICAgICAgICAgc291cmNlczogY29udGV4dC5zb3VyY2VzLFxuICAgICAgICAgIHNpZ25hbDogY29udGV4dC5zaWduYWxcbiAgICAgICAgfSksXG4gICAgICAgIG9uRXJyb3I6IFwiYWJvcnRlZFwiXG4gICAgICB9LFxuICAgICAgYWZ0ZXI6IHtcbiAgICAgICAgcmVzcG9uc2VUaW1lb3V0OiBcImZhaWxlZFwiXG4gICAgICB9LFxuICAgICAgb246IHtcbiAgICAgICAgbWVzc2FnZToge1xuICAgICAgICAgIGFjdGlvbnM6IGFzc2lnbih7XG4gICAgICAgICAgICByZXNwb25zZTogKHsgZXZlbnQgfSkgPT4gZXZlbnQuZGF0YS5kYXRhLFxuICAgICAgICAgICAgcmVzcG9uc2VUbzogKHsgZXZlbnQgfSkgPT4gZXZlbnQuZGF0YS5yZXNwb25zZVRvXG4gICAgICAgICAgfSksXG4gICAgICAgICAgdGFyZ2V0OiBcInN1Y2Nlc3NcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBmYWlsZWQ6IHtcbiAgICAgIHR5cGU6IFwiZmluYWxcIixcbiAgICAgIGVudHJ5OiBcIm9uIGZhaWxcIlxuICAgIH0sXG4gICAgc3VjY2Vzczoge1xuICAgICAgdHlwZTogXCJmaW5hbFwiLFxuICAgICAgZW50cnk6IFwib24gc3VjY2Vzc1wiXG4gICAgfSxcbiAgICBhYm9ydGVkOiB7XG4gICAgICB0eXBlOiBcImZpbmFsXCIsXG4gICAgICBlbnRyeTogXCJvbiBhYm9ydFwiXG4gICAgfVxuICB9LFxuICBvdXRwdXQ6ICh7IGNvbnRleHQsIHNlbGYgfSkgPT4gKHtcbiAgICByZXF1ZXN0SWQ6IHNlbGYuaWQsXG4gICAgcmVzcG9uc2U6IGNvbnRleHQucmVzcG9uc2UsXG4gICAgcmVzcG9uc2VUbzogY29udGV4dC5yZXNwb25zZVRvXG4gIH0pXG59KSwgc2VuZEJhY2tBdEludGVydmFsID0gZnJvbUNhbGxiYWNrKCh7IHNlbmRCYWNrLCBpbnB1dCB9KSA9PiB7XG4gIGNvbnN0IHNlbmQgPSAoKSA9PiB7XG4gICAgc2VuZEJhY2soaW5wdXQuZXZlbnQpO1xuICB9O1xuICBpbnB1dC5pbW1lZGlhdGUgJiYgc2VuZCgpO1xuICBjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKHNlbmQsIGlucHV0LmludGVydmFsKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgfTtcbn0pLCBjcmVhdGVDaGFubmVsTWFjaGluZSA9ICgpID0+IHNldHVwKHtcbiAgdHlwZXM6IHt9LFxuICBhY3RvcnM6IHtcbiAgICByZXF1ZXN0TWFjaGluZTogY3JlYXRlUmVxdWVzdE1hY2hpbmUoKSxcbiAgICBsaXN0ZW46IGNyZWF0ZUxpc3RlbkxvZ2ljKCksXG4gICAgc2VuZEJhY2tBdEludGVydmFsXG4gIH0sXG4gIGFjdGlvbnM6IHtcbiAgICBcImJ1ZmZlciBtZXNzYWdlXCI6IGVucXVldWVBY3Rpb25zKCh7IGVucXVldWUgfSkgPT4ge1xuICAgICAgZW5xdWV1ZS5hc3NpZ24oe1xuICAgICAgICBidWZmZXI6ICh7IGV2ZW50LCBjb250ZXh0IH0pID0+IChhc3NlcnRFdmVudChldmVudCwgXCJwb3N0XCIpLCBbLi4uY29udGV4dC5idWZmZXIsIGV2ZW50LmRhdGFdKVxuICAgICAgfSksIGVucXVldWUuZW1pdCgoeyBldmVudCB9KSA9PiAoYXNzZXJ0RXZlbnQoZXZlbnQsIFwicG9zdFwiKSwge1xuICAgICAgICB0eXBlOiBcIl9idWZmZXIuYWRkZWRcIixcbiAgICAgICAgbWVzc2FnZTogZXZlbnQuZGF0YVxuICAgICAgfSkpO1xuICAgIH0pLFxuICAgIFwiY3JlYXRlIHJlcXVlc3RcIjogYXNzaWduKHtcbiAgICAgIHJlcXVlc3RzOiAoeyBjb250ZXh0LCBldmVudCwgc2VsZiwgc3Bhd24gfSkgPT4ge1xuICAgICAgICBhc3NlcnRFdmVudChldmVudCwgXCJyZXF1ZXN0XCIpO1xuICAgICAgICBjb25zdCByZXF1ZXN0cyA9IChBcnJheS5pc0FycmF5KGV2ZW50LmRhdGEpID8gZXZlbnQuZGF0YSA6IFtldmVudC5kYXRhXSkubWFwKChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgY29uc3QgaWQgPSBgcmVxLSR7djQoKX1gO1xuICAgICAgICAgIHJldHVybiBzcGF3bihcInJlcXVlc3RNYWNoaW5lXCIsIHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgaW5wdXQ6IHtcbiAgICAgICAgICAgICAgY29ubmVjdGlvbklkOiBjb250ZXh0LmNvbm5lY3Rpb25JZCxcbiAgICAgICAgICAgICAgZGF0YTogcmVxdWVzdC5kYXRhLFxuICAgICAgICAgICAgICBkb21haW46IGNvbnRleHQuZG9tYWluLFxuICAgICAgICAgICAgICBleHBlY3RSZXNwb25zZTogcmVxdWVzdC5leHBlY3RSZXNwb25zZSxcbiAgICAgICAgICAgICAgZnJvbTogY29udGV4dC5uYW1lLFxuICAgICAgICAgICAgICBwYXJlbnRSZWY6IHNlbGYsXG4gICAgICAgICAgICAgIHJlc3BvbnNlVG86IHJlcXVlc3QucmVzcG9uc2VUbyxcbiAgICAgICAgICAgICAgc291cmNlczogY29udGV4dC50YXJnZXQsXG4gICAgICAgICAgICAgIHRhcmdldE9yaWdpbjogY29udGV4dC50YXJnZXRPcmlnaW4sXG4gICAgICAgICAgICAgIHRvOiBjb250ZXh0LmNvbm5lY3RUbyxcbiAgICAgICAgICAgICAgdHlwZTogcmVxdWVzdC50eXBlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gWy4uLmNvbnRleHQucmVxdWVzdHMsIC4uLnJlcXVlc3RzXTtcbiAgICAgIH1cbiAgICB9KSxcbiAgICBcImVtaXQgcmVjZWl2ZWQgbWVzc2FnZVwiOiBlbnF1ZXVlQWN0aW9ucygoeyBlbnF1ZXVlIH0pID0+IHtcbiAgICAgIGVucXVldWUuZW1pdCgoeyBldmVudCB9KSA9PiAoYXNzZXJ0RXZlbnQoZXZlbnQsIFwibWVzc2FnZS5yZWNlaXZlZFwiKSwge1xuICAgICAgICB0eXBlOiBcIl9tZXNzYWdlXCIsXG4gICAgICAgIG1lc3NhZ2U6IGV2ZW50Lm1lc3NhZ2UuZGF0YVxuICAgICAgfSkpLCBlbnF1ZXVlLmVtaXQoKHsgZXZlbnQgfSkgPT4gKGFzc2VydEV2ZW50KGV2ZW50LCBcIm1lc3NhZ2UucmVjZWl2ZWRcIiksIHtcbiAgICAgICAgdHlwZTogZXZlbnQubWVzc2FnZS5kYXRhLnR5cGUsXG4gICAgICAgIG1lc3NhZ2U6IGV2ZW50Lm1lc3NhZ2UuZGF0YVxuICAgICAgfSkpO1xuICAgIH0pLFxuICAgIFwiZmx1c2ggYnVmZmVyXCI6IGVucXVldWVBY3Rpb25zKCh7IGVucXVldWUgfSkgPT4ge1xuICAgICAgZW5xdWV1ZS5yYWlzZSgoeyBjb250ZXh0IH0pID0+ICh7XG4gICAgICAgIHR5cGU6IFwicmVxdWVzdFwiLFxuICAgICAgICBkYXRhOiBjb250ZXh0LmJ1ZmZlci5tYXAoKHsgZGF0YSwgdHlwZSB9KSA9PiAoeyBkYXRhLCB0eXBlIH0pKVxuICAgICAgfSkpLCBlbnF1ZXVlLmVtaXQoKHsgY29udGV4dCB9KSA9PiAoe1xuICAgICAgICB0eXBlOiBcIl9idWZmZXIuZmx1c2hlZFwiLFxuICAgICAgICBtZXNzYWdlczogY29udGV4dC5idWZmZXJcbiAgICAgIH0pKSwgZW5xdWV1ZS5hc3NpZ24oe1xuICAgICAgICBidWZmZXI6IFtdXG4gICAgICB9KTtcbiAgICB9KSxcbiAgICBwb3N0OiByYWlzZSgoeyBldmVudCB9KSA9PiAoYXNzZXJ0RXZlbnQoZXZlbnQsIFwicG9zdFwiKSwge1xuICAgICAgdHlwZTogXCJyZXF1ZXN0XCIsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGRhdGE6IGV2ZW50LmRhdGEuZGF0YSxcbiAgICAgICAgZXhwZWN0UmVzcG9uc2U6ICEwLFxuICAgICAgICB0eXBlOiBldmVudC5kYXRhLnR5cGVcbiAgICAgIH1cbiAgICB9KSksXG4gICAgXCJyZW1vdmUgcmVxdWVzdFwiOiBlbnF1ZXVlQWN0aW9ucygoeyBjb250ZXh0LCBlbnF1ZXVlLCBldmVudCB9KSA9PiB7XG4gICAgICBhc3NlcnRFdmVudChldmVudCwgW1wicmVxdWVzdC5zdWNjZXNzXCIsIFwicmVxdWVzdC5mYWlsZWRcIiwgXCJyZXF1ZXN0LmFib3J0ZWRcIl0pLCBzdG9wQ2hpbGQoZXZlbnQucmVxdWVzdElkKSwgZW5xdWV1ZS5hc3NpZ24oeyByZXF1ZXN0czogY29udGV4dC5yZXF1ZXN0cy5maWx0ZXIoKHsgaWQgfSkgPT4gaWQgIT09IGV2ZW50LnJlcXVlc3RJZCkgfSk7XG4gICAgfSksXG4gICAgcmVzcG9uZDogcmFpc2UoKHsgZXZlbnQgfSkgPT4gKGFzc2VydEV2ZW50KGV2ZW50LCBcInJlc3BvbnNlXCIpLCB7XG4gICAgICB0eXBlOiBcInJlcXVlc3RcIixcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgZGF0YTogZXZlbnQuZGF0YSxcbiAgICAgICAgdHlwZTogTVNHX1JFU1BPTlNFLFxuICAgICAgICByZXNwb25zZVRvOiBldmVudC5yZXNwb25kVG9cbiAgICAgIH1cbiAgICB9KSksXG4gICAgXCJzZW5kIGhhbmRzaGFrZSBhY2tcIjogcmFpc2Uoe1xuICAgICAgdHlwZTogXCJyZXF1ZXN0XCIsXG4gICAgICBkYXRhOiB7IHR5cGU6IE1TR19IQU5EU0hBS0VfQUNLIH1cbiAgICB9KSxcbiAgICBcInNlbmQgZGlzY29ubmVjdFwiOiByYWlzZSgoKSA9PiAoe1xuICAgICAgdHlwZTogXCJyZXF1ZXN0XCIsXG4gICAgICBkYXRhOiB7IHR5cGU6IE1TR19ESVNDT05ORUNUIH1cbiAgICB9KSksXG4gICAgXCJzZW5kIGhhbmRzaGFrZSBzeW5cIjogcmFpc2Uoe1xuICAgICAgdHlwZTogXCJyZXF1ZXN0XCIsXG4gICAgICBkYXRhOiB7IHR5cGU6IE1TR19IQU5EU0hBS0VfU1lOIH1cbiAgICB9KSxcbiAgICBcInNldCB0YXJnZXRcIjogYXNzaWduKHtcbiAgICAgIHRhcmdldDogKHsgZXZlbnQgfSkgPT4gKGFzc2VydEV2ZW50KGV2ZW50LCBcInRhcmdldC5zZXRcIiksIGV2ZW50LnRhcmdldClcbiAgICB9KVxuICB9LFxuICBndWFyZHM6IHtcbiAgICBcImhhcyB0YXJnZXRcIjogKHsgY29udGV4dCB9KSA9PiAhIWNvbnRleHQudGFyZ2V0LFxuICAgIFwic2hvdWxkIHNlbmQgaGVhcnRiZWF0c1wiOiAoeyBjb250ZXh0IH0pID0+IGNvbnRleHQuaGVhcnRiZWF0XG4gIH1cbn0pLmNyZWF0ZU1hY2hpbmUoe1xuICAvKiogQHhzdGF0ZS1sYXlvdXQgTjRJZ3BnSmc1bURPSUM1UUdNQVdCREFkcHNBYkF4QUM3b0JPTWhBZExHSVFOb0FNQXVvcUFBNEQyc0Fsb1YrNWl4QUFQUkFIWlJBSmdvQVdBQnowQXJISUNNeTJRR1paQ2dKd0FhRUFFOUVFK3RJcmI2QU5na0xsNDZmVHVqMUFYeGY2MFdIQVJKZ0FqZ0N1Y0pTd0FjakljTEFNekVnZ0hOeTgtSUlpQ0tMUzJoUVM2cWIyeXVyaXNyTDZSZ2pLOUxJeUN1cXEwZzdXc3RadUhoalllUGkrZ2NFVUFHYm9YTGlRMFlMeFBId0NzU21pQ2dveWtwYXlEdHFTNnRycXhZaktFazBnbnEyNEZGd1FBLWpJLURqSWRFekRuS05KRXh1T1pwWjEyZXEyOU9yU0N1dXB5cFlVb2pVYVRLQ25tNVdrMjEyM2dPUnpBK0hpbHhpYkJ1aVhHb0JTR25VQUlVNGdVOUZXYW1VdFIrbG1VTTFFbGxCRWtzbE1VRW5wa0phMEphRUZnR0FBMWx4TUZCOExBREpnaHJFUnFqa2h0c2hrM21UdE5vNU9wcXBZZnFDS2hUcHRvcXBZMVdVdHU0ZGt5OEJRV1d6MEp6dWUxLUVGWUlqcmdreHFMU3VwcVJSUHBvUHFKdExJMGhJaW9aRU5KSkU3Tm5KOFpZSFZrMVl5dlByRFJ5dVR5RVlMa1RhN3VpeFZsTWg4MUtHRmhTMWo2RVBrWmxwVmpUcGhyOG1rSTNzRFZoV1RIVFFCYlNMb0dBVVh3UkxnQU4wR1Z5RktOdDkxS2ltVUZFS1h2S0MyczlSKzZYK2ppcG56SmVTcUVKMVVLak5hTkpwNUVDNHNGT3JRdUNiaWZlVHdnMmNnb3ltMFJQeER0cWtqMGVhQjlBbzh6U29sTUVpdlpWY3E3MSszM2M1Q0VnZUZPQ3RYc2t6Uk04RUR4S1JwbWtTdzNRSmJRc21wSDV0SG1WOEpIU2JKcERzYWtWMmFTTUFMT01BTGhBam9MWEF4TmJpZ2xJLVN4V3cxVncwUU5EdzBRZmc5S1E3RUpTeEhIeEFwSzJoUUN5T0FpQXpWZ0RoTUdvSTloWDdGTUVIU0Y4Y1drZWxwSFVSQ2JCc2I0ODF4QUVnVDlCUUpDbVdRc2lFLVVSUEk4VEcxZ1dCbXpBVnN5TEFUdHV5Ulk5SUx0V29LbWxMODJLcWQwdEFWSjkxTE1IRlpES0lrVmxrTlZaSE1raUR6RS1BZHozVWpEeDdHaVJRSENLbmhlRDUzaytIU1NrRERJd3BCVlRxUXd1S0tFc3NTRFRBVWhDQUFJM3F5ZzBESXJkOEZrazg2TVFVTW5WTStSeW5vZWdUREpINDhoR3AwdlItRkRScXFLcWFzZ09xR3VhOUFRakFUQWQxTlNpdWw2ZnBYT3RXaTdXeTE5Y3NsRDR2bkc3SVgzb1ZqVkRVVllFSlFxcmtzVzhTZHN0THFQS3kwd0tnRzFSaHRNV29ncUtob01qa1dwNlh4VXlGQmUzYzN0QXo3MHZjbzZmcStWOFBUa0dVRnpkUXFObkVMRU0yeUNscnd3elE0WlNoS1FKcXI3VVlVOThBUzBXOXBUNHo1cEhHMHlYd01rTk5UeUdrM0IxVEIyQWdPQkJEWFhCRHN5aFNGRzlFb3ZRcU41aTFKZVJjS3F3NEJrbCtUb014OHgwaitFYXFROVhNU2tCVVJNZ01rRXdRV0tybzJOV05OZFBGSkF6TjBsSkdNNHNsRHhoQkVKZlh5cGxCZDAzd1cxS3hJZG5yQnhCaDRKQXlXNzVDOHJKcG1EcW1JR1drZ21wYXNQanFVY2FIb29NTEhBMHVVMVVrSk9nS1cxQjZyVDFiV29yNUF0MHpnY1RBa0s3aHJ6MWlyQjBEOGNXMFV2UlBMeXYwN1dxZ05xMnFBRytsOVNuWFV6MFVPWEQ1eHVNczNZNCtEVkpCWDdVaUtyVjZROGdjZm9KTzU0ckZlZkxMcWZKWVgxV0tZTkx4TDROTzFOd2dBICovXG4gIGlkOiBcImNoYW5uZWxcIixcbiAgY29udGV4dDogKHsgaW5wdXQgfSkgPT4gKHtcbiAgICBpZDogaW5wdXQuaWQgfHwgYCR7aW5wdXQubmFtZX0tJHt2NCgpfWAsXG4gICAgYnVmZmVyOiBbXSxcbiAgICBjb25uZWN0aW9uSWQ6IGBjbngtJHt2NCgpfWAsXG4gICAgY29ubmVjdFRvOiBpbnB1dC5jb25uZWN0VG8sXG4gICAgZG9tYWluOiBpbnB1dC5kb21haW4gPz8gRE9NQUlOLFxuICAgIGhlYXJ0YmVhdDogaW5wdXQuaGVhcnRiZWF0ID8/ICExLFxuICAgIG5hbWU6IGlucHV0Lm5hbWUsXG4gICAgcmVxdWVzdHM6IFtdLFxuICAgIHRhcmdldDogaW5wdXQudGFyZ2V0LFxuICAgIHRhcmdldE9yaWdpbjogaW5wdXQudGFyZ2V0T3JpZ2luXG4gIH0pLFxuICBvbjoge1xuICAgIFwidGFyZ2V0LnNldFwiOiB7XG4gICAgICBhY3Rpb25zOiBcInNldCB0YXJnZXRcIlxuICAgIH0sXG4gICAgXCJyZXF1ZXN0LnN1Y2Nlc3NcIjoge1xuICAgICAgYWN0aW9uczogXCJyZW1vdmUgcmVxdWVzdFwiXG4gICAgfSxcbiAgICBcInJlcXVlc3QuZmFpbGVkXCI6IHtcbiAgICAgIGFjdGlvbnM6IFwicmVtb3ZlIHJlcXVlc3RcIlxuICAgIH1cbiAgfSxcbiAgaW5pdGlhbDogXCJpZGxlXCIsXG4gIHN0YXRlczoge1xuICAgIGlkbGU6IHtcbiAgICAgIG9uOiB7XG4gICAgICAgIGNvbm5lY3Q6IHtcbiAgICAgICAgICB0YXJnZXQ6IFwiaGFuZHNoYWtpbmdcIixcbiAgICAgICAgICBndWFyZDogXCJoYXMgdGFyZ2V0XCJcbiAgICAgICAgfSxcbiAgICAgICAgcG9zdDoge1xuICAgICAgICAgIGFjdGlvbnM6IFwiYnVmZmVyIG1lc3NhZ2VcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBoYW5kc2hha2luZzoge1xuICAgICAgaWQ6IFwiaGFuZHNoYWtpbmdcIixcbiAgICAgIGludm9rZTogW1xuICAgICAgICB7XG4gICAgICAgICAgaWQ6IFwic2VuZCBzeW5cIixcbiAgICAgICAgICBzcmM6IFwic2VuZEJhY2tBdEludGVydmFsXCIsXG4gICAgICAgICAgaW5wdXQ6ICgpID0+ICh7XG4gICAgICAgICAgICBldmVudDogeyB0eXBlOiBcInN5blwiIH0sXG4gICAgICAgICAgICBpbnRlcnZhbDogSEFORFNIQUtFX0lOVEVSVkFMLFxuICAgICAgICAgICAgaW1tZWRpYXRlOiAhMFxuICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogXCJsaXN0ZW4gZm9yIGhhbmRzaGFrZVwiLFxuICAgICAgICAgIHNyYzogXCJsaXN0ZW5cIixcbiAgICAgICAgICBpbnB1dDogKGlucHV0KSA9PiBsaXN0ZW5JbnB1dEZyb21Db250ZXh0KHtcbiAgICAgICAgICAgIGluY2x1ZGU6IE1TR19IQU5EU0hBS0VfU1lOX0FDSyxcbiAgICAgICAgICAgIGNvdW50OiAxXG4gICAgICAgICAgfSkoaW5wdXQpXG4gICAgICAgICAgLyogQmVsb3cgd291bGQgbWF5YmUgYmUgbW9yZSByZWFkYWJsZSB0aGFuIHRyYW5zaXRpb25pbmcgdG9cbiAgICAgICAgICAnY29ubmVjdGVkJyBvbiAnbWVzc2FnZScsIGFuZCAnYWNrJyBvbiBleGl0IGJ1dCBoYXZpbmcgb25Eb25lIHdoZW5cbiAgICAgICAgICB1c2luZyBwYXNzaW5nIGludm9jYXRpb25zIGN1cnJlbnRseSBicmVha3MgWFN0YXRlIEVkaXRvciAqL1xuICAgICAgICAgIC8vIG9uRG9uZToge1xuICAgICAgICAgIC8vICAgdGFyZ2V0OiAnY29ubmVjdGVkJyxcbiAgICAgICAgICAvLyAgIGFjdGlvbnM6ICdhY2snLFxuICAgICAgICAgIC8vIH0sXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICBvbjoge1xuICAgICAgICBzeW46IHtcbiAgICAgICAgICBhY3Rpb25zOiBcInNlbmQgaGFuZHNoYWtlIHN5blwiXG4gICAgICAgIH0sXG4gICAgICAgIHJlcXVlc3Q6IHtcbiAgICAgICAgICBhY3Rpb25zOiBcImNyZWF0ZSByZXF1ZXN0XCJcbiAgICAgICAgfSxcbiAgICAgICAgcG9zdDoge1xuICAgICAgICAgIGFjdGlvbnM6IFwiYnVmZmVyIG1lc3NhZ2VcIlxuICAgICAgICB9LFxuICAgICAgICBcIm1lc3NhZ2UucmVjZWl2ZWRcIjoge1xuICAgICAgICAgIHRhcmdldDogXCJjb25uZWN0ZWRcIlxuICAgICAgICB9LFxuICAgICAgICBkaXNjb25uZWN0OiB7XG4gICAgICAgICAgdGFyZ2V0OiBcImRpc2Nvbm5lY3RlZFwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBleGl0OiBcInNlbmQgaGFuZHNoYWtlIGFja1wiXG4gICAgfSxcbiAgICBjb25uZWN0ZWQ6IHtcbiAgICAgIGVudHJ5OiBcImZsdXNoIGJ1ZmZlclwiLFxuICAgICAgaW52b2tlOiB7XG4gICAgICAgIGlkOiBcImxpc3RlbiBmb3IgbWVzc2FnZXNcIixcbiAgICAgICAgc3JjOiBcImxpc3RlblwiLFxuICAgICAgICBpbnB1dDogbGlzdGVuSW5wdXRGcm9tQ29udGV4dCh7XG4gICAgICAgICAgZXhjbHVkZTogW01TR19SRVNQT05TRSwgTVNHX0hFQVJUQkVBVF1cbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICBvbjoge1xuICAgICAgICBwb3N0OiB7XG4gICAgICAgICAgYWN0aW9uczogXCJwb3N0XCJcbiAgICAgICAgfSxcbiAgICAgICAgcmVxdWVzdDoge1xuICAgICAgICAgIGFjdGlvbnM6IFwiY3JlYXRlIHJlcXVlc3RcIlxuICAgICAgICB9LFxuICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgIGFjdGlvbnM6IFwicmVzcG9uZFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibWVzc2FnZS5yZWNlaXZlZFwiOiB7XG4gICAgICAgICAgYWN0aW9uczogXCJlbWl0IHJlY2VpdmVkIG1lc3NhZ2VcIlxuICAgICAgICB9LFxuICAgICAgICBkaXNjb25uZWN0OiB7XG4gICAgICAgICAgdGFyZ2V0OiBcImRpc2Nvbm5lY3RlZFwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpbml0aWFsOiBcImhlYXJ0YmVhdFwiLFxuICAgICAgc3RhdGVzOiB7XG4gICAgICAgIGhlYXJ0YmVhdDoge1xuICAgICAgICAgIGluaXRpYWw6IFwiY2hlY2tpbmdcIixcbiAgICAgICAgICBzdGF0ZXM6IHtcbiAgICAgICAgICAgIGNoZWNraW5nOiB7XG4gICAgICAgICAgICAgIGFsd2F5czoge1xuICAgICAgICAgICAgICAgIGd1YXJkOiBcInNob3VsZCBzZW5kIGhlYXJ0YmVhdHNcIixcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IFwic2VuZGluZ1wiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZW5kaW5nOiB7XG4gICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgXCJyZXF1ZXN0LmZhaWxlZFwiOiB7XG4gICAgICAgICAgICAgICAgICB0YXJnZXQ6IFwiI2hhbmRzaGFraW5nXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGludm9rZToge1xuICAgICAgICAgICAgICAgIGlkOiBcInNlbmQgaGVhcnRiZWF0XCIsXG4gICAgICAgICAgICAgICAgc3JjOiBcInNlbmRCYWNrQXRJbnRlcnZhbFwiLFxuICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgZXZlbnQ6IHsgdHlwZTogXCJwb3N0XCIsIGRhdGE6IHsgdHlwZTogTVNHX0hFQVJUQkVBVCwgZGF0YTogdm9pZCAwIH0gfSxcbiAgICAgICAgICAgICAgICAgIGludGVydmFsOiAyZTMsXG4gICAgICAgICAgICAgICAgICBpbW1lZGlhdGU6ICExXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZGlzY29ubmVjdGVkOiB7XG4gICAgICBpZDogXCJkaXNjb25uZWN0ZWRcIixcbiAgICAgIGVudHJ5OiBcInNlbmQgZGlzY29ubmVjdFwiLFxuICAgICAgb246IHtcbiAgICAgICAgcmVxdWVzdDoge1xuICAgICAgICAgIGFjdGlvbnM6IFwiY3JlYXRlIHJlcXVlc3RcIlxuICAgICAgICB9LFxuICAgICAgICBwb3N0OiB7XG4gICAgICAgICAgYWN0aW9uczogXCJidWZmZXIgbWVzc2FnZVwiXG4gICAgICAgIH0sXG4gICAgICAgIGNvbm5lY3Q6IHtcbiAgICAgICAgICB0YXJnZXQ6IFwiaGFuZHNoYWtpbmdcIixcbiAgICAgICAgICBndWFyZDogXCJoYXMgdGFyZ2V0XCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSksIGNyZWF0ZUNoYW5uZWwgPSAoaW5wdXQsIG1hY2hpbmUgPSBjcmVhdGVDaGFubmVsTWFjaGluZSgpKSA9PiB7XG4gIGNvbnN0IGlkID0gaW5wdXQuaWQgfHwgYCR7aW5wdXQubmFtZX0tJHt2NCgpfWAsIGFjdG9yID0gY3JlYXRlQWN0b3IobWFjaGluZSwge1xuICAgIGlucHV0OiB7IC4uLmlucHV0LCBpZCB9XG4gIH0pLCBvbiA9ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgY29uc3QgeyB1bnN1YnNjcmliZSB9ID0gYWN0b3Iub24oXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEB0b2RvIGB0eXBlYCB0eXBpbmdcbiAgICAgIHR5cGUsXG4gICAgICBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVyKGV2ZW50Lm1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIHJlc3BvbnNlICYmIGFjdG9yLnNlbmQoeyB0eXBlOiBcInJlc3BvbnNlXCIsIHJlc3BvbmRUbzogZXZlbnQubWVzc2FnZS5pZCwgZGF0YTogcmVzcG9uc2UgfSk7XG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gdW5zdWJzY3JpYmU7XG4gIH0sIGNvbm5lY3QgPSAoKSA9PiB7XG4gICAgYWN0b3Iuc2VuZCh7IHR5cGU6IFwiY29ubmVjdFwiIH0pO1xuICB9LCBkaXNjb25uZWN0ID0gKCkgPT4ge1xuICAgIGFjdG9yLnNlbmQoeyB0eXBlOiBcImRpc2Nvbm5lY3RcIiB9KTtcbiAgfSwgb25TdGF0dXMgPSAoaGFuZGxlcikgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnRTbmFwc2hvdCA9IGFjdG9yLmdldFNuYXBzaG90KCk7XG4gICAgbGV0IGN1cnJlbnRTdGF0dXMgPSB0eXBlb2YgY3VycmVudFNuYXBzaG90LnZhbHVlID09IFwic3RyaW5nXCIgPyBjdXJyZW50U25hcHNob3QudmFsdWUgOiBPYmplY3Qua2V5cyhjdXJyZW50U25hcHNob3QudmFsdWUpWzBdO1xuICAgIGNvbnN0IHsgdW5zdWJzY3JpYmUgfSA9IGFjdG9yLnN1YnNjcmliZSgoc3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IHN0YXR1cyA9IHR5cGVvZiBzdGF0ZS52YWx1ZSA9PSBcInN0cmluZ1wiID8gc3RhdGUudmFsdWUgOiBPYmplY3Qua2V5cyhzdGF0ZS52YWx1ZSlbMF07XG4gICAgICBjdXJyZW50U3RhdHVzICE9PSBzdGF0dXMgJiYgKGN1cnJlbnRTdGF0dXMgPSBzdGF0dXMsIGhhbmRsZXIoc3RhdHVzKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHVuc3Vic2NyaWJlO1xuICB9LCBzZXRUYXJnZXQgPSAodGFyZ2V0KSA9PiB7XG4gICAgYWN0b3Iuc2VuZCh7IHR5cGU6IFwidGFyZ2V0LnNldFwiLCB0YXJnZXQgfSk7XG4gIH0sIHBvc3QgPSAoZGF0YSkgPT4ge1xuICAgIGFjdG9yLnNlbmQoeyB0eXBlOiBcInBvc3RcIiwgZGF0YSB9KTtcbiAgfSwgc3RvcCA9ICgpID0+IHtcbiAgICBhY3Rvci5zdG9wKCk7XG4gIH0sIHN0YXJ0ID0gKCkgPT4gKGFjdG9yLnN0YXJ0KCksIHN0b3ApO1xuICByZXR1cm4ge1xuICAgIGFjdG9yLFxuICAgIGNvbm5lY3QsXG4gICAgZGlzY29ubmVjdCxcbiAgICBpZCxcbiAgICBuYW1lOiBpbnB1dC5uYW1lLFxuICAgIG1hY2hpbmUsXG4gICAgb24sXG4gICAgb25TdGF0dXMsXG4gICAgcG9zdCxcbiAgICBzZXRUYXJnZXQsXG4gICAgc3RhcnQsXG4gICAgc3RvcCxcbiAgICBnZXQgdGFyZ2V0KCkge1xuICAgICAgcmV0dXJuIGFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC50YXJnZXQ7XG4gICAgfVxuICB9O1xufSwgbm9vcCA9ICgpID0+IHtcbn0sIGNyZWF0ZUNvbnRyb2xsZXIgPSAoaW5wdXQpID0+IHtcbiAgY29uc3QgeyB0YXJnZXRPcmlnaW4gfSA9IGlucHV0LCB0YXJnZXRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSwgY29ubmVjdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLCBhZGRUYXJnZXQgPSAodGFyZ2V0KSA9PiB7XG4gICAgaWYgKHRhcmdldHMuaGFzKHRhcmdldCkpXG4gICAgICByZXR1cm4gbm9vcDtcbiAgICBpZiAoIXRhcmdldHMuc2l6ZSB8fCAhY29ubmVjdGlvbnMuc2l6ZSlcbiAgICAgIHJldHVybiB0YXJnZXRzLmFkZCh0YXJnZXQpLCBjb25uZWN0aW9ucy5mb3JFYWNoKChjb25uZWN0aW9uKSA9PiB7XG4gICAgICAgIGNvbm5lY3Rpb24uY2hhbm5lbHMuZm9yRWFjaCgoY2hhbm5lbCkgPT4ge1xuICAgICAgICAgIGNoYW5uZWwuc2V0VGFyZ2V0KHRhcmdldCksIGNoYW5uZWwuY29ubmVjdCgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pLCAoKSA9PiB7XG4gICAgICAgIHRhcmdldHMuZGVsZXRlKHRhcmdldCksIGNvbm5lY3Rpb25zLmZvckVhY2goKGNvbm5lY3Rpb24pID0+IHtcbiAgICAgICAgICBjb25uZWN0aW9uLmNoYW5uZWxzLmZvckVhY2goKGNoYW5uZWwpID0+IHtcbiAgICAgICAgICAgIGNoYW5uZWwudGFyZ2V0ID09PSB0YXJnZXQgJiYgY2hhbm5lbC5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB0YXJnZXRzLmFkZCh0YXJnZXQpO1xuICAgIGNvbnN0IHRhcmdldENoYW5uZWxzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICByZXR1cm4gY29ubmVjdGlvbnMuZm9yRWFjaCgoY29ubmVjdGlvbikgPT4ge1xuICAgICAgY29uc3QgY2hhbm5lbCA9IGNyZWF0ZUNoYW5uZWwoXG4gICAgICAgIHtcbiAgICAgICAgICAuLi5jb25uZWN0aW9uLmlucHV0LFxuICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICB0YXJnZXRPcmlnaW5cbiAgICAgICAgfSxcbiAgICAgICAgY29ubmVjdGlvbi5tYWNoaW5lXG4gICAgICApO1xuICAgICAgdGFyZ2V0Q2hhbm5lbHMuYWRkKGNoYW5uZWwpLCBjb25uZWN0aW9uLmNoYW5uZWxzLmFkZChjaGFubmVsKSwgY29ubmVjdGlvbi5zdWJzY3JpYmVycy5mb3JFYWNoKCh7IHR5cGUsIGhhbmRsZXIsIHVuc3Vic2NyaWJlcnMgfSkgPT4ge1xuICAgICAgICB1bnN1YnNjcmliZXJzLnB1c2goY2hhbm5lbC5vbih0eXBlLCBoYW5kbGVyKSk7XG4gICAgICB9KSwgY29ubmVjdGlvbi5pbnRlcm5hbEV2ZW50U3Vic2NyaWJlcnMuZm9yRWFjaCgoeyB0eXBlLCBoYW5kbGVyLCB1bnN1YnNjcmliZXJzIH0pID0+IHtcbiAgICAgICAgdW5zdWJzY3JpYmVycy5wdXNoKGNoYW5uZWwuYWN0b3Iub24odHlwZSwgaGFuZGxlcikudW5zdWJzY3JpYmUpO1xuICAgICAgfSksIGNvbm5lY3Rpb24uc3RhdHVzU3Vic2NyaWJlcnMuZm9yRWFjaCgoeyBoYW5kbGVyLCB1bnN1YnNjcmliZXJzIH0pID0+IHtcbiAgICAgICAgdW5zdWJzY3JpYmVycy5wdXNoKGNoYW5uZWwub25TdGF0dXMoKHN0YXR1cykgPT4gaGFuZGxlcih7IGNoYW5uZWw6IGNoYW5uZWwuaWQsIHN0YXR1cyB9KSkpO1xuICAgICAgfSksIGNoYW5uZWwuc3RhcnQoKSwgY2hhbm5lbC5jb25uZWN0KCk7XG4gICAgfSksICgpID0+IHtcbiAgICAgIHRhcmdldHMuZGVsZXRlKHRhcmdldCksIHRhcmdldENoYW5uZWxzLmZvckVhY2goKGNoYW5uZWwpID0+IHtcbiAgICAgICAgY2xlYW51cENoYW5uZWwoY2hhbm5lbCksIGNvbm5lY3Rpb25zLmZvckVhY2goKGNvbm5lY3Rpb24pID0+IHtcbiAgICAgICAgICBjb25uZWN0aW9uLmNoYW5uZWxzLmRlbGV0ZShjaGFubmVsKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9LCBjbGVhbnVwQ2hhbm5lbCA9IChjaGFubmVsKSA9PiB7XG4gICAgY2hhbm5lbC5kaXNjb25uZWN0KCksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgY2hhbm5lbC5zdG9wKCk7XG4gICAgfSwgMCk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgYWRkVGFyZ2V0LFxuICAgIGNyZWF0ZUNvbm5lY3Rpb246IChpbnB1dDIsIG1hY2hpbmUgPSBjcmVhdGVDaGFubmVsTWFjaGluZSgpKSA9PiB7XG4gICAgICBjb25zdCBjb25uZWN0aW9uID0ge1xuICAgICAgICBjaGFubmVsczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgICAgICAgaW5wdXQ6IGlucHV0MixcbiAgICAgICAgaW50ZXJuYWxFdmVudFN1YnNjcmliZXJzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgICAgICBtYWNoaW5lLFxuICAgICAgICBzdGF0dXNTdWJzY3JpYmVyczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgICAgICAgc3Vic2NyaWJlcnM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KClcbiAgICAgIH07XG4gICAgICBjb25uZWN0aW9ucy5hZGQoY29ubmVjdGlvbik7XG4gICAgICBjb25zdCB7IGNoYW5uZWxzLCBpbnRlcm5hbEV2ZW50U3Vic2NyaWJlcnMsIHN0YXR1c1N1YnNjcmliZXJzLCBzdWJzY3JpYmVycyB9ID0gY29ubmVjdGlvbjtcbiAgICAgIGlmICh0YXJnZXRzLnNpemUpXG4gICAgICAgIHRhcmdldHMuZm9yRWFjaCgodGFyZ2V0KSA9PiB7XG4gICAgICAgICAgY29uc3QgY2hhbm5lbCA9IGNyZWF0ZUNoYW5uZWwoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC4uLmlucHV0MixcbiAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICB0YXJnZXRPcmlnaW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtYWNoaW5lXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjaGFubmVscy5hZGQoY2hhbm5lbCk7XG4gICAgICAgIH0pO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGNoYW5uZWwgPSBjcmVhdGVDaGFubmVsKHsgLi4uaW5wdXQyLCB0YXJnZXRPcmlnaW4gfSwgbWFjaGluZSk7XG4gICAgICAgIGNoYW5uZWxzLmFkZChjaGFubmVsKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBvc3QgPSAoZGF0YSkgPT4ge1xuICAgICAgICBjaGFubmVscy5mb3JFYWNoKChjaGFubmVsKSA9PiB7XG4gICAgICAgICAgY2hhbm5lbC5wb3N0KGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgIH0sIG9uID0gKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgY29uc3QgdW5zdWJzY3JpYmVycyA9IFtdO1xuICAgICAgICBjaGFubmVscy5mb3JFYWNoKChjaGFubmVsKSA9PiB7XG4gICAgICAgICAgdW5zdWJzY3JpYmVycy5wdXNoKGNoYW5uZWwub24odHlwZSwgaGFuZGxlcikpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc3Vic2NyaWJlciA9IHsgdHlwZSwgaGFuZGxlciwgdW5zdWJzY3JpYmVycyB9O1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlcnMuYWRkKHN1YnNjcmliZXIpLCAoKSA9PiB7XG4gICAgICAgICAgdW5zdWJzY3JpYmVycy5mb3JFYWNoKCh1bnN1YikgPT4gdW5zdWIoKSksIHN1YnNjcmliZXJzLmRlbGV0ZShzdWJzY3JpYmVyKTtcbiAgICAgICAgfTtcbiAgICAgIH0sIG9uSW50ZXJuYWxFdmVudCA9ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIGNvbnN0IHVuc3Vic2NyaWJlcnMgPSBbXTtcbiAgICAgICAgY2hhbm5lbHMuZm9yRWFjaCgoY2hhbm5lbCkgPT4ge1xuICAgICAgICAgIHVuc3Vic2NyaWJlcnMucHVzaChjaGFubmVsLmFjdG9yLm9uKHR5cGUsIGhhbmRsZXIpLnVuc3Vic2NyaWJlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHN1YnNjcmliZXIgPSB7IHR5cGUsIGhhbmRsZXIsIHVuc3Vic2NyaWJlcnMgfTtcbiAgICAgICAgcmV0dXJuIGludGVybmFsRXZlbnRTdWJzY3JpYmVycy5hZGQoc3Vic2NyaWJlciksICgpID0+IHtcbiAgICAgICAgICB1bnN1YnNjcmliZXJzLmZvckVhY2goKHVuc3ViKSA9PiB1bnN1YigpKSwgaW50ZXJuYWxFdmVudFN1YnNjcmliZXJzLmRlbGV0ZShzdWJzY3JpYmVyKTtcbiAgICAgICAgfTtcbiAgICAgIH0sIG9uU3RhdHVzID0gKGhhbmRsZXIpID0+IHtcbiAgICAgICAgY29uc3QgdW5zdWJzY3JpYmVycyA9IFtdO1xuICAgICAgICBjaGFubmVscy5mb3JFYWNoKChjaGFubmVsKSA9PiB7XG4gICAgICAgICAgdW5zdWJzY3JpYmVycy5wdXNoKGNoYW5uZWwub25TdGF0dXMoKHN0YXR1cykgPT4gaGFuZGxlcih7IGNoYW5uZWw6IGNoYW5uZWwuaWQsIHN0YXR1cyB9KSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc3Vic2NyaWJlciA9IHsgaGFuZGxlciwgdW5zdWJzY3JpYmVycyB9O1xuICAgICAgICByZXR1cm4gc3RhdHVzU3Vic2NyaWJlcnMuYWRkKHN1YnNjcmliZXIpLCAoKSA9PiB7XG4gICAgICAgICAgdW5zdWJzY3JpYmVycy5mb3JFYWNoKCh1bnN1YikgPT4gdW5zdWIoKSksIHN0YXR1c1N1YnNjcmliZXJzLmRlbGV0ZShzdWJzY3JpYmVyKTtcbiAgICAgICAgfTtcbiAgICAgIH0sIHN0b3AgPSAoKSA9PiB7XG4gICAgICAgIGNoYW5uZWxzLmZvckVhY2goKGNoYW5uZWwpID0+IHtcbiAgICAgICAgICBjaGFubmVsLmRpc2Nvbm5lY3QoKSwgY2hhbm5lbC5zdG9wKCk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9uLFxuICAgICAgICBvbkludGVybmFsRXZlbnQsXG4gICAgICAgIG9uU3RhdHVzLFxuICAgICAgICBwb3N0LFxuICAgICAgICBzdGFydDogKCkgPT4gKGNoYW5uZWxzLmZvckVhY2goKGNoYW5uZWwpID0+IHtcbiAgICAgICAgICBjaGFubmVsLnN0YXJ0KCksIGNoYW5uZWwuY29ubmVjdCgpO1xuICAgICAgICB9KSwgc3RvcCksXG4gICAgICAgIHN0b3BcbiAgICAgIH07XG4gICAgfSxcbiAgICBkZXN0cm95OiAoKSA9PiB7XG4gICAgICBjb25uZWN0aW9ucy5mb3JFYWNoKCh7IGNoYW5uZWxzIH0pID0+IHtcbiAgICAgICAgY2hhbm5lbHMuZm9yRWFjaCgoY2hhbm5lbCkgPT4ge1xuICAgICAgICAgIGNsZWFudXBDaGFubmVsKGNoYW5uZWwpLCBjaGFubmVscy5kZWxldGUoY2hhbm5lbCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufSwgY3JlYXRlTm9kZU1hY2hpbmUgPSAoKSA9PiBzZXR1cCh7XG4gIHR5cGVzOiB7fSxcbiAgYWN0b3JzOiB7XG4gICAgcmVxdWVzdE1hY2hpbmU6IGNyZWF0ZVJlcXVlc3RNYWNoaW5lKCksXG4gICAgbGlzdGVuOiBjcmVhdGVMaXN0ZW5Mb2dpYygpXG4gIH0sXG4gIGFjdGlvbnM6IHtcbiAgICBcImJ1ZmZlciBpbmNvbWluZyBtZXNzYWdlXCI6IGFzc2lnbih7XG4gICAgICBoYW5kc2hha2VCdWZmZXI6ICh7IGV2ZW50LCBjb250ZXh0IH0pID0+IChhc3NlcnRFdmVudChldmVudCwgXCJtZXNzYWdlLnJlY2VpdmVkXCIpLCBbLi4uY29udGV4dC5oYW5kc2hha2VCdWZmZXIsIGV2ZW50XSlcbiAgICB9KSxcbiAgICBcImJ1ZmZlciBtZXNzYWdlXCI6IGVucXVldWVBY3Rpb25zKCh7IGVucXVldWUgfSkgPT4ge1xuICAgICAgZW5xdWV1ZS5hc3NpZ24oe1xuICAgICAgICBidWZmZXI6ICh7IGV2ZW50LCBjb250ZXh0IH0pID0+IChhc3NlcnRFdmVudChldmVudCwgXCJwb3N0XCIpLCBbXG4gICAgICAgICAgLi4uY29udGV4dC5idWZmZXIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgZGF0YTogZXZlbnQuZGF0YSxcbiAgICAgICAgICAgIHJlc29sdmFibGU6IGV2ZW50LnJlc29sdmFibGUsXG4gICAgICAgICAgICBvcHRpb25zOiBldmVudC5vcHRpb25zXG4gICAgICAgICAgfVxuICAgICAgICBdKVxuICAgICAgfSksIGVucXVldWUuZW1pdCgoeyBldmVudCB9KSA9PiAoYXNzZXJ0RXZlbnQoZXZlbnQsIFwicG9zdFwiKSwge1xuICAgICAgICB0eXBlOiBcIl9idWZmZXIuYWRkZWRcIixcbiAgICAgICAgbWVzc2FnZTogZXZlbnQuZGF0YVxuICAgICAgfSkpO1xuICAgIH0pLFxuICAgIFwiY3JlYXRlIHJlcXVlc3RcIjogYXNzaWduKHtcbiAgICAgIHJlcXVlc3RzOiAoeyBjb250ZXh0LCBldmVudCwgc2VsZiwgc3Bhd24gfSkgPT4ge1xuICAgICAgICBhc3NlcnRFdmVudChldmVudCwgXCJyZXF1ZXN0XCIpO1xuICAgICAgICBjb25zdCByZXF1ZXN0cyA9IChBcnJheS5pc0FycmF5KGV2ZW50LmRhdGEpID8gZXZlbnQuZGF0YSA6IFtldmVudC5kYXRhXSkubWFwKChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgY29uc3QgaWQgPSBgcmVxLSR7djQoKX1gO1xuICAgICAgICAgIHJldHVybiBzcGF3bihcInJlcXVlc3RNYWNoaW5lXCIsIHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgaW5wdXQ6IHtcbiAgICAgICAgICAgICAgY29ubmVjdGlvbklkOiBjb250ZXh0LmNvbm5lY3Rpb25JZCxcbiAgICAgICAgICAgICAgZGF0YTogcmVxdWVzdC5kYXRhLFxuICAgICAgICAgICAgICBkb21haW46IGNvbnRleHQuZG9tYWluLFxuICAgICAgICAgICAgICBleHBlY3RSZXNwb25zZTogcmVxdWVzdC5leHBlY3RSZXNwb25zZSxcbiAgICAgICAgICAgICAgZnJvbTogY29udGV4dC5uYW1lLFxuICAgICAgICAgICAgICBwYXJlbnRSZWY6IHNlbGYsXG4gICAgICAgICAgICAgIHJlc29sdmFibGU6IHJlcXVlc3QucmVzb2x2YWJsZSxcbiAgICAgICAgICAgICAgcmVzcG9uc2VUbzogcmVxdWVzdC5yZXNwb25zZVRvLFxuICAgICAgICAgICAgICBzaWduYWw6IHJlcXVlc3Qub3B0aW9ucz8uc2lnbmFsLFxuICAgICAgICAgICAgICBzb3VyY2VzOiBjb250ZXh0LnRhcmdldCxcbiAgICAgICAgICAgICAgc3VwcHJlc3NXYXJuaW5nczogcmVxdWVzdC5vcHRpb25zPy5zdXBwcmVzc1dhcm5pbmdzLFxuICAgICAgICAgICAgICB0YXJnZXRPcmlnaW46IGNvbnRleHQudGFyZ2V0T3JpZ2luLFxuICAgICAgICAgICAgICB0bzogY29udGV4dC5jb25uZWN0VG8sXG4gICAgICAgICAgICAgIHR5cGU6IHJlcXVlc3QudHlwZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFsuLi5jb250ZXh0LnJlcXVlc3RzLCAuLi5yZXF1ZXN0c107XG4gICAgICB9XG4gICAgfSksXG4gICAgXCJlbWl0IGhlYXJ0YmVhdFwiOiBlbWl0KCgpID0+ICh7XG4gICAgICB0eXBlOiBcIl9oZWFydGJlYXRcIlxuICAgIH0pKSxcbiAgICBcImVtaXQgcmVjZWl2ZWQgbWVzc2FnZVwiOiBlbnF1ZXVlQWN0aW9ucygoeyBlbnF1ZXVlIH0pID0+IHtcbiAgICAgIGVucXVldWUuZW1pdCgoeyBldmVudCB9KSA9PiAoYXNzZXJ0RXZlbnQoZXZlbnQsIFwibWVzc2FnZS5yZWNlaXZlZFwiKSwge1xuICAgICAgICB0eXBlOiBcIl9tZXNzYWdlXCIsXG4gICAgICAgIG1lc3NhZ2U6IGV2ZW50Lm1lc3NhZ2UuZGF0YVxuICAgICAgfSkpLCBlbnF1ZXVlLmVtaXQoKHsgZXZlbnQgfSkgPT4gKGFzc2VydEV2ZW50KGV2ZW50LCBcIm1lc3NhZ2UucmVjZWl2ZWRcIiksIHtcbiAgICAgICAgdHlwZTogZXZlbnQubWVzc2FnZS5kYXRhLnR5cGUsXG4gICAgICAgIG1lc3NhZ2U6IGV2ZW50Lm1lc3NhZ2UuZGF0YVxuICAgICAgfSkpO1xuICAgIH0pLFxuICAgIFwiZmx1c2ggYnVmZmVyXCI6IGVucXVldWVBY3Rpb25zKCh7IGVucXVldWUgfSkgPT4ge1xuICAgICAgZW5xdWV1ZS5yYWlzZSgoeyBjb250ZXh0IH0pID0+ICh7XG4gICAgICAgIHR5cGU6IFwicmVxdWVzdFwiLFxuICAgICAgICBkYXRhOiBjb250ZXh0LmJ1ZmZlci5tYXAoKHsgZGF0YSwgcmVzb2x2YWJsZSwgb3B0aW9ucyB9KSA9PiAoe1xuICAgICAgICAgIGRhdGE6IGRhdGEuZGF0YSxcbiAgICAgICAgICB0eXBlOiBkYXRhLnR5cGUsXG4gICAgICAgICAgZXhwZWN0UmVzcG9uc2U6ICEhcmVzb2x2YWJsZSxcbiAgICAgICAgICByZXNvbHZhYmxlLFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgfSkpXG4gICAgICB9KSksIGVucXVldWUuZW1pdCgoeyBjb250ZXh0IH0pID0+ICh7XG4gICAgICAgIHR5cGU6IFwiX2J1ZmZlci5mbHVzaGVkXCIsXG4gICAgICAgIG1lc3NhZ2VzOiBjb250ZXh0LmJ1ZmZlci5tYXAoKHsgZGF0YSB9KSA9PiBkYXRhKVxuICAgICAgfSkpLCBlbnF1ZXVlLmFzc2lnbih7XG4gICAgICAgIGJ1ZmZlcjogW11cbiAgICAgIH0pO1xuICAgIH0pLFxuICAgIFwiZmx1c2ggaGFuZHNoYWtlIGJ1ZmZlclwiOiBlbnF1ZXVlQWN0aW9ucygoeyBjb250ZXh0LCBlbnF1ZXVlIH0pID0+IHtcbiAgICAgIGNvbnRleHQuaGFuZHNoYWtlQnVmZmVyLmZvckVhY2goKGV2ZW50KSA9PiBlbnF1ZXVlLnJhaXNlKGV2ZW50KSksIGVucXVldWUuYXNzaWduKHtcbiAgICAgICAgaGFuZHNoYWtlQnVmZmVyOiBbXVxuICAgICAgfSk7XG4gICAgfSksXG4gICAgcG9zdDogcmFpc2UoKHsgZXZlbnQgfSkgPT4gKGFzc2VydEV2ZW50KGV2ZW50LCBcInBvc3RcIiksIHtcbiAgICAgIHR5cGU6IFwicmVxdWVzdFwiLFxuICAgICAgZGF0YToge1xuICAgICAgICBkYXRhOiBldmVudC5kYXRhLmRhdGEsXG4gICAgICAgIGV4cGVjdFJlc3BvbnNlOiAhIWV2ZW50LnJlc29sdmFibGUsXG4gICAgICAgIHR5cGU6IGV2ZW50LmRhdGEudHlwZSxcbiAgICAgICAgcmVzb2x2YWJsZTogZXZlbnQucmVzb2x2YWJsZSxcbiAgICAgICAgb3B0aW9uczogZXZlbnQub3B0aW9uc1xuICAgICAgfVxuICAgIH0pKSxcbiAgICBcInJlbW92ZSByZXF1ZXN0XCI6IGVucXVldWVBY3Rpb25zKCh7IGNvbnRleHQsIGVucXVldWUsIGV2ZW50IH0pID0+IHtcbiAgICAgIGFzc2VydEV2ZW50KGV2ZW50LCBbXCJyZXF1ZXN0LnN1Y2Nlc3NcIiwgXCJyZXF1ZXN0LmZhaWxlZFwiLCBcInJlcXVlc3QuYWJvcnRlZFwiXSksIHN0b3BDaGlsZChldmVudC5yZXF1ZXN0SWQpLCBlbnF1ZXVlLmFzc2lnbih7IHJlcXVlc3RzOiBjb250ZXh0LnJlcXVlc3RzLmZpbHRlcigoeyBpZCB9KSA9PiBpZCAhPT0gZXZlbnQucmVxdWVzdElkKSB9KTtcbiAgICB9KSxcbiAgICBcInNlbmQgcmVzcG9uc2VcIjogcmFpc2UoKHsgZXZlbnQgfSkgPT4gKGFzc2VydEV2ZW50KGV2ZW50LCBbXCJtZXNzYWdlLnJlY2VpdmVkXCIsIFwiaGVhcnRiZWF0LnJlY2VpdmVkXCJdKSwge1xuICAgICAgdHlwZTogXCJyZXF1ZXN0XCIsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHR5cGU6IE1TR19SRVNQT05TRSxcbiAgICAgICAgcmVzcG9uc2VUbzogZXZlbnQubWVzc2FnZS5kYXRhLmlkLFxuICAgICAgICBkYXRhOiB2b2lkIDBcbiAgICAgIH1cbiAgICB9KSksXG4gICAgXCJzZW5kIGhhbmRzaGFrZSBzeW4gYWNrXCI6IHJhaXNlKHtcbiAgICAgIHR5cGU6IFwicmVxdWVzdFwiLFxuICAgICAgZGF0YTogeyB0eXBlOiBNU0dfSEFORFNIQUtFX1NZTl9BQ0sgfVxuICAgIH0pLFxuICAgIFwic2V0IGNvbm5lY3Rpb24gY29uZmlnXCI6IGFzc2lnbih7XG4gICAgICBjb25uZWN0aW9uSWQ6ICh7IGV2ZW50IH0pID0+IChhc3NlcnRFdmVudChldmVudCwgXCJtZXNzYWdlLnJlY2VpdmVkXCIpLCBldmVudC5tZXNzYWdlLmRhdGEuY29ubmVjdGlvbklkKSxcbiAgICAgIHRhcmdldDogKHsgZXZlbnQgfSkgPT4gKGFzc2VydEV2ZW50KGV2ZW50LCBcIm1lc3NhZ2UucmVjZWl2ZWRcIiksIGV2ZW50Lm1lc3NhZ2Uuc291cmNlIHx8IHZvaWQgMCksXG4gICAgICB0YXJnZXRPcmlnaW46ICh7IGV2ZW50IH0pID0+IChhc3NlcnRFdmVudChldmVudCwgXCJtZXNzYWdlLnJlY2VpdmVkXCIpLCBldmVudC5tZXNzYWdlLm9yaWdpbilcbiAgICB9KVxuICB9LFxuICBndWFyZHM6IHtcbiAgICBoYXNTb3VyY2U6ICh7IGNvbnRleHQgfSkgPT4gY29udGV4dC50YXJnZXQgIT09IG51bGxcbiAgfVxufSkuY3JlYXRlTWFjaGluZSh7XG4gIC8qKiBAeHN0YXRlLWxheW91dCBONElncGdKZzVtRE9JQzVRRHNEMkV3R0lCT1lDT0FybkFDNEIwc0JBeHBYTEFOb0FNQXVvcUFBNnF3Q1d4WHF5ckVBQTlFQVZnWUFXVWdFWUpEVVFBNEpBWm1VU0pDMGNvRHNBR2hBQlBSTklZTFNFcmRPa0JPQUd6YngyMjdZVUJmVi1yUVljK0lyRElBWmdDR1hBQTJrSXdzU0NBYzNMejhnaUlJb2lha3FnQk1ES2JwMnRZUzBzcnAra1lJMHVudW51aGdwRndRNFpnUS1OVmN5QUJ1cUFEVzFWN05kV0FJTGUyVVFmSElrWkdDc1R4OEF0Rko2YUtpcEF6V090cnBDN1o1QlVXR2lOb0s2YVMyNlJMVzJ0TGFxa3FxRlNBOU5YMllBTGEwUVRDa3VEUmNyUkhNazV4cGdrNW9nSkxaU05aSVZEb1ZDRkxaaW9oYklWU0xrWExaUkhaRGd4YkhjSHJWNnJGaUJOb2xOUm9sRVZKYkNzZEdVenNveWhpRWNsbE9DMURvd2VsVm1Wck9VUFBjcXFRQUJaQlpBUVdEQ2pvdEtBTkpvMU5xZGJvQzRXaThWQlNYSUtBRGVYRFViamY0a3dGa2tFSUxiZzhSWk1IS096V0t6S0prSEphMDg2WGE0cVpTNHBVaXNVU3FVK1Fna1luc1EwemNuSmFSTERicFp3S05RU0JZc3BtMk1FeUM1S1RuYURTU2QxOGg3SzcxcTMyRXdNeFlQQTBCSkZMS1k1eVp4SXJLU1VSTTBSbkZIU0JUclFxUTliYWJRZWpCQ3IycTlYU2lCY1dDVWZqSU1DVUluNm9OeEVQR3RUV0ZGUjBSVXk3aUd6dCszSXAwWFVSWFZaS1B2VkNmSUtjenlCK3Z5enFMem9HemN1SUcwTUdUeUN6dGpSdGphSmpiSFZNTkFVVGR1MVBVaHowdllocnlMT2NTd1hNdGhCZkswWkdzTFFHQlpla0NpMEpzbzFJZEkyM1dHMDR6T0U0d0lnNmNvSWdCb3gzSW1kaTFKUmRueE5PeFNITlNRa1d0VzBtVGpNeE1RN2ZEemdjYk5LbjdXaktKZU40UGkrTUFmaitlODRNZlVNRkhiWlp3eE9IWk5EeU8wOWdRT1FqbUFoWkpDTTlJTWpJeWNLT3ZRVXdDQ2JCaUFBSTJzc2hwTmtpQjZOTEo5RUlRQlFiV09kSmxNaFlDVWpiSmtjaFhHc0Ztc0pRTVZzV2wzQnpLcDRHaUhvQVhnanlrZ0FXbWtaWjZ4eTNMWkYyRW9iQ3k2eHNRV0pRNDJrRTRGakEtRXdCU3hUalNSVWhEZ3FremdPMkJ4ZHlrVTRBdlhGUS1Lak1DOHlIS1Y2cU5KaTZXT2RjeXBjWnNYR3hlMEpHMFh5U0tqTTVsS3NNeUx3c2lBeHNZenlsRGZPTnpuVUVxcm1pKzFUaGtIcVhET05iVUxpMXdnQSAqL1xuICBpZDogXCJub2RlXCIsXG4gIGNvbnRleHQ6ICh7IGlucHV0IH0pID0+ICh7XG4gICAgYnVmZmVyOiBbXSxcbiAgICBjb25uZWN0aW9uSWQ6IG51bGwsXG4gICAgY29ubmVjdFRvOiBpbnB1dC5jb25uZWN0VG8sXG4gICAgZG9tYWluOiBpbnB1dC5kb21haW4gPz8gRE9NQUlOLFxuICAgIGhhbmRzaGFrZUJ1ZmZlcjogW10sXG4gICAgbmFtZTogaW5wdXQubmFtZSxcbiAgICByZXF1ZXN0czogW10sXG4gICAgdGFyZ2V0OiB2b2lkIDAsXG4gICAgdGFyZ2V0T3JpZ2luOiBudWxsXG4gIH0pLFxuICBvbjoge1xuICAgIFwicmVxdWVzdC5zdWNjZXNzXCI6IHtcbiAgICAgIGFjdGlvbnM6IFwicmVtb3ZlIHJlcXVlc3RcIlxuICAgIH0sXG4gICAgXCJyZXF1ZXN0LmZhaWxlZFwiOiB7XG4gICAgICBhY3Rpb25zOiBcInJlbW92ZSByZXF1ZXN0XCJcbiAgICB9LFxuICAgIFwicmVxdWVzdC5hYm9ydGVkXCI6IHtcbiAgICAgIGFjdGlvbnM6IFwicmVtb3ZlIHJlcXVlc3RcIlxuICAgIH1cbiAgfSxcbiAgaW5pdGlhbDogXCJpZGxlXCIsXG4gIHN0YXRlczoge1xuICAgIGlkbGU6IHtcbiAgICAgIGludm9rZToge1xuICAgICAgICBpZDogXCJsaXN0ZW4gZm9yIGhhbmRzaGFrZSBzeW5cIixcbiAgICAgICAgc3JjOiBcImxpc3RlblwiLFxuICAgICAgICBpbnB1dDogbGlzdGVuSW5wdXRGcm9tQ29udGV4dCh7XG4gICAgICAgICAgaW5jbHVkZTogTVNHX0hBTkRTSEFLRV9TWU4sXG4gICAgICAgICAgY291bnQ6IDFcbiAgICAgICAgfSksXG4gICAgICAgIG9uRG9uZToge1xuICAgICAgICAgIHRhcmdldDogXCJoYW5kc2hha2luZ1wiLFxuICAgICAgICAgIGd1YXJkOiBcImhhc1NvdXJjZVwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbjoge1xuICAgICAgICBcIm1lc3NhZ2UucmVjZWl2ZWRcIjoge1xuICAgICAgICAgIGFjdGlvbnM6IFwic2V0IGNvbm5lY3Rpb24gY29uZmlnXCJcbiAgICAgICAgfSxcbiAgICAgICAgcG9zdDoge1xuICAgICAgICAgIGFjdGlvbnM6IFwiYnVmZmVyIG1lc3NhZ2VcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBoYW5kc2hha2luZzoge1xuICAgICAgZW50cnk6IFwic2VuZCBoYW5kc2hha2Ugc3luIGFja1wiLFxuICAgICAgaW52b2tlOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogXCJsaXN0ZW4gZm9yIGhhbmRzaGFrZSBhY2tcIixcbiAgICAgICAgICBzcmM6IFwibGlzdGVuXCIsXG4gICAgICAgICAgaW5wdXQ6IGxpc3RlbklucHV0RnJvbUNvbnRleHQoe1xuICAgICAgICAgICAgaW5jbHVkZTogTVNHX0hBTkRTSEFLRV9BQ0ssXG4gICAgICAgICAgICBjb3VudDogMSxcbiAgICAgICAgICAgIC8vIE92ZXJyaWRlIHRoZSBkZWZhdWx0IGBtZXNzYWdlLnJlY2VpdmVkYCByZXNwb25zZVR5cGUgdG8gcHJldmVudFxuICAgICAgICAgICAgLy8gYnVmZmVyaW5nIHRoZSBhY2sgbWVzc2FnZS4gV2UgdHJhbnNpdGlvbiB0byB0aGUgY29ubmVjdGVkIHN0YXRlXG4gICAgICAgICAgICAvLyB1c2luZyBvbkRvbmUgaW5zdGVhZCBvZiBsaXN0ZW5pbmcgdG8gdGhpcyBldmVudCB1c2luZyBgb25gXG4gICAgICAgICAgICByZXNwb25zZVR5cGU6IFwiaGFuZHNoYWtlLmNvbXBsZXRlXCJcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBvbkRvbmU6IFwiY29ubmVjdGVkXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGlkOiBcImxpc3RlbiBmb3IgZGlzY29ubmVjdFwiLFxuICAgICAgICAgIHNyYzogXCJsaXN0ZW5cIixcbiAgICAgICAgICBpbnB1dDogbGlzdGVuSW5wdXRGcm9tQ29udGV4dCh7XG4gICAgICAgICAgICBpbmNsdWRlOiBNU0dfRElTQ09OTkVDVCxcbiAgICAgICAgICAgIGNvdW50OiAxLFxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiBcImRpc2Nvbm5lY3RcIlxuICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogXCJsaXN0ZW4gZm9yIG1lc3NhZ2VzXCIsXG4gICAgICAgICAgc3JjOiBcImxpc3RlblwiLFxuICAgICAgICAgIGlucHV0OiBsaXN0ZW5JbnB1dEZyb21Db250ZXh0KHtcbiAgICAgICAgICAgIGV4Y2x1ZGU6IFtNU0dfRElTQ09OTkVDVCwgTVNHX0hBTkRTSEFLRV9BQ0ssIE1TR19IRUFSVEJFQVQsIE1TR19SRVNQT05TRV1cbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgb246IHtcbiAgICAgICAgcmVxdWVzdDoge1xuICAgICAgICAgIGFjdGlvbnM6IFwiY3JlYXRlIHJlcXVlc3RcIlxuICAgICAgICB9LFxuICAgICAgICBwb3N0OiB7XG4gICAgICAgICAgYWN0aW9uczogXCJidWZmZXIgbWVzc2FnZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibWVzc2FnZS5yZWNlaXZlZFwiOiB7XG4gICAgICAgICAgYWN0aW9uczogXCJidWZmZXIgaW5jb21pbmcgbWVzc2FnZVwiXG4gICAgICAgIH0sXG4gICAgICAgIGRpc2Nvbm5lY3Q6IHtcbiAgICAgICAgICB0YXJnZXQ6IFwiaWRsZVwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbm5lY3RlZDoge1xuICAgICAgZW50cnk6IFtcImZsdXNoIGhhbmRzaGFrZSBidWZmZXJcIiwgXCJmbHVzaCBidWZmZXJcIl0sXG4gICAgICBpbnZva2U6IFtcbiAgICAgICAge1xuICAgICAgICAgIGlkOiBcImxpc3RlbiBmb3IgbWVzc2FnZXNcIixcbiAgICAgICAgICBzcmM6IFwibGlzdGVuXCIsXG4gICAgICAgICAgaW5wdXQ6IGxpc3RlbklucHV0RnJvbUNvbnRleHQoe1xuICAgICAgICAgICAgZXhjbHVkZTogW01TR19SRVNQT05TRSwgTVNHX0hFQVJUQkVBVF1cbiAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgaWQ6IFwibGlzdGVuIGZvciBoZWFydGJlYXRcIixcbiAgICAgICAgICBzcmM6IFwibGlzdGVuXCIsXG4gICAgICAgICAgaW5wdXQ6IGxpc3RlbklucHV0RnJvbUNvbnRleHQoe1xuICAgICAgICAgICAgaW5jbHVkZTogTVNHX0hFQVJUQkVBVCxcbiAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogXCJoZWFydGJlYXQucmVjZWl2ZWRcIlxuICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogXCJsaXN0ZW4gZm9yIGRpc2Nvbm5lY3RcIixcbiAgICAgICAgICBzcmM6IFwibGlzdGVuXCIsXG4gICAgICAgICAgaW5wdXQ6IGxpc3RlbklucHV0RnJvbUNvbnRleHQoe1xuICAgICAgICAgICAgaW5jbHVkZTogTVNHX0RJU0NPTk5FQ1QsXG4gICAgICAgICAgICBjb3VudDogMSxcbiAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogXCJkaXNjb25uZWN0XCJcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgb246IHtcbiAgICAgICAgcmVxdWVzdDoge1xuICAgICAgICAgIGFjdGlvbnM6IFwiY3JlYXRlIHJlcXVlc3RcIlxuICAgICAgICB9LFxuICAgICAgICBwb3N0OiB7XG4gICAgICAgICAgYWN0aW9uczogXCJwb3N0XCJcbiAgICAgICAgfSxcbiAgICAgICAgZGlzY29ubmVjdDoge1xuICAgICAgICAgIHRhcmdldDogXCJpZGxlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJtZXNzYWdlLnJlY2VpdmVkXCI6IHtcbiAgICAgICAgICBhY3Rpb25zOiBbXCJzZW5kIHJlc3BvbnNlXCIsIFwiZW1pdCByZWNlaXZlZCBtZXNzYWdlXCJdXG4gICAgICAgIH0sXG4gICAgICAgIFwiaGVhcnRiZWF0LnJlY2VpdmVkXCI6IHtcbiAgICAgICAgICBhY3Rpb25zOiBbXCJzZW5kIHJlc3BvbnNlXCIsIFwiZW1pdCBoZWFydGJlYXRcIl1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSksIGNyZWF0ZU5vZGUgPSAoaW5wdXQsIG1hY2hpbmUgPSBjcmVhdGVOb2RlTWFjaGluZSgpKSA9PiB7XG4gIGNvbnN0IGFjdG9yID0gY3JlYXRlQWN0b3IobWFjaGluZSwge1xuICAgIGlucHV0XG4gIH0pLCBvbiA9ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgY29uc3QgeyB1bnN1YnNjcmliZSB9ID0gYWN0b3Iub24oXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEB0b2RvIGB0eXBlYCB0eXBpbmdcbiAgICAgIHR5cGUsXG4gICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgaGFuZGxlcihldmVudC5tZXNzYWdlLmRhdGEpO1xuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIHVuc3Vic2NyaWJlO1xuICB9LCBvblN0YXR1cyA9IChoYW5kbGVyKSA9PiB7XG4gICAgY29uc3Qgc25hcHNob3QgPSBhY3Rvci5nZXRTbmFwc2hvdCgpO1xuICAgIGxldCBjdXJyZW50U3RhdHVzID0gdHlwZW9mIHNuYXBzaG90LnZhbHVlID09IFwic3RyaW5nXCIgPyBzbmFwc2hvdC52YWx1ZSA6IE9iamVjdC5rZXlzKHNuYXBzaG90LnZhbHVlKVswXTtcbiAgICBjb25zdCB7IHVuc3Vic2NyaWJlIH0gPSBhY3Rvci5zdWJzY3JpYmUoKHN0YXRlKSA9PiB7XG4gICAgICBjb25zdCBzdGF0dXMgPSB0eXBlb2Ygc3RhdGUudmFsdWUgPT0gXCJzdHJpbmdcIiA/IHN0YXRlLnZhbHVlIDogT2JqZWN0LmtleXMoc3RhdGUudmFsdWUpWzBdO1xuICAgICAgY3VycmVudFN0YXR1cyAhPT0gc3RhdHVzICYmIChjdXJyZW50U3RhdHVzID0gc3RhdHVzLCBoYW5kbGVyKHN0YXR1cykpO1xuICAgIH0pO1xuICAgIHJldHVybiB1bnN1YnNjcmliZTtcbiAgfSwgcG9zdCA9IChkYXRhKSA9PiB7XG4gICAgYWN0b3Iuc2VuZCh7IHR5cGU6IFwicG9zdFwiLCBkYXRhIH0pO1xuICB9LCBmZXRjaCA9IChkYXRhLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgcmVzb2x2YWJsZSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHJldHVybiBhY3Rvci5zZW5kKHtcbiAgICAgIHR5cGU6IFwicG9zdFwiLFxuICAgICAgZGF0YSxcbiAgICAgIHJlc29sdmFibGUsXG4gICAgICBvcHRpb25zXG4gICAgfSksIHJlc29sdmFibGUucHJvbWlzZTtcbiAgfSwgc3RvcCA9ICgpID0+IHtcbiAgICBhY3Rvci5zdG9wKCk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgYWN0b3IsXG4gICAgZmV0Y2gsXG4gICAgbWFjaGluZSxcbiAgICBvbixcbiAgICBvblN0YXR1cyxcbiAgICBwb3N0LFxuICAgIHN0YXJ0OiAoKSA9PiAoYWN0b3Iuc3RhcnQoKSwgc3RvcCksXG4gICAgc3RvcFxuICB9O1xufTtcbmV4cG9ydCB7XG4gIERPTUFJTixcbiAgSEFORFNIQUtFX0lOVEVSVkFMLFxuICBIQU5EU0hBS0VfTVNHX1RZUEVTLFxuICBIRUFSVEJFQVRfSU5URVJWQUwsXG4gIElOVEVSTkFMX01TR19UWVBFUyxcbiAgTVNHX0RJU0NPTk5FQ1QsXG4gIE1TR19IQU5EU0hBS0VfQUNLLFxuICBNU0dfSEFORFNIQUtFX1NZTixcbiAgTVNHX0hBTkRTSEFLRV9TWU5fQUNLLFxuICBNU0dfSEVBUlRCRUFULFxuICBNU0dfUkVTUE9OU0UsXG4gIFJFU1BPTlNFX1RJTUVPVVQsXG4gIGNyZWF0ZUNoYW5uZWwsXG4gIGNyZWF0ZUNoYW5uZWxNYWNoaW5lLFxuICBjcmVhdGVDb250cm9sbGVyLFxuICBjcmVhdGVMaXN0ZW5Mb2dpYyxcbiAgY3JlYXRlTm9kZSxcbiAgY3JlYXRlTm9kZU1hY2hpbmUsXG4gIGNyZWF0ZVJlcXVlc3RNYWNoaW5lXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@sanity/comlink/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@sanity/next-loader/dist/_chunks-es/PresentationComlink.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@sanity/next-loader/dist/_chunks-es/PresentationComlink.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ PresentationComlink; }\n/* harmony export */ });\n/* harmony import */ var _sanity_comlink__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sanity/comlink */ \"(app-pages-browser)/./node_modules/@sanity/comlink/dist/index.js\");\n/* harmony import */ var _sanity_next_loader_server_actions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @sanity/next-loader/server-actions */ \"(app-pages-browser)/./node_modules/@sanity/next-loader/dist/server-actions.js\");\n/* harmony import */ var next_navigation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/navigation.js */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var use_effect_event__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! use-effect-event */ \"(app-pages-browser)/./node_modules/use-effect-event/dist/index.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./context.js */ \"(app-pages-browser)/./node_modules/@sanity/next-loader/dist/_chunks-es/context.js\");\n\n\n\n\n\n\nconst channelsToComlinkMap = {\n  \"handshake/syn\": _sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.MSG_HANDSHAKE_SYN,\n  \"handshake/syn-ack\": _sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.MSG_HANDSHAKE_SYN_ACK,\n  \"handshake/ack\": _sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.MSG_HANDSHAKE_ACK,\n  \"channel/response\": _sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.MSG_RESPONSE,\n  \"channel/heartbeat\": _sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.MSG_HEARTBEAT,\n  \"channel/disconnect\": _sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.MSG_DISCONNECT,\n  \"overlay/focus\": \"visual-editing/focus\",\n  \"overlay/navigate\": \"visual-editing/navigate\",\n  \"overlay/toggle\": \"visual-editing/toggle\",\n  \"presentation/toggleOverlay\": \"presentation/toggle-overlay\"\n}, comlinkToChannelsMap = {\n  [_sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.MSG_HANDSHAKE_SYN]: \"handshake/syn\",\n  [_sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.MSG_HANDSHAKE_SYN_ACK]: \"handshake/syn-ack\",\n  [_sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.MSG_HANDSHAKE_ACK]: \"handshake/ack\",\n  [_sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.MSG_RESPONSE]: \"channel/response\",\n  [_sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.MSG_HEARTBEAT]: \"channel/heartbeat\",\n  [_sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.MSG_DISCONNECT]: \"channel/disconnect\",\n  \"visual-editing/focus\": \"overlay/focus\",\n  \"visual-editing/navigate\": \"overlay/navigate\",\n  \"visual-editing/toggle\": \"overlay/toggle\",\n  \"presentation/toggle-overlay\": \"presentation/toggleOverlay\"\n}, convertToComlinkEvent = (event) => {\n  const { data } = event;\n  return data && typeof data == \"object\" && \"domain\" in data && \"type\" in data && \"from\" in data && \"to\" in data && (data.domain === \"sanity/channels\" && (data.domain = _sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.DOMAIN), data.to === \"overlays\" && (data.to = \"visual-editing\"), data.from === \"overlays\" && (data.from = \"visual-editing\"), data.type = channelsToComlinkMap[data.type] ?? data.type), event;\n}, convertToChannelsMessage = (message) => (message.domain === _sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.DOMAIN && (message.domain = \"sanity/channels\"), message.to === \"visual-editing\" && (message.to = \"overlays\"), message.from === \"visual-editing\" && (message.from = \"overlays\"), message.type = comlinkToChannelsMap[message.type] ?? message.type, message.type === \"channel/response\" && message.responseTo && !message.data && (message.data = { responseTo: message.responseTo }), message), sendAsChannelsMessage = ({ context }, params) => {\n  const { sources, targetOrigin } = context, message = convertToChannelsMessage(params.message);\n  sources.forEach((source) => {\n    source.postMessage(message, { targetOrigin });\n  });\n}, createCompatibilityActors = () => ({\n  listen: (0,_sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.createListenLogic)(convertToComlinkEvent),\n  requestMachine: (0,_sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.createRequestMachine)().provide({\n    actions: {\n      \"send message\": sendAsChannelsMessage\n    }\n  })\n});\nfunction PresentationComlink(props) {\n  const { draftModeEnabled, draftModePerspective } = props, router = (0,next_navigation_js__WEBPACK_IMPORTED_MODULE_0__.useRouter)(), handlePerspectiveChange = (0,use_effect_event__WEBPACK_IMPORTED_MODULE_3__.useEffectEvent)(\n    (perspective, signal) => {\n      draftModeEnabled && perspective !== draftModePerspective && (0,_sanity_next_loader_server_actions__WEBPACK_IMPORTED_MODULE_4__.setPerspectiveCookie)(perspective).then(() => {\n        signal.aborted || router.refresh();\n      }).catch((reason) => console.error(\"Failed to set the preview perspective cookie\", reason));\n    }\n  );\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const comlink = (0,_sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.createNode)(\n      {\n        name: \"loaders\",\n        connectTo: \"presentation\"\n      },\n      (0,_sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.createNodeMachine)().provide({\n        actors: createCompatibilityActors()\n      })\n    );\n    let controller;\n    comlink.on(\"loader/perspective\", (data) => {\n      controller?.abort(), controller = new AbortController(), handlePerspectiveChange(data.perspective, controller.signal);\n    });\n    const stop = comlink.start();\n    return (0,_context_js__WEBPACK_IMPORTED_MODULE_5__.setComlink)(comlink), () => {\n      stop();\n    };\n  }, [handlePerspectiveChange]), null;\n}\nPresentationComlink.displayName = \"PresentationComlink\";\n\n//# sourceMappingURL=PresentationComlink.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L25leHQtbG9hZGVyL2Rpc3QvX2NodW5rcy1lcy9QcmVzZW50YXRpb25Db21saW5rLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBMk47QUFDako7QUFDM0I7QUFDYjtBQUNnQjtBQUNSO0FBQzFDO0FBQ0EsbUJBQW1CLDhEQUFpQjtBQUNwQyx1QkFBdUIsa0VBQXFCO0FBQzVDLG1CQUFtQiw4REFBaUI7QUFDcEMsc0JBQXNCLHlEQUFZO0FBQ2xDLHVCQUF1QiwwREFBYTtBQUNwQyx3QkFBd0IsMkRBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsR0FBRyw4REFBaUI7QUFDcEIsR0FBRyxrRUFBcUI7QUFDeEIsR0FBRyw4REFBaUI7QUFDcEIsR0FBRyx5REFBWTtBQUNmLEdBQUcsMERBQWE7QUFDaEIsR0FBRywyREFBYztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxVQUFVLE9BQU87QUFDakIseUtBQXlLLG1EQUFNO0FBQy9LLENBQUMsOERBQThELG1EQUFNLDZVQUE2VSxnQ0FBZ0Msd0NBQXdDLFNBQVM7QUFDbmUsVUFBVSx3QkFBd0I7QUFDbEM7QUFDQSxrQ0FBa0MsY0FBYztBQUNoRCxHQUFHO0FBQ0gsQ0FBQztBQUNELFVBQVUsa0VBQWlCO0FBQzNCLGtCQUFrQixxRUFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBLFVBQVUseUNBQXlDLGtCQUFrQiw2REFBUyw4QkFBOEIsZ0VBQWM7QUFDMUg7QUFDQSxrRUFBa0Usd0ZBQW9CO0FBQ3RGO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTLGdEQUFTO0FBQ2xCLG9CQUFvQiwyREFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTSxrRUFBaUI7QUFDdkI7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxXQUFXLHVEQUFVO0FBQ3JCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvbmV4dC1sb2FkZXIvZGlzdC9fY2h1bmtzLWVzL1ByZXNlbnRhdGlvbkNvbWxpbmsuanM/MGJjOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVMaXN0ZW5Mb2dpYywgY3JlYXRlUmVxdWVzdE1hY2hpbmUsIERPTUFJTiwgTVNHX0hBTkRTSEFLRV9TWU4sIE1TR19IQU5EU0hBS0VfU1lOX0FDSywgTVNHX0hBTkRTSEFLRV9BQ0ssIE1TR19SRVNQT05TRSwgTVNHX0hFQVJUQkVBVCwgTVNHX0RJU0NPTk5FQ1QsIGNyZWF0ZU5vZGUsIGNyZWF0ZU5vZGVNYWNoaW5lIH0gZnJvbSBcIkBzYW5pdHkvY29tbGlua1wiO1xuaW1wb3J0IHsgc2V0UGVyc3BlY3RpdmVDb29raWUgfSBmcm9tIFwiQHNhbml0eS9uZXh0LWxvYWRlci9zZXJ2ZXItYWN0aW9uc1wiO1xuaW1wb3J0IHsgdXNlUm91dGVyIH0gZnJvbSBcIm5leHQvbmF2aWdhdGlvbi5qc1wiO1xuaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VFZmZlY3RFdmVudCB9IGZyb20gXCJ1c2UtZWZmZWN0LWV2ZW50XCI7XG5pbXBvcnQgeyBzZXRDb21saW5rIH0gZnJvbSBcIi4vY29udGV4dC5qc1wiO1xuY29uc3QgY2hhbm5lbHNUb0NvbWxpbmtNYXAgPSB7XG4gIFwiaGFuZHNoYWtlL3N5blwiOiBNU0dfSEFORFNIQUtFX1NZTixcbiAgXCJoYW5kc2hha2Uvc3luLWFja1wiOiBNU0dfSEFORFNIQUtFX1NZTl9BQ0ssXG4gIFwiaGFuZHNoYWtlL2Fja1wiOiBNU0dfSEFORFNIQUtFX0FDSyxcbiAgXCJjaGFubmVsL3Jlc3BvbnNlXCI6IE1TR19SRVNQT05TRSxcbiAgXCJjaGFubmVsL2hlYXJ0YmVhdFwiOiBNU0dfSEVBUlRCRUFULFxuICBcImNoYW5uZWwvZGlzY29ubmVjdFwiOiBNU0dfRElTQ09OTkVDVCxcbiAgXCJvdmVybGF5L2ZvY3VzXCI6IFwidmlzdWFsLWVkaXRpbmcvZm9jdXNcIixcbiAgXCJvdmVybGF5L25hdmlnYXRlXCI6IFwidmlzdWFsLWVkaXRpbmcvbmF2aWdhdGVcIixcbiAgXCJvdmVybGF5L3RvZ2dsZVwiOiBcInZpc3VhbC1lZGl0aW5nL3RvZ2dsZVwiLFxuICBcInByZXNlbnRhdGlvbi90b2dnbGVPdmVybGF5XCI6IFwicHJlc2VudGF0aW9uL3RvZ2dsZS1vdmVybGF5XCJcbn0sIGNvbWxpbmtUb0NoYW5uZWxzTWFwID0ge1xuICBbTVNHX0hBTkRTSEFLRV9TWU5dOiBcImhhbmRzaGFrZS9zeW5cIixcbiAgW01TR19IQU5EU0hBS0VfU1lOX0FDS106IFwiaGFuZHNoYWtlL3N5bi1hY2tcIixcbiAgW01TR19IQU5EU0hBS0VfQUNLXTogXCJoYW5kc2hha2UvYWNrXCIsXG4gIFtNU0dfUkVTUE9OU0VdOiBcImNoYW5uZWwvcmVzcG9uc2VcIixcbiAgW01TR19IRUFSVEJFQVRdOiBcImNoYW5uZWwvaGVhcnRiZWF0XCIsXG4gIFtNU0dfRElTQ09OTkVDVF06IFwiY2hhbm5lbC9kaXNjb25uZWN0XCIsXG4gIFwidmlzdWFsLWVkaXRpbmcvZm9jdXNcIjogXCJvdmVybGF5L2ZvY3VzXCIsXG4gIFwidmlzdWFsLWVkaXRpbmcvbmF2aWdhdGVcIjogXCJvdmVybGF5L25hdmlnYXRlXCIsXG4gIFwidmlzdWFsLWVkaXRpbmcvdG9nZ2xlXCI6IFwib3ZlcmxheS90b2dnbGVcIixcbiAgXCJwcmVzZW50YXRpb24vdG9nZ2xlLW92ZXJsYXlcIjogXCJwcmVzZW50YXRpb24vdG9nZ2xlT3ZlcmxheVwiXG59LCBjb252ZXJ0VG9Db21saW5rRXZlbnQgPSAoZXZlbnQpID0+IHtcbiAgY29uc3QgeyBkYXRhIH0gPSBldmVudDtcbiAgcmV0dXJuIGRhdGEgJiYgdHlwZW9mIGRhdGEgPT0gXCJvYmplY3RcIiAmJiBcImRvbWFpblwiIGluIGRhdGEgJiYgXCJ0eXBlXCIgaW4gZGF0YSAmJiBcImZyb21cIiBpbiBkYXRhICYmIFwidG9cIiBpbiBkYXRhICYmIChkYXRhLmRvbWFpbiA9PT0gXCJzYW5pdHkvY2hhbm5lbHNcIiAmJiAoZGF0YS5kb21haW4gPSBET01BSU4pLCBkYXRhLnRvID09PSBcIm92ZXJsYXlzXCIgJiYgKGRhdGEudG8gPSBcInZpc3VhbC1lZGl0aW5nXCIpLCBkYXRhLmZyb20gPT09IFwib3ZlcmxheXNcIiAmJiAoZGF0YS5mcm9tID0gXCJ2aXN1YWwtZWRpdGluZ1wiKSwgZGF0YS50eXBlID0gY2hhbm5lbHNUb0NvbWxpbmtNYXBbZGF0YS50eXBlXSA/PyBkYXRhLnR5cGUpLCBldmVudDtcbn0sIGNvbnZlcnRUb0NoYW5uZWxzTWVzc2FnZSA9IChtZXNzYWdlKSA9PiAobWVzc2FnZS5kb21haW4gPT09IERPTUFJTiAmJiAobWVzc2FnZS5kb21haW4gPSBcInNhbml0eS9jaGFubmVsc1wiKSwgbWVzc2FnZS50byA9PT0gXCJ2aXN1YWwtZWRpdGluZ1wiICYmIChtZXNzYWdlLnRvID0gXCJvdmVybGF5c1wiKSwgbWVzc2FnZS5mcm9tID09PSBcInZpc3VhbC1lZGl0aW5nXCIgJiYgKG1lc3NhZ2UuZnJvbSA9IFwib3ZlcmxheXNcIiksIG1lc3NhZ2UudHlwZSA9IGNvbWxpbmtUb0NoYW5uZWxzTWFwW21lc3NhZ2UudHlwZV0gPz8gbWVzc2FnZS50eXBlLCBtZXNzYWdlLnR5cGUgPT09IFwiY2hhbm5lbC9yZXNwb25zZVwiICYmIG1lc3NhZ2UucmVzcG9uc2VUbyAmJiAhbWVzc2FnZS5kYXRhICYmIChtZXNzYWdlLmRhdGEgPSB7IHJlc3BvbnNlVG86IG1lc3NhZ2UucmVzcG9uc2VUbyB9KSwgbWVzc2FnZSksIHNlbmRBc0NoYW5uZWxzTWVzc2FnZSA9ICh7IGNvbnRleHQgfSwgcGFyYW1zKSA9PiB7XG4gIGNvbnN0IHsgc291cmNlcywgdGFyZ2V0T3JpZ2luIH0gPSBjb250ZXh0LCBtZXNzYWdlID0gY29udmVydFRvQ2hhbm5lbHNNZXNzYWdlKHBhcmFtcy5tZXNzYWdlKTtcbiAgc291cmNlcy5mb3JFYWNoKChzb3VyY2UpID0+IHtcbiAgICBzb3VyY2UucG9zdE1lc3NhZ2UobWVzc2FnZSwgeyB0YXJnZXRPcmlnaW4gfSk7XG4gIH0pO1xufSwgY3JlYXRlQ29tcGF0aWJpbGl0eUFjdG9ycyA9ICgpID0+ICh7XG4gIGxpc3RlbjogY3JlYXRlTGlzdGVuTG9naWMoY29udmVydFRvQ29tbGlua0V2ZW50KSxcbiAgcmVxdWVzdE1hY2hpbmU6IGNyZWF0ZVJlcXVlc3RNYWNoaW5lKCkucHJvdmlkZSh7XG4gICAgYWN0aW9uczoge1xuICAgICAgXCJzZW5kIG1lc3NhZ2VcIjogc2VuZEFzQ2hhbm5lbHNNZXNzYWdlXG4gICAgfVxuICB9KVxufSk7XG5mdW5jdGlvbiBQcmVzZW50YXRpb25Db21saW5rKHByb3BzKSB7XG4gIGNvbnN0IHsgZHJhZnRNb2RlRW5hYmxlZCwgZHJhZnRNb2RlUGVyc3BlY3RpdmUgfSA9IHByb3BzLCByb3V0ZXIgPSB1c2VSb3V0ZXIoKSwgaGFuZGxlUGVyc3BlY3RpdmVDaGFuZ2UgPSB1c2VFZmZlY3RFdmVudChcbiAgICAocGVyc3BlY3RpdmUsIHNpZ25hbCkgPT4ge1xuICAgICAgZHJhZnRNb2RlRW5hYmxlZCAmJiBwZXJzcGVjdGl2ZSAhPT0gZHJhZnRNb2RlUGVyc3BlY3RpdmUgJiYgc2V0UGVyc3BlY3RpdmVDb29raWUocGVyc3BlY3RpdmUpLnRoZW4oKCkgPT4ge1xuICAgICAgICBzaWduYWwuYWJvcnRlZCB8fCByb3V0ZXIucmVmcmVzaCgpO1xuICAgICAgfSkuY2F0Y2goKHJlYXNvbikgPT4gY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBzZXQgdGhlIHByZXZpZXcgcGVyc3BlY3RpdmUgY29va2llXCIsIHJlYXNvbikpO1xuICAgIH1cbiAgKTtcbiAgcmV0dXJuIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY29tbGluayA9IGNyZWF0ZU5vZGUoXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwibG9hZGVyc1wiLFxuICAgICAgICBjb25uZWN0VG86IFwicHJlc2VudGF0aW9uXCJcbiAgICAgIH0sXG4gICAgICBjcmVhdGVOb2RlTWFjaGluZSgpLnByb3ZpZGUoe1xuICAgICAgICBhY3RvcnM6IGNyZWF0ZUNvbXBhdGliaWxpdHlBY3RvcnMoKVxuICAgICAgfSlcbiAgICApO1xuICAgIGxldCBjb250cm9sbGVyO1xuICAgIGNvbWxpbmsub24oXCJsb2FkZXIvcGVyc3BlY3RpdmVcIiwgKGRhdGEpID0+IHtcbiAgICAgIGNvbnRyb2xsZXI/LmFib3J0KCksIGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCksIGhhbmRsZVBlcnNwZWN0aXZlQ2hhbmdlKGRhdGEucGVyc3BlY3RpdmUsIGNvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICB9KTtcbiAgICBjb25zdCBzdG9wID0gY29tbGluay5zdGFydCgpO1xuICAgIHJldHVybiBzZXRDb21saW5rKGNvbWxpbmspLCAoKSA9PiB7XG4gICAgICBzdG9wKCk7XG4gICAgfTtcbiAgfSwgW2hhbmRsZVBlcnNwZWN0aXZlQ2hhbmdlXSksIG51bGw7XG59XG5QcmVzZW50YXRpb25Db21saW5rLmRpc3BsYXlOYW1lID0gXCJQcmVzZW50YXRpb25Db21saW5rXCI7XG5leHBvcnQge1xuICBQcmVzZW50YXRpb25Db21saW5rIGFzIGRlZmF1bHRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QcmVzZW50YXRpb25Db21saW5rLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@sanity/next-loader/dist/_chunks-es/PresentationComlink.js\n"));

/***/ })

}]);